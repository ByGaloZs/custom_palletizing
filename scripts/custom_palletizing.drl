# =====================================================================
# Palletizing Script (Doosan DRL)
# =====================================================================

# ---------------------- frames ----------------------
# ID de los frames enseñados en el controlador

# Frames de TRABAJO (los que usa todo el programa para pick/place)
conv_frame  = 101   # Frame del conveyor (pick) - TRABAJO
left_frame  = 102   # Frame del pallet izquierdo - TRABAJO
right_frame = 103   # Frame del pallet derecho - TRABAJO

# Frames ORIGINALES nivel 0 (enseñados manualmente con el lifter abajo,
# todo respecto al WORLD). Estos NUNCA se modifican desde código.
conv_frame_orig  = 191   # conveyor original nivel 0
left_frame_orig  = 192   # pallet izquierdo original nivel 0
right_frame_orig = 193   # pallet derecho original nivel 0

# ---------------------- parámetros globales ---------
# Modo de orientación: FIX XYZ (RX, RY, RZ fijos, no ELR).
rot_mode = DR_FIX_XYZ

# Offsets en Z para APPROACH y RETRACT con respecto al PLACE
dz_app = 150.0     # Distancia en Z para aproximación (APP)
dz_ret = 200.0     # Distancia en Z para retract (RET)

# Offsets en X/Y sólo para APPROACH de PLACE (personalizables)
dx_app = 0.0       # Offset en X del APPROACH respecto al slot
dy_app = 0.0       # Offset en Y del APPROACH respecto al slot

# ---------------------- velocidades -----------------
# Velocidades y aceleraciones de joint (vj/aj) y lineales (vl/al)
# Se separa en "rápido" y "lento" para pick/place.
vj_fast = 80;  aj_fast = 80
vj_slow = 60;  aj_slow = 60
vl_fast = 1000; al_fast = 1000
vl_slow = 800;  al_slow = 800

# ---------------------- poses joint auxiliares ------  
# Home general del robot (posición segura de referencia)
home = posj(-90.00, 0.00, 90.00, 0.00, 90.00, 90.00)

# Posiciones "up" sobre zonas clave (hubs de seguridad):
up_conv  = posj(-80.61, 29.87, 65.62, 0.00, 84.50, 99.38)  # Hub sobre conveyor
up_left  = posj(4.58, -8.86, 98.00, 0.00, 90.85, 94.58)  # Hub sobre pallet izquierdo
up_right = posj(-175.42, -8.86, 98.01, 0.00, 90.86, 94.58)  # Hub sobre pallet derecho

# Posición segura antes de bajar el lifter por completo.
safe_pose = posj(0.00, 0.00, 0.00, 0.00, 0.00, 90.00)

# ---------------------- I/O gripper -----------------
# Definición de las salidas digitales que controlan el gripper
do_a = 1  # DO para "mitad A" o una vía del gripper
do_b = 2  # DO para "mitad B" o la otra vía del gripper

# Funciones de control del gripper (FULL / HALF A / HALF B / RELEASE)
def grip_full():
    """
    Activa ambas salidas -> agarra la caja completa.
    """
    set_digital_output(do_a, ON)
    set_digital_output(do_b, ON)
    wait(0.2)

def grip_half_a():
    """
    Sólo activa 'A' -> agarra media caja tipo A.
    """
    set_digital_output(do_a, ON)
    set_digital_output(do_b, OFF)
    wait(0.2)

def grip_half_b():
    """
    Sólo activa 'B' -> agarra media caja tipo B.
    """
    set_digital_output(do_a, OFF)
    set_digital_output(do_b, ON)
    wait(0.2)

def rel_full():
    """
    Libera ambas mitades -> suelta caja completa.
    """
    set_digital_output(do_a, OFF)
    set_digital_output(do_b, OFF)
    wait(0.2)

def rel_half_a():
    """
    Libera sólo la mitad A (Half-A).
    """
    set_digital_output(do_a, OFF)
    wait(0.15)

def rel_half_b():
    """
    Libera sólo la mitad B (Half-B).
    """
    set_digital_output(do_b, OFF)
    wait(0.15)


# =====================================================================
# Sensores de seguridad
# =====================================================================

# Ejemplo de mapeo futuro de DI (reemplazar con IDs reales):
# di_conv_ready     = 10   # Conveyor listo (todas las cajas acomodadas)
# di_conv_sensor_a  = 11   # Sensor A en conveyor (detección lado A)
# di_conv_sensor_b  = 12   # Sensor B en conveyor (detección lado B)
# di_pallet_left    = 20   # Limit switch pallet izquierdo presente
# di_pallet_right   = 21   # Limit switch pallet derecho presente

def wait_conveyor_ready():
    """
    Esperar a que el conveyor tenga lista la fila completa de cajas antes del pick.
    De momento NO bloquea nada; la lógica con DI se deja comentada para futuro.
    """
    # while get_digital_input(di_conv_ready) == OFF:
    #     tp_log("Esperando a que el conveyor esté listo...")
    #     wait(0.2)
    return

def read_conv_box_state():
    """
    Determinar si la caja en conveyor es completa o media usando 2 sensores.
    Devuelve string: "none" / "half" / "full".
    Actualmente devuelve "full" para no modificar la lógica.
    """
    # sA = get_digital_input(di_conv_sensor_a)
    # sB = get_digital_input(di_conv_sensor_b)
    # if sA == OFF and sB == OFF:
    #     return "none"
    # if (sA == ON and sB == OFF) or (sA == OFF and sB == ON):
    #     return "half"
    # if sA == ON and sB == ON:
    #     return "full"
    return "full"

def wait_remove_finished_pallet(side):
    """
    Espera a que retiren la tarima terminada del lado indicado ('L' o 'R').
    Lógica con DI comentada para futura activación.
    """
    # di_pal = di_pallet_left if side == "L" else di_pallet_right
    # while get_digital_input(di_pal) == ON:
    #     tp_log("Esperando a que retiren la tarima del lado " + side + "...")
    #     wait(0.5)
    return

def wait_new_pallet(side):
    """
    Espera a que coloquen una nueva tarima en el lado indicado ('L' o 'R').
    Lógica con DI comentada para futura activación.
    """
    # di_pal = di_pallet_left if side == "L" else di_pallet_right
    # while get_digital_input(di_pal) == OFF:
    #     tp_log("Esperando nueva tarima en lado " + side + "...")
    #     wait(0.5)
    return


# =====================================================================
# LIFTER100 (or_lift) - Lógica multinivel + seguridad + compensación
# =====================================================================

# Tramos mecánicos del lifter
DZ_LIFTER_1 = 400.0         # primer tramo
DZ_LIFTER_2 = 270.0         # segundo tramo (total ≈ 670 mm)

# Mapa lógico por cama (0-based):
#   0..3 -> nivel 0 (0 mm, lifter abajo)
#   4..6 -> nivel 1 (+400 mm)
#   7..8 -> nivel 2 (+400+270 mm)
def lifter_level_for_layer(layer):
    """
    Devuelve el nivel lógico del lifter según la cama (layer 0-based):
      0-3 -> 0
      4-6 -> 1
      7-8 -> 2
    """
    if layer <= 3:
        return 0
    elif layer <= 6:
        return 1
    else:
        return 2

def _level_offset(level):
    """
    Devuelve el offset total en Z según el nivel del lifter.
    Este offset se usa para compensar frames (bajan en Z cuando el lifter sube).
    """
    if level == 0:
        return 0.0
    elif level == 1:
        return DZ_LIFTER_1
    elif level == 2:
        return DZ_LIFTER_1 + DZ_LIFTER_2
    return 0.0

def lifter_target_pos_for_level(level):
    """
    Posición objetivo en mm del Lift100 para un nivel lógico:
      level 0 ->   0 mm
      level 1 -> 400 mm
      level 2 -> 670 mm
    """
    if level == 0:
        return 0.0
    elif level == 1:
        return 400.0
    elif level == 2:
        return 670.0
    return 0.0


def lifter_level_from_pos(pos):
    """
    Estima el nivel lógico (0,1,2) según la posición real [mm] del Lift100.
    Ajusta los umbrales según los valores reales de tu instalación.
    """
    # Ejemplo: 0..200 => nivel 0, 200..540 => nivel 1, >540 => nivel 2
    if pos < 200.0:
        return 0
    elif pos < 540.0:
        return 1
    else:
        return 2


# Estado actual del lifter (nivel lógico 0/1/2)
_lifter_level = 0


# ---------------------- helpers de seguridad Lift100 -----------------

def lifter_wait_ready(timeout=15.0):
    """
    Espera a que el Lift100 termine cualquier movimiento (isBusy == False).
    Usa un timeout para evitar bucles infinitos.
    """
    t = 0.0
    while or_lift.isBusy():
        wait(0.1)
        t = t + 0.1
        if t >= timeout:
            tp_log("TIMEOUT esperando a que el Lift100 termine el movimiento.")
            break

def lifter_check_error():
    """
    Consulta or_lift.get_error() y registra el código si no es 0.
    NO detiene el programa, sólo deja traza.
    """
    err = or_lift.get_error()
    if err != 0:
        tp_log("ADVERTENCIA: Lift100 error code = " + str(err))
    return err

def lifter_check_position(level, tol=5.0):
    """
    Verifica que el Lift100 esté dentro de una tolerancia ±tol [mm]
    alrededor de la posición esperada para 'level'.
    """
    if not or_lift.isconn():
        tp_log("Lift100 no conectado; no se puede verificar posición.")
        return False

    pos = or_lift.get_pos()
    tgt = lifter_target_pos_for_level(level)
    if abs(pos - tgt) <= tol:
        return True

    tp_log("ADVERTENCIA: Lift100 desincronizado. level=" + str(level) +
           " pos=" + str(pos) + " esperado=" + str(tgt))
    return False

def lifter_safe_init():
    """
    Verifica conexión e inicialización del Lift100.
    Si no está inicializado, ejecuta or_lift.init() y espera a que termine.
    NO toca frames ni niveles, sólo deja el Lift100 referenciado.
    """
    if not or_lift.isconn():
        tp_log("ERROR: Lift100 no conectado (or_lift.isconn() == False).")
        return

    if or_lift.isInit():
        tp_log("Lift100 ya está inicializado.")
        return

    tp_log("Inicializando Lift100...")
    or_lift.init()
    lifter_wait_ready()

    if not or_lift.isInit():
        tp_log("ADVERTENCIA: or_lift.isInit() sigue en False después de init().")
    else:
        tp_log("Lift100 inicializado correctamente.")


# ---------------------- frames + nivel lifter ------------------------

def _lifter_do_set_level(level):
    """
    Ajusta el Lift100 al nivel indicado usando or_lift.move().
    Niveles permitidos:
      0 -> ~0 mm
      1 -> ~400 mm
      2 -> ~670 mm
    Incluye:
      - Verificación de conexión.
      - Inicialización segura si aún no está init.
      - Espera a que termine el movimiento (isBusy).
      - Chequeo de error y de posición final.
    """
    # Asegurar conexión e init
    lifter_safe_init()
    if not or_lift.isconn():
        tp_log("No se puede mover Lift100: sin conexión.")
        return

    # Nivel objetivo → posición objetivo
    if not (level == 0 or level == 1 or level == 2):
        tp_log("Nivel Lift100 inválido: " + str(level) +
               ". Re-inicializando a posición 0.")
        or_lift.init()
        lifter_wait_ready()
        lifter_check_error()
        return

    tgt = lifter_target_pos_for_level(level)

    # Si ya está dentro de tolerancia y no está ocupado, no mover
    cur = or_lift.get_pos()
    if abs(cur - tgt) < 2.0 and (not or_lift.isBusy()):
        tp_log("Lift100 ya en nivel " + str(level) +
               " (pos=" + str(cur) + " mm).")
        return

    tp_log("Moviendo Lift100 a nivel " + str(level) +
           " (" + str(tgt) + " mm).")

    # Movimiento con velocidad razonable dentro del rango 10–100 mm/s
    or_lift.move(tgt, 80.0)

    # Esperar a que termine
    lifter_wait_ready()

    # Revisar si hay errores
    lifter_check_error()

    # Verificar posición final
    lifter_check_position(level)


def apply_level_to_frames(level):
    """
    A partir de los frames ORIGINALES nivel 0 (191, 192, 193),
    escribe los frames de trabajo (101, 102, 103) compensando en Z
    según el nivel lógico del lifter (0,1,2).

    Regla:
      new_z = z_original - offset(level)
    donde offset(level) usa _level_offset(level).
    """
    dz = _level_offset(level)

    # Lista de mapeos (frame_original -> frame_trabajo)
    pairs = [
        (conv_frame_orig,  conv_frame),
        (left_frame_orig,  left_frame),
        (right_frame_orig, right_frame)
    ]

    for f_orig, f_work in pairs:
        pose_orig, ref_orig = get_user_cart_coord(f_orig)

        # Se mantiene X, Y, RX, RY, RZ; sólo se compensa Z
        new_pose = posx(
            pose_orig[0],              # X
            pose_orig[1],              # Y
            pose_orig[2] - dz,         # Z compensada
            pose_orig[3],              # RX
            pose_orig[4],              # RY
            pose_orig[5],              # RZ
            rot_mode
        )

        # Escribimos en el frame de TRABAJO correspondiente
        overwrite_user_cart_coord(f_work, new_pose, ref_orig, DR_TEMPORARY)


def lifter_set_level(side, level):
    """
    Mueve el lifter al nivel indicado (0,1,2) y ajusta SIEMPRE los frames
    de TRABAJO (101,102,103) a partir de los frames ORIGINALES nivel 0
    (191,192,193), sin modificar jamás los originales.

    Pasos:
      - Si el nivel ya es _lifter_level, no hace nada.
      - Mueve físicamente el lifter al nivel deseado.
      - Aplica la compensación de frames con apply_level_to_frames(level).
      - Actualiza _lifter_level.
    """
    global _lifter_level

    # Protección: si ya estamos en ese nivel lógico, no hacer nada
    if level == _lifter_level:
        tp_log("Lift100 ya en nivel lógico " + str(level) + ".")
        return

    tp_log("Cambiando lifter a nivel " + str(level) +
           " (offset Z = " + str(_level_offset(level)) + " mm).")

    # Mover físicamente el lifter
    _lifter_do_set_level(level)

    # Ajustar frames de trabajo en función de los frames originales
    apply_level_to_frames(level)

    # Actualizar estado lógico
    _lifter_level = level


def lifter_restore_frames():
    """
    Restaura el sistema a nivel 0:
      - Mueve físicamente el lifter a nivel 0.
      - Aplica apply_level_to_frames(0) para que 101/102/103 coincidan
        con los frames originales nivel 0.
      - Actualiza _lifter_level = 0.
    """
    global _lifter_level

    # Mover lifter físicamente a nivel 0
    _lifter_do_set_level(0)

    # Aplicar compensación de nivel 0 (sin desplazamiento en Z)
    apply_level_to_frames(0)

    # Estado lógico
    _lifter_level = 0



# =====================================================================
# Datos PLACE (por capas y lados)
# =====================================================================
# Estructura:
#   left_layers / right_layers: lista de layers (0..N-1).
#   Cada layer: lista de 9 slots (0..8).
#   Cada slot: (X, Y, Z, RX, RY, RZ) en el frame del pallet.

left_layers = [
    # LAYER 1 (Left)
    [
        (105.0, 402.0, 235.0, -180.0, 0.0,  90.0),
        (593.0,  90.0, 235.0, -180.0, 0.0, 180.0),
        (593.0, 265.0, 235.0, -180.0, 0.0,-180.0),
        (593.0, 440.0, 235.0, -180.0, 0.0,-180.0),
        (593.0, 615.0, 235.0, -180.0, 0.0,-180.0),
        (593.0, 790.0, 235.0, -180.0, 0.0,-180.0),
        (593.0, 965.0, 235.0, -180.0, 0.0,-180.0),
        (593.0,1140.0, 235.0, -180.0, 0.0,-180.0),
        (105.0,1212.0, 235.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 2 (Left)
    [
        (915.0, 812.0, 356.0, -180.0, 0.0,  90.0),
        (915.0, 407.0, 356.0, -180.0, 0.0,  90.0),
        (418.0,  90.0, 356.0, -180.0, 0.0,-180.0),
        (418.0, 265.0, 356.0, -180.0, 0.0, 180.0),
        (418.0, 440.0, 356.0, -180.0, 0.0,-180.0),
        (418.0, 615.0, 356.0, -180.0, 0.0,-180.0),
        (418.0, 790.0, 356.0, -180.0, 0.0,-180.0),
        (418.0, 965.0, 356.0, -180.0, 0.0,-180.0),
        (418.0,1140.0, 356.0, -180.0, 0.0,-180.0)
    ],
    # LAYER 3 (Left)
    [
        (105.0, 402.0, 477.0, -180.0, 0.0,  90.0),
        (593.0,  90.0, 477.0, -180.0, 0.0,-180.0),
        (593.0, 265.0, 477.0, -180.0, 0.0,-180.0),
        (593.0, 440.0, 477.0, -180.0, 0.0,-180.0),
        (593.0, 615.0, 477.0, -180.0, 0.0,-180.0),
        (593.0, 790.0, 477.0, -180.0, 0.0,-180.0),
        (593.0, 965.0, 477.0, -180.0, 0.0,-180.0),
        (593.0,1140.0, 477.0, -180.0, 0.0,-180.0),
        (105.0,1212.0, 477.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 4 (Left)
    [
        (915.0, 812.0, 597.0, -180.0, 0.0,  90.0),
        (915.0, 407.0, 597.0, -180.0, 0.0,  90.0),
        (418.0,  90.0, 597.0,  180.0, 0.0,-180.0),
        (418.0, 265.0, 597.0, -180.0, 0.0,-180.0),
        (418.0, 440.0, 597.0, -180.0, 0.0,-180.0),
        (418.0, 615.0, 597.0, -180.0, 0.0,-180.0),
        (418.0, 790.0, 597.0, -180.0, 0.0,-180.0),
        (418.0, 965.0, 597.0, -180.0, 0.0,-180.0),
        (418.0,1140.0, 597.0, -180.0, 0.0,-180.0)
    ],
    # LAYER 5 (Left)
    [
        (105.0, 402.0, 717.0, -180.0, 0.0,  90.0),
        (593.0,  90.0, 717.0, -180.0, 0.0, 180.0),
        (593.0, 265.0, 717.0, -180.0, 0.0,-180.0),
        (593.0, 440.0, 717.0, -180.0, 0.0,-180.0),
        (593.0, 615.0, 717.0, -180.0, 0.0,-180.0),
        (593.0, 790.0, 717.0, -180.0, 0.0,-180.0),
        (593.0, 965.0, 717.0, -180.0, 0.0,-180.0),
        (593.0,1140.0, 717.0, -180.0, 0.0,-180.0),
        (105.0,1212.0, 717.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 6 (Left)
    [
        (915.0, 812.0, 837.0, -180.0, 0.0,  90.0),
        (915.0, 407.0, 837.0, -180.0, 0.0,  90.0),
        (418.0,  90.0, 837.0,  180.0, 0.0,-180.0),
        (418.0, 265.0, 837.0, -180.0, 0.0,-180.0),
        (418.0, 440.0, 837.0, -180.0, 0.0, 180.0),
        (418.0, 615.0, 837.0, -180.0, 0.0,-180.0),
        (418.0, 790.0, 837.0,  180.0, 0.0,-180.0),
        (418.0, 965.0, 837.0, -180.0, 0.0,-180.0),
        (418.0,1140.0, 837.0, -180.0, 0.0,-180.0)
    ],
    # LAYER 7 (Left)
    [
        (105.0, 402.0, 957.0, -180.0, 0.0,  90.0),
        (593.0,  90.0, 957.0, -180.0, 0.0,-180.0),
        (593.0, 265.0, 957.0, -180.0, 0.0,-180.0),
        (593.0, 440.0, 957.0, -180.0, 0.0,-180.0),
        (593.0, 615.0, 957.0, -180.0, 0.0,-180.0),
        (593.0, 790.0, 957.0, -180.0, 0.0,-180.0),
        (593.0, 965.0, 957.0, -180.0, 0.0, 180.0),
        (593.0,1140.0, 957.0, -180.0, 0.0,-180.0),
        (105.0,1212.0, 957.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 8 (Left)
    [
        (915.0, 812.0,1077.0, -180.0, 0.0,  90.0),
        (915.0, 407.0,1077.0, -180.0, 0.0,  90.0),
        (418.0,  90.0,1077.0, -180.0, 0.0,-180.0),
        (418.0, 265.0,1077.0, -180.0, 0.0,-180.0),
        (418.0, 440.0,1077.0, -180.0, 0.0,-180.0),
        (418.0, 615.0,1077.0, -180.0, 0.0,-180.0),
        (418.0, 790.0,1077.0, -180.0, 0.0,-180.0),
        (418.0, 965.0,1077.0, -180.0, 0.0, 180.0),
        (418.0,1140.0,1077.0, -180.0, 0.0,-180.0)
    ],
    # LAYER 9 (Left)
    [
        (105.0, 402.0,1197.0, -180.0, 0.0,  90.0),
        (593.0,  90.0,1197.0, -180.0, 0.0,-180.0),
        (593.0, 265.0,1197.0, -180.0, 0.0,-180.0),
        (593.0, 440.0,1197.0, -180.0, 0.0,-180.0),
        (593.0, 615.0,1197.0, -180.0, 0.0,-180.0),
        (593.0, 790.0,1197.0, -180.0, 0.0,-180.0),
        (593.0, 965.0,1197.0, -180.0, 0.0, 180.0),
        (593.0,1140.0,1197.0, -180.0, 0.0,-180.0),
        (105.0,1212.0,1197.0, -180.0, 0.0,  90.0)
    ]
]

right_layers = [
    # LAYER 1 (Right)
    [
        (905.0, 402.0, 235.0, -180.0, 0.0, -90.0),
        (417.0,  80.0, 235.0, -180.0, 0.0,   0.0),
        (417.0, 255.0, 235.0, -180.0, 0.0,   0.0),
        (417.0, 430.0, 235.0, -180.0, 0.0,   0.0),
        (417.0, 605.0, 235.0, -180.0, 0.0,   0.0),
        (417.0, 780.0, 235.0, -180.0, 0.0,   0.0),
        (417.0, 955.0, 235.0, -180.0, 0.0,   0.0),
        (417.0,1130.0, 235.0, -180.0, 0.0,   0.0),
        (905.0,1213.0, 235.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 2 (Right)
    [
        ( 95.0, 808.0, 356.0, -180.0, 0.0, -90.0),
        ( 95.0, 402.0, 356.0, -180.0, 0.0, -90.0),
        (593.0,  80.0, 356.0, -180.0, 0.0,   0.0),
        (593.0, 255.0, 356.0, -180.0, 0.0,   0.0),
        (593.0, 430.0, 356.0, -180.0, 0.0,   0.0),
        (593.0, 605.0, 356.0, -180.0, 0.0,   0.0),
        (593.0, 780.0, 356.0, -180.0, 0.0,   0.0),
        (593.0, 955.0, 356.0, -180.0, 0.0,   0.0),
        (593.0,1130.0, 356.0, -180.0, 0.0,   0.0)
    ],
    # LAYER 3 (Right)
    [
        (905.0, 402.0, 477.0, -180.0, 0.0, -90.0),
        (417.0,  80.0, 477.0, -180.0, 0.0,   0.0),
        (417.0, 255.0, 477.0, -180.0, 0.0,   0.0),
        (417.0, 430.0, 477.0, -180.0, 0.0,   0.0),
        (417.0, 605.0, 477.0, -180.0, 0.0,   0.0),
        (417.0, 780.0, 477.0, -180.0, 0.0,   0.0),
        (417.0, 955.0, 477.0, -180.0, 0.0,   0.0),
        (417.0,1130.0, 477.0, -180.0, 0.0,   0.0),
        (905.0,1213.0, 477.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 4 (Right)
    [
        ( 95.0, 808.0, 598.0, -180.0, 0.0, -90.0),
        ( 95.0, 402.0, 598.0, -180.0, 0.0, -90.0),
        (593.0,  80.0, 598.0, -180.0, 0.0,   0.0),
        (593.0, 255.0, 598.0, -180.0, 0.0,   0.0),
        (593.0, 430.0, 598.0, -180.0, 0.0,   0.0),
        (593.0, 605.0, 598.0, -180.0, 0.0,   0.0),
        (593.0, 780.0, 598.0, -180.0, 0.0,   0.0),
        (593.0, 955.0, 598.0, -180.0, 0.0,   0.0),
        (593.0,1130.0, 598.0, -180.0, 0.0,   0.0)
    ],
    # LAYER 5 (Right)
    [
        (905.0, 402.0, 719.0, -180.0, 0.0, -90.0),
        (417.0, 80.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 255.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 430.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 605.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 780.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 955.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 1130.0, 719.0, -180.0, 0.0, 0.0),
        (905.0, 1213.0, 719.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 6 (Right)
    [
        (95.0, 808.0, 840.0, -180.0, 0.0, -90.0),
        (95.0, 402.0, 840.0, -180.0, 0.0, -90.0),
        (593.0, 80.0, 840.0, -180.0, 0.0, 0.0),
        (593.0, 255.0, 840.0, -180.0, 0.0, 0.0),
        (593.0, 430.0, 840.0, -180.0, 0.0, 0.0),
        (593.0, 605.0, 840.0, -180.0, 0.0, 0.0),
        (593.0, 780.0, 840.0, -180.0, 0.0, 0.0),
        (593.0, 955.0, 840.0, -180.0, 0.0, 0.0),
        (593.0, 1130.0, 840.0, -180.0, 0.0, 0.0)
    ],
    # LAYER 7 (Right)
    [
        (905.0, 402.0, 961.0, -180.0, 0.0, -90.0),
        (417.0, 80.0, 961.0, -180.0, 0.0, 0.0),
        (417.0, 255.0, 961.0, -180.0, 0.0, 0.0),
        (417.0, 430.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 605.0, 961.0, -180.0, 0.0, 0.0),
        (417.0, 780.0, 961.0, -180.0, 0.0, 0.0),
        (417.0, 955.0, 961.0, -180.0, 0.0, 0.0),
        (417.0, 1130.0, 961.0, -180.0, 0.0, 0.0),
        (905.0, 1213.0, 961.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 8 (Right)
    [
        (95.0, 808.0, 1082.0, -180.0, 0.0, -90.0),
        (95.0, 808.0, 1082.0, -180.0, 0.0, -90.0),
        (593.0, 80.0, 1082.0, -180.0, 0.0, 0.0 ),
        (593.0, 255.0, 1082.0, -180.0, 0.0, 0.0),
        (593.0, 430.0, 1082.0, -180.0, 0.0, 0.0),
        (593.0, 605.0, 1082.0, -180.0, 0.0, 0.0),
        (593.0, 780.0, 1082.0, -180.0, 0.0, 0.0),
        (593.0, 955.0, 1082.0, -180.0, 0.0, 0.0),
        (593.0, 1130.0, 1082.0, -180.0, 0.0, 0.0)
    ],
    # LAYER 9 (Right)
    [
        (905.0, 402.0, 1203.0, -180.0, 0.0, -90.0),
        (417.0, 80.0, 1203.0, -180.0, 0.0, 0.0),
        (417.0, 255.0, 1203.0, -180.0, 0.0, 0.0),
        (417.0, 430.0, 1203.0, -180.0, 0.0, 0.0),
        (417.0, 605.0, 1203.0, -180.0, 0.0, 0.0),
        (417.0, 780.0, 1203.0, -180.0, 0.0, 0.0),
        (417.0, 955.0, 1203.0, -180.0, 0.0, 0.0),
        (417.0, 1130.0, 1203.0, -180.0, 0.0, 0.0),
        (905.0, 1213.0, 1203.0, -180.0, 0.0, -90.0)
    ]
]

# =====================================================================
# Half plan (A→B)
# =====================================================================
# Cada tupla: (layer_origen, slot_origen, layer_destino_halfB, slot_destino_halfB)
# Ejemplo (0,8,1,0):
#   - Half-A se coloca en L1 S9 (layer=0, slot=8)
#   - Half-B se coloca en L2 S1 (layer=1, slot=0)

half_plan_left  = [(0,8,1,0), (2,8,3,0), (4,8,5,0), (6,8,7,0)]
half_plan_right = [(0,8,1,0), (2,8,3,0), (4,8,5,0), (6,8,7,0)]

# =====================================================================
# Mid por capa (MidA / MidB) en joints
# =====================================================================
# MidA: joint targets intermedios por capa (para cada lado).
# MidB: MidA con J6 rotado +90° (cambio de orientación de muñeca).

mid_left_a = [
    posj(0.72, 58.86, 107.11, 0.00, 14.02, 0.72),
    posj(0.72, 49.68, 109.40, 0.00, 20.90, 0.72),
    posj(0.72, 40.89, 109.82, 0.00, 29.27, 0.72),
    posj(0.72, 32.94, 108.37, 0.00, 38.67, 0.72),
    posj(0.72, 52.23, 108.94, 0.00, 18.80, 0.72),
    posj(0.72, 43.37, 109.89, 0.00, 26.71, 0.72),
    posj(0.72, 35.16, 108.98, 0.00, 35.83, 0.72),
    posj(0.72, 27.97, 106.24, 0.00, 45.76, 0.72),
    posj(0.72, 22.09, 101.74, 0.00, 56.14, 0.72)
]

mid_right_a = [
    posj(-181.11, 58.26, 110.56, 0.00, 11.16, -1.11),
    posj(-181.11, 48.75, 112.90, 0.00, 18.33, -1.11),
    posj(-181.11, 39.58, 113.33, 0.00, 27.07, -1.11),
    posj(-181.11, 31.26, 111.85, 0.00, 36.88, -1.11),
    posj(-181.11, 51.64, 112.39, 0.00, 15.96, -1.11),
    posj(-181.11, 42.32, 113.41, 0.00, 24.25, -1.11),
    posj(-181.11, 33.65, 112.49, 0.00, 33.84, -1.11),
    posj(-181.11, 25.99, 109.65, 0.00, 44.35, -1.11),
    posj(-181.11, 19.81, 105.01, 0.00, 55.16, -1.11)
]

def _rot_j6(j, delta):
    """
    Devuelve un nuevo posj con el mismo J1..J5 y J6 rotado en 'delta'.
    """
    return posj(j[0], j[1], j[2], j[3], j[4], j[5] + delta)

# MidB = MidA con J6 rotado +90°
mid_left_b  = [ _rot_j6(j,  90.0) for j in mid_left_a  ]
mid_right_b = [ _rot_j6(j,  90.0) for j in mid_right_a ]

# ---------------------- mapa MidB configurable -------------
# midB_map_left/right contiene (layer,slot) en 0-based que usarán MidB.
# Todo lo demás usa MidA.
# Regla:
#  L1,3,5,7,9: slot 1 y 9 -> MidB, 2..8 MidA
#  L2,4,6,8:   slots 1,2 -> MidB, 3..9 MidA

midB_map_left = [
    (0,0), (0,8),
    (1,0), (1,1),
    (2,0), (2,8),
    (3,0), (3,1),
    (4,0), (4,8),
    (5,0), (5,1),
    (6,0), (6,8),
    (7,0), (7,1),
    (8,0), (8,8)
]

# Por defecto el Right usa el mismo patrón; se puede modificar más adelante.
midB_map_right = list(midB_map_left)

# =====================================================================
# Utilidades geométricas
# =====================================================================

def mk_off(dz):
    """
    Crea una posx de offset en Z (relativo) con orientaciones 0.
    Se usa para APPROACH/RETRACT en pick/place.
    """
    return posx(0.0, 0.0, dz, 0.0, 0.0, 0.0, rot_mode)

def mk_off_app():
    """
    Offset sólo para APPROACH de PLACE: (dx_app, dy_app, dz_app).
    """
    return posx(dx_app, dy_app, dz_app, 0.0, 0.0, 0.0, rot_mode)

def get_place(side, layer, slot):
    """
    Devuelve:
      - La pose posx del PLACE (en el frame del pallet)
      - El ID de frame (left_frame/right_frame)
    """
    if side == "L":
        p = left_layers[layer][slot]
        return posx(p[0], p[1], p[2], p[3], p[4], p[5], rot_mode), left_frame
    else:
        p = right_layers[layer][slot]
        return posx(p[0], p[1], p[2], p[3], p[4], p[5], rot_mode), right_frame

def get_app(side, layer, slot):
    """
    Calcula la pose de APPROACH a partir del PLACE:
    PLACE + (dx_app, dy_app, dz_app) en el frame del pallet.
    """
    pl, rf = get_place(side, layer, slot)
    return trans(pl, mk_off_app(), rf, rf), rf

def get_ret(side, layer, slot):
    """
    Calcula la pose de RETRACT a partir del PLACE:
    PLACE + (0, 0, dz_ret) en el frame del pallet.
    """
    pl, rf = get_place(side, layer, slot)
    return trans(pl, mk_off(dz_ret), rf, rf), rf

def find_half(side, layer, slot):
    """
    Busca en half_plan_left/right si (layer,slot) es un ORIGEN Half-A.
    Devuelve:
      (True, dl, ds)  si es origen Half y (dl,ds) es el destino Half-B
      (False, 0, 0)   si no es origen Half
    """
    plan = half_plan_left if side == "L" else half_plan_right
    for t in plan:
        if t[0] == layer and t[1] == slot:
            return True, t[2], t[3]
    return False, 0, 0

def is_half_destination(side, layer, slot):
    """
    Indica si (layer,slot) es un DESTINO Half-B.
    Se usa para:
      - Saltar esos slots en la corrida normal (run_from).
      - Reconocer cuando el usuario arranca justo en un Half-B.
    """
    plan = half_plan_left if side == "L" else half_plan_right
    for t in plan:
        if t[2] == layer and t[3] == slot:
            return True
    return False

# --------- selección de MidA / MidB según tabla ----------
def _is_group_b(side, layer, slot):
    """
    Determina si este (layer,slot) debe usar MidB (J6 +90°)
    según midB_map_left/right.
    """
    if side == "L":
        return (layer, slot) in midB_map_left
    else:
        return (layer, slot) in midB_map_right

def get_mid(side, layer, slot):
    """
    Devuelve el joint target Mid adecuado (A o B) según:
      - Lado (Left/Right)
      - Capa (layer)
      - Slot
    Si la capa excede el tamaño de la lista de mids, devuelve None.
    """
    use_b = _is_group_b(side, layer, slot)
    if side == "L":
        if use_b:
            return mid_left_b[layer]  if layer < len(mid_left_b)  else None
        else:
            return mid_left_a[layer]  if layer < len(mid_left_a)  else None
    else:
        if use_b:
            return mid_right_b[layer] if layer < len(mid_right_b) else None
        else:
            return mid_right_a[layer] if layer < len(mid_right_a) else None

# =====================================================================
# Pick desde conveyor
# =====================================================================

# Pose cartesiana del pick en el conveyor (en conv_frame)
pick_pose = posx(422.00, -110.00, 810.00, 180.00, 0.00, 0.0, rot_mode)

def get_pick():
    """
    Devuelve la pose de pick y el frame del conveyor.
    """
    return pick_pose, conv_frame

def get_pick_app():
    """
    APPROACH del pick: pick_pose + dz_app en Z del conveyor.
    """
    return trans(pick_pose, mk_off(dz_app), conv_frame, conv_frame), conv_frame

def get_pick_ret():
    """
    RETRACT del pick: pick_pose + dz_ret en Z del conveyor.
    """
    return trans(pick_pose, mk_off(dz_ret), conv_frame, conv_frame), conv_frame

def do_pick(mode):
    """
    Secuencia completa de pick:
      - Espera a que el conveyor esté listo (todas las cajas acomodadas).
      - Va a up_conv
      - Baja a APPROACH (pick_app)
      - Baja a PICK (pick_pose)
      - Activa el gripper según el modo (full/half_a/half_b)
      - Sube a RETRACT (pick_ret)
      - Regresa a up_conv
    """
    # 1) Esperar a que el conveyor reporte que la fila está completa (PLACEHOLDER)
    wait_conveyor_ready()

    # 2) (Futuro) decidir automáticamente half / full usando sensores A/B
    # state = read_conv_box_state()
    # if state == "half":
    #     mode = "half_b"   # Ejemplo: tomar sólo media caja del conveyor
    # elif state == "full":
    #     mode = "full"

    # Ir al hub sobre el conveyor
    movej(up_conv, vj_fast, aj_fast, r=5)

    # Calcular APPROACH, PICK y RETRACT (referenciados a conv_frame)
    a, _ = get_pick_app()
    p, _ = get_pick()
    r, _ = get_pick_ret()

    # Aproximación lenta en línea
    movel(a, v=vl_slow, a=al_slow, ref=conv_frame)
    # Bajar al pick
    movel(p, v=vl_slow, a=al_slow, ref=conv_frame)

    # Selección del modo de agarre
    if mode == "full":
        grip_full()
    elif mode == "half_a":
        grip_half_a()
    elif mode == "half_b":
        grip_half_b()

    # Retiro en línea
    movel(r, v=vl_slow, a=al_slow, ref=conv_frame)

    # Volver al hub del conveyor
    movej(up_conv, vj_fast, aj_fast, r=5)

# =====================================================================
# Place (full / half)
# =====================================================================

def do_place(side, layer, slot, rtype):
    """
    Secuencia completa de place en un slot:
      - Mueve al hub del lado (up_left/up_right)
      - Pasa por MidA o MidB (si está definido para esa capa/slot)
      - Va al APPROACH (con offsets X/Y/Z)
      - Baja al PLACE
      - Suelta tipo rtype (full/half_a/half_b)
      - Sube a RETRACT
      - Regresa al hub del lado
    """
    # Seleccionar hub según lado
    up = up_left if side == "L" else up_right

    # Place, Approach y Retract en el frame del pallet
    pl, rp = get_place(side, layer, slot)  # Pose de place y frame
    ap, ra = get_app(side, layer, slot)    # Pose de approach y frame
    rt, rr = get_ret(side, layer, slot)    # Pose de retract y frame

    # Ir al hub del pallet
    movej(up, vj_fast, aj_fast)

    # MidA/MidB (si la capa tiene mid definida)
    use_b = _is_group_b(side, layer, slot)
    m = get_mid(side, layer, slot)
    if not (m == None):
        if use_b:
            tp_log("MidB en " + side + " L" + str(layer+1) + " S" + str(slot+1))
        else:
            tp_log("MidA en " + side + " L" + str(layer+1) + " S" + str(slot+1))
        movej(m, vj_fast, aj_fast)

    # Aproximación al slot (con offsets dx_app/dy_app/dz_app)
    movel(ap, v=vl_slow, a=al_slow, ref=ra)
    # Bajar a la posición exacta de PLACE
    movel(pl, v=vl_slow, a=al_slow, ref=rp)

    # Liberar según el tipo de pieza (full / half_a / half_b)
    if   rtype == "full":
        rel_full()
    elif rtype == "half_a":
        rel_half_a()
    elif rtype == "half_b":
        rel_half_b()

    # Retiro en línea
    movel(rt, v=vl_slow, a=al_slow, ref=rr)
    # Volver al hub del pallet
    movej(up, vj_fast, aj_fast)

# =====================================================================
# Lógica Half-A / Half-B
# =====================================================================

# Destinos Half-B ya llenados (para no repetirlos)
_halfB_filled = set()

def do_half(side, layer, slot, is_half, dl, ds):
    """
    Maneja la lógica de Half-A / Half-B para un slot:
      - Si is_half == True:
          * SLOT actual es origen: se coloca Half-A ahí.
          * Luego se coloca Half-B en (dl,ds), si el destino es válido.
          * Antes del Half-B, se ajusta el nivel del lifter según la cama destino.
      - Si is_half == False:
          * SLOT normal: se hace place full.
    """
    if is_half:
        # Mensaje: estamos colocando Half-A en el origen
        tp_log("Half-A: L" + str(layer+1) + " S" + str(slot+1) +
               " → L" + str(dl+1) + " S" + str(ds+1))

        # 1) Half-A en el slot origen (nivel ya ajustado previamente para esta cama)
        do_place(side, layer, slot, "half_a")

        # Si el destino ya fue marcado como lleno antes, no repetir Half-B
        if (side, dl, ds) in _halfB_filled:
            tp_log("Half-B destino ya estaba lleno. Omitiendo: L" +
                   str(dl+1) + " S" + str(ds+1))
            return

        # Verificar que el destino existe en la tabla de layers/slots
        if side == "L":
            ok = (dl < len(left_layers) and ds < len(left_layers[dl]))
        else:
            ok = (dl < len(right_layers) and ds < len(right_layers[dl]))

        if ok:
            # *** Ajustar nivel del lifter para la cama DESTINO ***
            dest_level = lifter_level_for_layer(dl)
            lifter_set_level(side, dest_level)

            # Movernos al hub del lado antes de ir al destino Half-B
            movej((up_right if side == "R" else up_left),
                  v=vj_slow, a=aj_slow)

            tp_log("Colocando Half-B en destino L" +
                   str(dl+1) + " S" + str(ds+1))

            # Coloca Half-B en el destino
            do_place(side, dl, ds, "half_b")

            # Marcar destino como lleno (ya no repetir Half-B ahí)
            _halfB_filled.add((side, dl, ds))
        else:
            # Fuera de rango → sólo se hace Half-A
            tp_log("Destino Half-B fuera de rango. Solo Half-A.")
    else:
        # Slot normal: caja completa
        do_place(side, layer, slot, "full")

# =====================================================================
# tp helpers (Teach Pendant)
# =====================================================================

def clamp(val, lo, hi):
    """
    Limita 'val' al rango [lo, hi].
    """
    if val < lo: return lo
    if val > hi: return hi
    return val

def ask_side():
    """
    Pide al operador el lado (L/R).
    Repite hasta que la entrada sea válida.
    """
    s = tp_get_user_input("Lado L/R", DR_VAR_STR)
    if s == "L" or s == "l": return "L"
    if s == "R" or s == "r": return "R"
    tp_log("Entrada invalida, usa L o R")
    return ask_side()

def ask_layer(side):
    """
    Pide la cama (1..N) según el lado, la convierte a índice 0-based.
    """
    n = len(left_layers) if side == "L" else len(right_layers)
    v = tp_get_user_input("Cama 1.." + str(n), DR_VAR_INT)
    v = clamp(v, 1, n)
    return v - 1

def ask_slot(side, layer):
    """
    Pide el slot (1..N) de la cama seleccionada, lo convierte a índice 0-based.
    """
    n = len(left_layers[layer]) if side == "L" else len(right_layers[layer])
    v = tp_get_user_input("Slot 1.." + str(n), DR_VAR_INT)
    v = clamp(v, 1, n)
    return v - 1

# =====================================================================
# helpers para lecturas posx/posj y safe_home
# =====================================================================

# Centro X aproximado de cada pallet para decidir qué hub usar
_left_cx  =  250.0
_right_cx = -1266.0

def _pal_hub(cx):
    """
    Dado cx (X actual del TCP en base), decide a qué hub de pallet ir:
      - up_left  si está más cerca de _left_cx
      - up_right si está más cerca de _right_cx
    """
    if abs(cx - _left_cx) <= abs(cx - _right_cx):
        return up_left
    else:
        return up_right

def _get_posx_only():
    """
    Obtiene la pose cartesiana actual (posx).
    Algunos firmwares devuelven (pose,ref), por eso se hace el try/except.
    """
    res = get_current_posx()
    try:
        pose, _ = res
        return pose
    except:
        return res

def _get_posj_only():
    """
    Obtiene la pose articular actual (posj).
    Algunos firmwares devuelven (joints,ref), por eso se hace el try/except.
    """
    res = get_current_posj()
    try:
        j, _ = res
        return j
    except:
        return res

# Tolerancia para considerar que está en HOME (en grados)
tol_j_deg = 2.0

def _is_home():
    """
    Comprueba si la posición actual de joints está cerca de 'home'.
    """
    jcur = _get_posj_only()
    return (abs(jcur[0] - home[0]) <= tol_j_deg and
            abs(jcur[1] - home[1]) <= tol_j_deg and
            abs(jcur[2] - home[2]) <= tol_j_deg and
            abs(jcur[3] - home[3]) <= tol_j_deg and
            abs(jcur[4] - home[4]) <= tol_j_deg and
            abs(jcur[5] - home[5]) <= tol_j_deg)

def safe_home():
    """
    Lógica de retorno seguro a HOME:
      - Si ya está en home, no hace nada.
      - Sube 100mm en Z relativo al frame base (para alejarse de obstáculos).
      - Si Y > 0 (pallets): va al hub de pallet más cercano (left/right).
      - Si Y <= 0 (conveyor): va a up_conv.
      - Desde el hub, va a 'home'.
    """
    if _is_home():
        return

    # Obtener pose actual
    cur = _get_posx_only()
    cx = cur[0]
    cy = cur[1]

    # Subir en Z 100mm en base (movimiento relativo)
    pz = posx(0, 0, 100, 0, 0, 0, rot_mode)
    movel(pz, time=2, ref=DR_BASE, mod=DR_MV_MOD_REL)

    # Decidir hub según el cuadrante (Y positiva => pallets)
    if cy > 0:
        movej(_pal_hub(cx), v=vj_slow, a=aj_slow)
    else:
        movej(up_conv, v=vj_slow, a=aj_slow)

    # Ir finalmente al home
    movej(home, v=vj_slow, a=aj_slow)

def go_safe_before_lifter():
    """
    Lleva al robot a 'safe_pose' antes de bajar completamente el lifter.
    Se asume que safe_pose es un joint target seguro libre de obstáculos.
    """
    movej(safe_pose, v=vj_slow, a=aj_slow)

# =====================================================================
# rutina: ejecutar desde (layer,slot) hasta acabar el lado
# =====================================================================

def run_from(side, start_layer, start_slot):
    """
    Ejecuta la secuencia completa de paletizado desde (start_layer,start_slot)
    hasta completar todas las capas y slots del lado indicado.
    Respeta la lógica:
      - Saltar destinos Half-B (is_half_destination).
      - Ejecutar Half-A/B donde aplique (find_half + do_half).
      - Seleccionar nivel del lifter por cama:
          * L1-4 -> nivel 0
          * L5-7 -> nivel 1 (+400)
          * L8-9 -> nivel 2 (+400+270)
      - La ÚLTIMA CAJA DE LA CAMA 9 se coloca como Half-B (half_b) y sólo
        toma media caja.
    NOTA: Esta función YA NO baja el lifter ni restaura frames al final;
          eso se hace fuera, al terminar el pallet completo.
    """
    layers = left_layers if side == "L" else right_layers
    n_layers = len(layers)
    layer = start_layer

    while layer < n_layers:
        # ------------------- LÓGICA LIFTER POR CAPA -------------------
        lvl = lifter_level_for_layer(layer)
        lifter_set_level(side, lvl)
        # --------------------------------------------------------------

        n_slots = len(layers[layer])
        # En la capa de arranque se respeta start_slot, en las demás se empieza en 0
        s0 = start_slot if layer == start_layer else 0
        slot = s0

        while slot < n_slots:
            # Si el slot es un destino Half-B, se omite aquí
            if is_half_destination(side, layer, slot):
                slot = slot + 1
                continue

            # --------- ÚLTIMA CAJA DE LA CAMA 9 = Half-B -------------
            # layer == n_layers-1  → última cama (cama 9 en 1-based)
            # slot  == n_slots-1  → último slot de esa cama
            if (layer == n_layers - 1) and (slot == n_slots - 1):
                tp_log("Última caja de la cama 9: sólo Half-B en " +
                       side + " L" + str(layer+1) + " S" + str(slot+1))
                # En el futuro se puede decidir half/full por sensores; por ahora se
                # fuerza half_b.
                do_pick("half_b")
                do_place(side, layer, slot, "half_b")
                slot = slot + 1
                continue
            # -----------------------------------------------------------

            tp_log("Colocando en " + side +
                   " L" + str(layer+1) +
                   " S" + str(slot+1))

            # Siempre se toma pieza completa del conveyor (salvo el caso especial c9)
            do_pick("full")

            # Verificar si es un origen Half (Half-A/B) o slot normal
            is_h, dl, ds = find_half(side, layer, slot)

            # Ejecutar lógica de Half o Full
            do_half(side, layer, slot, is_h, dl, ds)

            slot = slot + 1
        layer = layer + 1


# =====================================================================
# MAIN
# =====================================================================

def main():
    """
    Flujo principal del programa:
      - Configura TCP y tool_shape.
      - safe_home.
      - Inicializa Lift100 (or_lift) de forma segura.
      - Lee la posición ACTUAL del Lift100 y deduce su nivel lógico (0,1,2).
      - Aplica la compensación de frames de TRABAJO (101/102/103) a partir
        de los frames ORIGINALES (191/192/193) según ese nivel.
      - Pregunta lado, cama y slot inicial al operador.
      - Lógica especial:
          * Si arrancas en la ÚLTIMA caja de la cama 9 → sólo Half-B.
          * Si arrancas en un destino Half-B → media caja y continuar.
      - Ejecuta la secuencia completa de ese lado (run_from).
      - Al terminar UN pallet:
          * Va a safe_pose.
          * (Futuro) espera a que retiren la tarima terminada.
          * Baja lifter a nivel 0 y restaura frames de trabajo desde originales.
          * (Futuro) espera nueva tarima en el otro lado.
      - Ejecuta el otro lado completo desde L1 S1 con la misma lógica.
      - Al final de TODO:
          * safe_pose, retirar segunda tarima (futuro), lifter a 0 y frames originales.
          * Regresa a home.
    """
    global _lifter_level

    # Configuración de la herramienta (nombres ya definidos en el controlador)
    set_tcp("custom_gripper")
    set_tool_shape("gripper_shape")

    # Llevar al robot a home de forma segura
    safe_home()

    # Asegurar que el Lift100 está inicializado antes de tocar frames
    lifter_safe_init()

    # --------------------------------------------------------------
    # NUEVA LÓGICA INICIAL:
    #   - Leer posición actual del Lift100.
    #   - Deducir nivel lógico (0/1/2) sin mover físicamente el lifter.
    #   - Actualizar _lifter_level.
    #   - Ajustar frames de trabajo 101/102/103 desde los originales
    #     191/192/193 según ese nivel.
    # --------------------------------------------------------------
    if or_lift.isconn():
        pos = or_lift.get_pos()
        level_actual = lifter_level_from_pos(pos)
        tp_log("Lift100 detectado en pos=" + str(pos) +
               " mm, nivel lógico estimado=" + str(level_actual))
    else:
        tp_log("Lift100 no conectado al inicio: se asume nivel 0.")
        level_actual = 0

    _lifter_level = level_actual
    apply_level_to_frames(level_actual)
    # --------------------------------------------------------------

    # Preguntar lado, layer y slot de arranque
    side  = ask_side()
    layer = ask_layer(side)
    slot  = ask_slot(side, layer)

    tp_log("Inicio en " + side +
           " L" + str(layer+1) +
           " S" + str(slot+1))

    # Determinar el otro lado para después
    other_side = "R" if side == "L" else "L"

    # Info de capas/slots para este lado
    layers = left_layers if side == "L" else right_layers
    n_layers = len(layers)
    n_slots_in_layer = len(layers[layer])

    # ---------- CASO ESPECIAL: arranque EXACTAMENTE en última caja de cama 9 ----------
    if (layer == n_layers - 1) and (slot == n_slots_in_layer - 1):
        tp_log("Arranque en última caja de la cama 9: sólo Half-B.")

        lvl0 = lifter_level_for_layer(layer)
        lifter_set_level(side, lvl0)

        # Sólo media caja B en ese slot
        do_pick("half_b")
        do_place(side, layer, slot, "half_b")

        # Cerrar lado inicial
        tp_log("Lado " + side + " finalizado.")
        go_safe_before_lifter()
        # wait_remove_finished_pallet(side)  # TO_DO: descomentar cuando haya sensor
        lifter_restore_frames()

        # Esperar nueva tarima en el otro lado (PLACEHOLDER)
        # wait_new_pallet(other_side)        # TO_DO: descomentar cuando haya sensor

        # Ejecutar lado opuesto completo desde L1 S1
        tp_log("Iniciando lado " + other_side + " desde L1 S1.")
        run_from(other_side, 0, 0)

        # Final del segundo lado
        tp_log("Lado " + other_side + " finalizado.")
        go_safe_before_lifter()
        # wait_remove_finished_pallet(other_side)
        lifter_restore_frames()

        movej(home, v=vj_fast, a=aj_slow, r=25)
        return

    # ---------- CASO: slot inicial es destino Half-B (arranque en Half-B) ----------
    if is_half_destination(side, layer, slot):
        tp_log("Arranque en Half-B: se toma media pieza y se coloca en este slot.")

        # Ajustar nivel del lifter para esta cama
        lvl0 = lifter_level_for_layer(layer)
        lifter_set_level(side, lvl0)

        # Tomar sólo media pieza tipo B del conveyor
        do_pick("half_b")
        # Colocar Half-B en el slot seleccionado
        do_place(side, layer, slot, "half_b")

        # Marcar este slot como destino ya lleno
        _halfB_filled.add((side, layer, slot))

        # Definir el siguiente punto desde donde continuar en el mismo lado
        next_layer = layer
        next_slot  = slot + 1
        if next_slot >= n_slots_in_layer:
            next_layer = next_layer + 1
            next_slot  = 0

        # Si aún hay capas por procesar en este lado, continuar desde ahí
        if next_layer < len(layers):
            run_from(side, next_layer, next_slot)

        # Cerrar lado 'side'
        tp_log("Lado " + side + " finalizado.")
        go_safe_before_lifter()
        # wait_remove_finished_pallet(side)
        lifter_restore_frames()
        # wait_new_pallet(other_side)

        # Ejecutar lado opuesto completo desde L1 S1
        tp_log("Iniciando lado " + other_side + " desde L1 S1.")
        run_from(other_side, 0, 0)

        tp_log("Lado " + other_side + " finalizado.")
        go_safe_before_lifter()
        # wait_remove_finished_pallet(other_side)
        lifter_restore_frames()

        movej(home, v=vj_fast, a=aj_slow, r=25)
        return

    # ----------------- CASO NORMAL: slot inicial NO es destino Half-B -----------------

    # Ajustar nivel del lifter para la cama inicial
    lvl0 = lifter_level_for_layer(layer)
    lifter_set_level(side, lvl0)

    # Primer slot del arranque: pieza completa
    do_pick("full")

    # Revisar si este slot es origen de Half-A/B
    is_half, dl, ds = find_half(side, layer, slot)
    do_half(side, layer, slot, is_half, dl, ds)

    # Continuar con el resto de slots a partir del siguiente en este lado
    run_from(side, layer, slot + 1)

    # --------- AL TERMINAR ESTE LADO, PASAR AL OTRO ---------
    tp_log("Lado " + side + " finalizado.")
    go_safe_before_lifter()
    # wait_remove_finished_pallet(side)
    lifter_restore_frames()
    # wait_new_pallet(other_side)

    tp_log("Iniciando lado " + other_side + " desde L1 S1.")
    run_from(other_side, 0, 0)

    tp_log("Lado " + other_side + " finalizado.")
    go_safe_before_lifter()
    # wait_remove_finished_pallet(other_side)
    lifter_restore_frames()

    # Regresar a home al finalizar todo
    movej(home, v=vj_fast, a=aj_slow, r=25)


# Llamada principal
main()
