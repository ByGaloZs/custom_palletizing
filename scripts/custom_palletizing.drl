# =====================================================================
# Palletizing Script (Doosan DRL)
# =====================================================================
# Este programa controla un sistema de paletizado con:
# - Un robot Doosan
# - Un lifter (Lift100) que sube/baja la base del robot
# - Un conveyor (transportador) donde llegan las cajas
# - Dos pallets: izquierdo (L) y derecho (R)
# - Un gripper de dos mitades (Half-A y Half-B)
#
# Funcionalidades principales:
# - Pick de cajas (completas o medias) desde el conveyor
# - Colocación de cajas en patrones de paletizado por capas ("camas") y slots
# - Manejo de medias cajas (Half-A / Half-B) con un plan definido
# - Compensación automática de frames según la altura del lifter
# - Uso de señales de PLC para pallets presentes y conveyor listo
# - Interacción con el operador a través del Teach Pendant (tp_popup, tp_get_user_input, etc.)
# =====================================================================

# ---------------------- frames ----------------------
# ID de los frames enseñados en el controlador

# Frames de TRABAJO (los que usa todo el programa para pick/place)
# Estos son los frames que se utilizan dinámicamente para cálculos de movimiento.
conv_frame  = 101   # Frame del conveyor (pick) - TRABAJO
left_frame  = 102   # Frame del pallet izquierdo - TRABAJO
right_frame = 103   # Frame del pallet derecho - TRABAJO

# Frames ORIGINALES nivel 0 (enseñados manualmente con el lifter abajo,
# todo respecto al WORLD). Estos NUNCA se modifican desde código.
# Se usan como referencia base para recalcular los frames de trabajo cuando cambia el nivel del lifter.
conv_frame_orig  = 191   # conveyor original nivel 0
left_frame_orig  = 192   # pallet izquierdo original nivel 0
right_frame_orig = 193   # pallet derecho original nivel 0

# ---------------------- parámetros globales ---------
# Modo de orientación: FIX XYZ (RX, RY, RZ fijos, no ELR).
# Es decir, se trabajan las orientaciones directamente en ángulos RX, RY, RZ.
rot_mode = DR_FIX_XYZ

# Offsets en Z para APPROACH y RETRACT con respecto al PLACE
# Sirven para aproximarse y retirarse verticalmente del punto de contacto.
dz_app = 150.0     # Distancia en Z para aproximación (APP) antes de llegar al punto de place/pick
dz_ret = 200.0     # Distancia en Z para retract (RET) después de soltar/tomar la caja

# Offsets en X/Y sólo para APPROACH de PLACE (personalizables)
# Actualmente no se usan (0), pero permiten acercarse por un lado si se desea.
dx_app = 0.0       # Offset en X del APPROACH respecto al slot
dy_app = 0.0       # Offset en Y del APPROACH respecto al slot

# ---------------------- velocidades -----------------
# Velocidades y aceleraciones de joint (vj/aj) y lineales (vl/al)
# Se separa en "rápido" y "lento" para poder controlar zonas seguras y zonas de trabajo fino.
vj_fast = 60;  aj_fast = 50   # Movimiento rápido en juntas (movej)
vj_slow = 40;  aj_slow = 30   # Movimiento más lento en juntas (para zonas sensibles)
vl_fast = 1000; al_fast = 1000  # Movimiento rápido lineal (movel)
vl_slow = 800;  al_slow = 800   # Movimiento lento lineal (para acercamiento / contacto)

# ---------------------- poses joint auxiliares ------  
# Home general del robot (posición segura de referencia)
home = posj(-90.00, 0.00, 90.00, 0.00, 90.00, 90.00)

# Posiciones "up" sobre zonas clave (hubs de seguridad):
# Estas son posturas en joint encima de las zonas principales. Se usan como puntos intermedios seguros.
up_conv  = posj(-80.61, 29.87, 65.62, 0.00, 84.50, 99.38)   # Hub sobre conveyor
up_left  = posj(4.58, -8.86, 98.00, 0.00, 90.85, 94.58)     # Hub sobre pallet izquierdo
up_right = posj(-175.42, -8.86, 98.01, 0.00, 90.86, 94.58)  # Hub sobre pallet derecho


# Posición segura antes de bajar el lifter por completo.
# Esta postura busca minimizar riesgo de colisión cuando se mueve el Lift100.
safe_pose = posj(0.00, 0.00, 0.00, 0.00, 0.00, 90.00)


MAINT_PASSWORD = "1234"   # Cambia esta contraseña a la que acuerden
maint_safe_pose = posj(90.00, 50.00, 115.00, 0, -75.00, 90.00)

# Flag global: indica si se ha entrado en modo mantenimiento
_in_maintenance = False



# ---------------------- I/O gripper -----------------
# Definición de las salidas digitales que controlan el gripper
# Se asume un gripper de doble vía, donde cada vía puede controlar media caja.
do_a = 1  # DO para "mitad A" o una vía del gripper
do_b = 2  # DO para "mitad B" o la otra vía del gripper

# Entradas digitales de retro de vacío
# Estas indican si hay vacío suficiente (pieza agarrada) en cada mitad.
di_vac_ok_a = 1    # DI para "vacío OK mitad A" 
di_vac_ok_b = 2    # DI para "vacío OK mitad B" 

# ---------------------- PLC OUTPUT BITS ----------------------
VAC_OK_BIT     = 0   # 1 = pick valido (hubo vacio)
VAC_LOSS_BIT   = 1   # 1 = perdida de vacio en el place
MAINT_BIT      = 2   # 1 = robot en modo mantenimiento
PICK_MODE_REG  = 0   # Registro entero para modo de pick (0=idle,1=full,2=half_b)


# Funciones de control del gripper (FULL / HALF A / HALF B / RELEASE)
# Estas funciones encapsulan la lógica de encender/apagar las DO y agregar pequeñas esperas.

def grip_full():
    """
    Activa ambas salidas -> agarra la caja completa.
    """
    set_digital_output(do_a, ON)
    set_digital_output(do_b, ON)
    wait(0.2)  # Tiempo para que el gripper genere vacío / cierre

def grip_half_a():
    """
    Sólo activa 'A' -> agarra media caja tipo A.
    """
    set_digital_output(do_a, ON)
    set_digital_output(do_b, OFF)
    wait(0.2)

def grip_half_b():
    """
    Sólo activa 'B' -> agarra media caja tipo B.
    """
    set_digital_output(do_a, OFF)
    set_digital_output(do_b, ON)
    wait(0.2)

def rel_full():
    """
    Libera ambas mitades -> suelta caja completa.
    """
    set_digital_output(do_a, OFF)
    set_digital_output(do_b, OFF)
    wait(0.2)

def rel_half_a():
    """
    Libera sólo la mitad A (Half-A).
    """
    set_digital_output(do_a, OFF)
    wait(0.15)

def rel_half_b():
    """
    Libera sólo la mitad B (Half-B).
    """
    set_digital_output(do_b, OFF)
    wait(0.15)


# =====================================================================
# Retroalimentación de vacío
# =====================================================================
# Mientras USE_VAC_FEEDBACK = False, el programa ignora estas DI de vacío
# y asume que siempre se agarra correctamente la pieza.
USE_VAC_FEEDBACK = True   # Cambiar a True cuando se integre retro de vacío real

def _vac_ok_a():
    """
    Devuelve True si la mitad A del gripper tiene vacío OK.

    Lee directamente de una ENTRADA DIGITAL del robot:
      di_vac_ok_a -> get_digital_input(di_vac_ok_a)
    """
    return get_digital_input(di_vac_ok_a) == ON

def _vac_ok_b():
    """
    Devuelve True si la mitad B del gripper tiene vacío OK.

    Lee directamente de una ENTRADA DIGITAL del robot:
      di_vac_ok_b -> get_digital_input(di_vac_ok_b)
    """
    return get_digital_input(di_vac_ok_b) == ON

def wait_vacuum_ok(mode, timeout=1.5):
    """
    Espera a que el gripper confirme vacío OK según el modo:
      - "full"   -> A y B deben tener vacío
      - "half_a" -> sólo A debe tener vacío
      - "half_b" -> sólo B debe tener vacío

    Si USE_VAC_FEEDBACK == False, siempre devuelve True (modo actual, sin sensores).

    timeout en segundos: tiempo máximo para esperar vacío antes de considerar fallo.
    """
    if not USE_VAC_FEEDBACK:
        # Modo actual: NO se verifica vacío, se asume OK
        return True

    # Determina qué mitades deben tener vacío según el modo
    need_a = (mode == "full" or mode == "half_a")
    need_b = (mode == "full" or mode == "half_b")

    t = 0.0
    dt = 0.05  # Periodo de muestreo de las entradas

    # Bucle hasta que haya vacío o se acabe el tiempo de espera
    while t < timeout:
        ok_a = (not need_a) or _vac_ok_a()
        ok_b = (not need_b) or _vac_ok_b()

        if ok_a and ok_b:
            # Ambas mitades requeridas tienen vacío correcto
            return True

        wait(dt)
        t = t + dt

    # Si llega aquí, no hubo vacío suficiente dentro del timeout
    tp_log("ADVERTENCIA: fallo de vacío en modo '" + mode + "'.")
    return False

def rel_by_mode(mode):
    """
    Libera el gripper según el modo de pick usado.
    """
    if mode == "full":
        rel_full()
    elif mode == "half_a":
        rel_half_a()
    elif mode == "half_b":
        rel_half_b()

def has_vacuum_for_mode(mode):
    """Comprueba de forma instantánea si el vacío sigue siendo válido
    para el modo indicado (full / half_a / half_b).

    Si USE_VAC_FEEDBACK == False, devuelve siempre True para no cambiar
    el comportamiento actual.
    """
    if not USE_VAC_FEEDBACK:
        return True

    need_a = (mode == "full") or (mode == "half_a")
    need_b = (mode == "full") or (mode == "half_b")

    ok_a = (not need_a) or _vac_ok_a()
    ok_b = (not need_b) or _vac_ok_b()

    return ok_a and ok_b


# =====================================================================
# Sensores de seguridad
# =====================================================================
# ---------------------- I/O pallets desde PLC ----------------------
# Estos bits vienen del PLC y representan sensores físicos de presencia de tarima
# o estados de "conveyor listo".

PALLET_LEFT_BIT  = 1   # Limit switch pallet izquierdo presente
PALLET_RIGHT_BIT = 2   # Limit switch pallet derecho presente
CONV_READY_BIT   = 0   # Bit del PLC que indica "conveyor listo"

def _pallet_bit_index(side):
    """
    Devuelve el índice de bit correspondiente al lado:
      side == "L" -> PALLET_LEFT_BIT
      side == "R" -> PALLET_RIGHT_BIT
    """
    return PALLET_LEFT_BIT if side == "L" else PALLET_RIGHT_BIT

def is_pallet_present(side):
    """
    Devuelve True si el pallet está presente en el lado indicado ('L' o 'R').
    Lee el bit correspondiente del registro del PLC.
    """
    bit_idx = _pallet_bit_index(side)
    return get_input_register_bit(bit_idx) == ON

def wait_pallet_present(side):
    """
    Espera a que haya pallet presente en el lado indicado ('L' o 'R').

    Se asume:
      - bit == ON  -> hay tarima presente
      - bit == OFF -> NO hay tarima
    """
    bit_idx = _pallet_bit_index(side)

    tp_log("Esperando tarima en lado " + side + "...")
    while get_input_register_bit(bit_idx) == OFF:
        wait(0.5)  # Revisa el bit cada 0.5 segundos

    tp_log("Tarima detectada en lado " + side + ".")

def wait_remove_finished_pallet(side):
    """
    Espera a que retiren la tarima terminada del lado indicado ('L' o 'R').

    Se asume:
      - bit == ON  -> hay tarima presente
      - bit == OFF -> tarima retirada
    """
    bit_idx = _pallet_bit_index(side)

    tp_log("Esperando a que retiren la tarima del lado " + side + "...")
    while get_input_register_bit(bit_idx) == ON:
        wait(0.5)

    tp_log("Tarima retirada en lado " + side + ".")

def wait_conveyor_ready():
    """
    Espera a que el PLC indique que la caja está lista para pick.
    El bit CONV_READY_BIT debe permanecer en ON para continuar.
    """
    tp_log("Esperando conveyor listo para pick...")
    while get_input_register_bit(CONV_READY_BIT) == OFF:
        wait(0.2)
    tp_log("Conveyor listo.")



# =====================================================================
# LIFTER100 (or_lift) - Lógica multinivel + seguridad + compensación
# =====================================================================
# Esta sección maneja el Lift100:
# - Convierte capas ("camas") a niveles de lifter (0,1,2)
# - Compensa los frames de trabajo según la altura
# - Verifica estados de error / posición del lifter

# Tramos mecánicos del lifter
DZ_LIFTER_1 = 400.0         # primer tramo (mm)
DZ_LIFTER_2 = 270.0         # segundo tramo (mm) (total ≈ 670 mm)

# Mapa lógico por cama (0-based):
#   0..3 -> nivel 0 (0 mm, lifter abajo)
#   4..6 -> nivel 1 (+400 mm)
#   7..8 -> nivel 2 (+400+270 mm)
def lifter_level_for_layer(layer):
    """
    Devuelve el nivel lógico del lifter según la cama (layer 0-based):
      0-3 -> 0
      4-6 -> 1
      7-8 -> 2
    """
    if layer <= 3:
        return 0
    elif layer <= 6:
        return 1
    else:
        return 2

def _level_offset(level):
    """
    Devuelve el offset total en Z según el nivel del lifter.
    Este offset se usa para compensar frames (bajan en Z cuando el lifter sube).
    """
    if level == 0:
        return 0.0
    elif level == 1:
        return DZ_LIFTER_1
    elif level == 2:
        return DZ_LIFTER_1 + DZ_LIFTER_2
    return 0.0

def lifter_target_pos_for_level(level):
    """
    Posición objetivo en mm del Lift100 para un nivel lógico:
      level 0 ->   0 mm
      level 1 -> 400 mm
      level 2 -> 670 mm
    """
    if level == 0:
        return 0.0
    elif level == 1:
        return 400.0
    elif level == 2:
        return 670.0
    return 0.0


def lifter_level_from_pos(pos):
    """
    Estima el nivel lógico (0,1,2) según la posición real [mm] del Lift100.
    Ajusta los umbrales según los valores reales de tu instalación.
    """
    # Ejemplo: 0..200 => nivel 0, 200..540 => nivel 1, >540 => nivel 2
    if pos < 200.0:
        return 0
    elif pos < 540.0:
        return 1
    else:
        return 2


# Estado actual del lifter (nivel lógico 0/1/2)
_lifter_level = 0


# ---------------------- helpers de seguridad Lift100 -----------------

def lifter_wait_ready(timeout=15.0):
    """
    Espera a que el Lift100 termine cualquier movimiento (isBusy == False).
    Usa un timeout para evitar bucles infinitos.
    """
    t = 0.0
    while or_lift.isBusy():
        wait(0.1)
        t = t + 0.1
        if t >= timeout:
            tp_log("TIMEOUT esperando a que el Lift100 termine el movimiento.")
            break

def lifter_check_error():
    """
    Consulta or_lift.get_error() y registra el código si no es 0.
    NO detiene el programa, sólo deja traza.
    """
    err = or_lift.get_error()
    if err != 0:
        tp_log("ADVERTENCIA: Lift100 error code = " + str(err))
    return err

def lifter_check_position(level, tol=5.0):
    """
    Verifica que el Lift100 esté dentro de una tolerancia ±tol [mm]
    alrededor de la posición esperada para 'level'.
    """
    if not or_lift.isconn():
        tp_log("Lift100 no conectado; no se puede verificar posición.")
        return False

    pos = or_lift.get_pos()
    tgt = lifter_target_pos_for_level(level)
    if abs(pos - tgt) <= tol:
        return True

    tp_log("ADVERTENCIA: Lift100 desincronizado. level=" + str(level) +
           " pos=" + str(pos) + " esperado=" + str(tgt))
    return False

def lifter_safe_init():
    """
    Verifica conexión e inicialización del Lift100.
    Si no está inicializado, ejecuta or_lift.init() y espera a que termine.
    NO toca frames ni niveles, sólo deja el Lift100 referenciado.
    """
    if not or_lift.isconn():
        tp_log("ERROR: Lift100 no conectado (or_lift.isconn() == False).")
        return

    if or_lift.isInit():
        tp_log("Lift100 ya está inicializado.")
        return

    tp_log("Inicializando Lift100...")
    or_lift.init()
    lifter_wait_ready()

    if not or_lift.isInit():
        tp_log("ADVERTENCIA: or_lift.isInit() sigue en False después de init().")
    else:
        tp_log("Lift100 inicializado correctamente.")


# ---------------------- frames + nivel lifter ------------------------

def _lifter_do_set_level(level):
    """
    Ajusta el Lift100 al nivel indicado usando or_lift.move().
    Niveles permitidos:
      0 -> ~0 mm
      1 -> ~400 mm
      2 -> ~670 mm
    Incluye:
      - Verificación de conexión.
      - Inicialización segura si aún no está init.
      - Espera a que termine el movimiento (isBusy).
      - Chequeo de error y de posición final.
    """
    # Asegurar conexión e init
    lifter_safe_init()
    if not or_lift.isconn():
        tp_log("No se puede mover Lift100: sin conexión.")
        return

    # Validar nivel
    if not (level == 0 or level == 1 or level == 2):
        tp_log("Nivel Lift100 inválido: " + str(level) +
               ". Re-inicializando a posición 0.")
        or_lift.init()
        lifter_wait_ready()
        lifter_check_error()
        return

    # Calcular posición objetivo en mm
    tgt = lifter_target_pos_for_level(level)

    # Si ya está dentro de tolerancia y no está ocupado, no mover
    cur = or_lift.get_pos()
    if abs(cur - tgt) < 2.0 and (not or_lift.isBusy()):
        tp_log("Lift100 ya en nivel " + str(level) +
               " (pos=" + str(cur) + " mm).")
        return

    tp_log("Moviendo Lift100 a nivel " + str(level) +
           " (" + str(tgt) + " mm).")

    # Movimiento con velocidad razonable dentro del rango 10–100 mm/s
    or_lift.move(tgt, 80.0)

    # Esperar a que termine
    lifter_wait_ready()

    # Revisar si hay errores
    lifter_check_error()

    # Verificar posición final
    lifter_check_position(level)


def apply_level_to_frames(level):
    """
    A partir de los frames ORIGINALES nivel 0 (191, 192, 193),
    escribe los frames de trabajo (101, 102, 103) compensando en Z
    según el nivel lógico del lifter (0,1,2).

    Regla:
      new_z = z_original - offset(level)
    donde offset(level) usa _level_offset(level).
    """
    dz = _level_offset(level)

    # Lista de mapeos (frame_original -> frame_trabajo)
    pairs = [
        (conv_frame_orig,  conv_frame),
        (left_frame_orig,  left_frame),
        (right_frame_orig, right_frame)
    ]

    for f_orig, f_work in pairs:
        # Obtener pose del frame original (nivel 0)
        pose_orig, ref_orig = get_user_cart_coord(f_orig)

        # Se mantiene X, Y, RX, RY, RZ; sólo se compensa Z
        new_pose = posx(
            pose_orig[0],              # X
            pose_orig[1],              # Y
            pose_orig[2] - dz,         # Z compensada hacia abajo
            pose_orig[3],              # RX
            pose_orig[4],              # RY
            pose_orig[5],              # RZ
            rot_mode
        )

        # Escribimos en el frame de TRABAJO correspondiente
        overwrite_user_cart_coord(f_work, new_pose, ref_orig, DR_TEMPORARY)


def lifter_set_level(side, level):
    """
    Mueve el lifter al nivel indicado (0,1,2) y ajusta SIEMPRE los frames
    de TRABAJO (101,102,103) a partir de los frames ORIGINALES nivel 0
    (191,192,193), sin modificar jamás los originales.

    Pasos:
      - Si el nivel ya es _lifter_level, no hace nada.
      - Mueve físicamente el lifter al nivel deseado.
      - Aplica la compensación de frames con apply_level_to_frames(level).
      - Actualiza _lifter_level.
    """
    global _lifter_level

    # Protección: si ya estamos en ese nivel lógico, no hacer nada
    if level == _lifter_level:
        tp_log("Lift100 ya en nivel lógico " + str(level) + ".")
        return

    tp_log("Cambiando lifter a nivel " + str(level) +
           " (offset Z = " + str(_level_offset(level)) + " mm).")

    # Mover físicamente el lifter
    _lifter_do_set_level(level)

    # Ajustar frames de trabajo en función de los frames originales
    apply_level_to_frames(level)

    # Actualizar estado lógico
    _lifter_level = level


def lifter_restore_frames():
    """
    Restaura el sistema a nivel 0:
      - Mueve físicamente el lifter a nivel 0.
      - Aplica apply_level_to_frames(0) para que 101/102/103 coincidan
        con los frames originales nivel 0.
      - Actualiza _lifter_level = 0.
    """
    global _lifter_level

    # Mover lifter físicamente a nivel 0
    _lifter_do_set_level(0)

    # Aplicar compensación de nivel 0 (sin desplazamiento en Z)
    apply_level_to_frames(0)

    # Estado lógico
    _lifter_level = 0



# =====================================================================
# Datos PLACE (por capas y lados)
# =====================================================================
# Estructura:
#   left_layers / right_layers: lista de layers (0..N-1).
#   Cada layer: lista de 9 slots (0..8).
#   Cada slot: (X, Y, Z, RX, RY, RZ) en el frame del pallet.
#
# Estas tablas definen el patrón exacto de paletizado.

left_layers = [
    # LAYER 1 (Left)
    [
        (105.0, 402.0, 235.0, -180.0, 0.0,  90.0),
        (593.0,  90.0, 235.0, -180.0, 0.0, 180.0),
        (593.0, 265.0, 235.0, -180.0, 0.0,-180.0),
        (593.0, 440.0, 235.0, -180.0, 0.0,-180.0),
        (593.0, 615.0, 235.0, -180.0, 0.0,-180.0),
        (593.0, 790.0, 235.0, -180.0, 0.0,-180.0),
        (593.0, 965.0, 235.0, -180.0, 0.0,-180.0),
        (593.0,1140.0, 235.0, -180.0, 0.0,-180.0),
        (105.0,1212.0, 235.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 2 (Left)
    [
        (915.0, 812.0, 356.0, -180.0, 0.0,  90.0),
        (915.0, 407.0, 356.0, -180.0, 0.0,  90.0),
        (418.0,  90.0, 356.0, -180.0, 0.0,-180.0),
        (418.0, 265.0, 356.0, -180.0, 0.0, 180.0),
        (418.0, 440.0, 356.0, -180.0, 0.0,-180.0),
        (418.0, 615.0, 356.0, -180.0, 0.0,-180.0),
        (418.0, 790.0, 356.0, -180.0, 0.0,-180.0),
        (418.0, 965.0, 356.0, -180.0, 0.0,-180.0),
        (418.0,1140.0, 356.0, -180.0, 0.0,-180.0)
    ],
    # LAYER 3 (Left)
    [
        (105.0, 402.0, 477.0, -180.0, 0.0,  90.0),
        (593.0,  90.0, 477.0, -180.0, 0.0,-180.0),
        (593.0, 265.0, 477.0, -180.0, 0.0,-180.0),
        (593.0, 440.0, 477.0, -180.0, 0.0,-180.0),
        (593.0, 615.0, 477.0, -180.0, 0.0,-180.0),
        (593.0, 790.0, 477.0, -180.0, 0.0,-180.0),
        (593.0, 965.0, 477.0, -180.0, 0.0,-180.0),
        (593.0,1140.0, 477.0, -180.0, 0.0,-180.0),
        (105.0,1212.0, 477.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 4 (Left)
    [
        (915.0, 812.0, 597.0, -180.0, 0.0,  90.0),
        (915.0, 407.0, 597.0, -180.0, 0.0,  90.0),
        (418.0,  90.0, 597.0,  180.0, 0.0,-180.0),
        (418.0, 265.0, 597.0, -180.0, 0.0,-180.0),
        (418.0, 440.0, 597.0, -180.0, 0.0,-180.0),
        (418.0, 615.0, 597.0, -180.0, 0.0,-180.0),
        (418.0, 790.0, 597.0, -180.0, 0.0,-180.0),
        (418.0, 965.0, 597.0, -180.0, 0.0,-180.0),
        (418.0,1140.0, 597.0, -180.0, 0.0,-180.0)
    ],
    # LAYER 5 (Left)
    [
        (105.0, 402.0, 717.0, -180.0, 0.0,  90.0),
        (593.0,  90.0, 717.0, -180.0, 0.0, 180.0),
        (593.0, 265.0, 717.0, -180.0, 0.0,-180.0),
        (593.0, 440.0, 717.0, -180.0, 0.0,-180.0),
        (593.0, 615.0, 717.0, -180.0, 0.0,-180.0),
        (593.0, 790.0, 717.0, -180.0, 0.0,-180.0),
        (593.0, 965.0, 717.0, -180.0, 0.0,-180.0),
        (593.0,1140.0, 717.0, -180.0, 0.0,-180.0),
        (105.0,1212.0, 717.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 6 (Left)
    [
        (915.0, 812.0, 837.0, -180.0, 0.0,  90.0),
        (915.0, 407.0, 837.0, -180.0, 0.0,  90.0),
        (418.0,  90.0, 837.0,  180.0, 0.0,-180.0),
        (418.0, 265.0, 837.0, -180.0, 0.0,-180.0),
        (418.0, 440.0, 837.0, -180.0, 0.0, 180.0),
        (418.0, 615.0, 837.0, -180.0, 0.0,-180.0),
        (418.0, 790.0, 837.0, -180.0, 0.0, 180.0),
        (418.0, 965.0, 837.0, -180.0, 0.0,-180.0),
        (418.0,1140.0, 837.0, -180.0, 0.0,-180.0)
    ],
    # LAYER 7 (Left)
    [
        (105.0, 402.0, 957.0, -180.0, 0.0,  90.0),
        (593.0,  90.0, 957.0, -180.0, 0.0,-180.0),
        (593.0, 265.0, 957.0, -180.0, 0.0,-180.0),
        (593.0, 440.0, 957.0, -180.0, 0.0,-180.0),
        (593.0, 615.0, 957.0, -180.0, 0.0,-180.0),
        (593.0, 790.0, 957.0, -180.0, 0.0,-180.0),
        (593.0, 965.0, 957.0, -180.0, 0.0, 180.0),
        (593.0,1140.0, 957.0, -180.0, 0.0,-180.0),
        (105.0,1212.0, 957.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 8 (Left)
    [
        (915.0, 812.0,1077.0, -180.0, 0.0,  90.0),
        (915.0, 407.0,1077.0, -180.0, 0.0,  90.0),
        (418.0,  90.0,1077.0, -180.0, 0.0,-180.0),
        (418.0, 265.0,1077.0, -180.0, 0.0,-180.0),
        (418.0, 440.0,1077.0, -180.0, 0.0,-180.0),
        (418.0, 615.0,1077.0, -180.0, 0.0,-180.0),
        (418.0, 790.0,1077.0, -180.0, 0.0,-180.0),
        (418.0, 965.0,1077.0, -180.0, 0.0, 180.0),
        (418.0,1140.0,1077.0, -180.0, 0.0,-180.0)
    ],
    # LAYER 9 (Left)
    [
        (105.0, 402.0,1197.0, -180.0, 0.0,  90.0),
        (593.0,  90.0,1197.0, -180.0, 0.0,-180.0),
        (593.0, 265.0,1197.0, -180.0, 0.0,-180.0),
        (593.0, 440.0,1197.0, -180.0, 0.0,-180.0),
        (593.0, 615.0,1197.0, -180.0, 0.0,-180.0),
        (593.0, 790.0,1197.0, -180.0, 0.0,-180.0),
        (593.0, 965.0,1197.0, -180.0, 0.0, 180.0),
        (593.0,1140.0,1197.0, -180.0, 0.0,-180.0),
        (105.0,1212.0,1197.0, -180.0, 0.0,  90.0)
    ]
]

right_layers = [
    # LAYER 1 (Right)
    [
        (905.0, 402.0, 235.0, -180.0, 0.0, -90.0),
        (417.0,  80.0, 235.0, -180.0, 0.0,   0.0),
        (417.0, 255.0, 235.0, -180.0, 0.0,   0.0),
        (417.0, 430.0, 235.0, -180.0, 0.0,   0.0),
        (417.0, 605.0, 235.0, -180.0, 0.0,   0.0),
        (417.0, 780.0, 235.0, -180.0, 0.0,   0.0),
        (417.0, 955.0, 235.0, -180.0, 0.0,   0.0),
        (417.0,1130.0, 235.0, -180.0, 0.0,   0.0),
        (905.0,1213.0, 235.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 2 (Right)
    [
        ( 95.0, 808.0, 356.0, -180.0, 0.0, -90.0),
        ( 95.0, 402.0, 356.0, -180.0, 0.0, -90.0),
        (593.0,  80.0, 356.0, -180.0, 0.0,   0.0),
        (593.0, 255.0, 356.0, -180.0, 0.0,   0.0),
        (593.0, 430.0, 356.0, -180.0, 0.0,   0.0),
        (593.0, 605.0, 356.0, -180.0, 0.0,   0.0),
        (593.0, 780.0, 356.0, -180.0, 0.0,   0.0),
        (593.0, 955.0, 356.0, -180.0, 0.0,   0.0),
        (593.0,1130.0, 356.0, -180.0, 0.0,   0.0)
    ],
    # LAYER 3 (Right)
    [
        (905.0, 402.0, 477.0, -180.0, 0.0, -90.0),
        (417.0,  80.0, 477.0, -180.0, 0.0,   0.0),
        (417.0, 255.0, 477.0, -180.0, 0.0,   0.0),
        (417.0, 430.0, 477.0, -180.0, 0.0,   0.0),
        (417.0, 605.0, 477.0, -180.0, 0.0,   0.0),
        (417.0, 780.0, 477.0, -180.0, 0.0,   0.0),
        (417.0, 955.0, 477.0, -180.0, 0.0,   0.0),
        (417.0,1130.0, 477.0, -180.0, 0.0,   0.0),
        (905.0,1213.0, 477.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 4 (Right)
    [
        ( 95.0, 808.0, 598.0, -180.0, 0.0, -90.0),
        ( 95.0, 402.0, 598.0, -180.0, 0.0, -90.0),
        (593.0,  80.0, 598.0, -180.0, 0.0,   0.0),
        (593.0, 255.0, 598.0, -180.0, 0.0,   0.0),
        (593.0, 430.0, 598.0, -180.0, 0.0,   0.0),
        (593.0, 605.0, 598.0, -180.0, 0.0,   0.0),
        (593.0, 780.0, 598.0, -180.0, 0.0,   0.0),
        (593.0, 955.0, 598.0, -180.0, 0.0,   0.0),
        (593.0,1130.0, 598.0, -180.0, 0.0,   0.0)
    ],
    # LAYER 5 (Right)
    [
        (905.0, 402.0, 719.0, -180.0, 0.0, -90.0),
        (417.0, 80.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 255.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 430.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 605.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 780.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 955.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 1130.0, 719.0, -180.0, 0.0, 0.0),
        (905.0, 1213.0, 719.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 6 (Right)
    [
        (95.0, 808.0, 840.0, -180.0, 0.0, -90.0),
        (95.0, 402.0, 840.0, -180.0, 0.0, -90.0),
        (593.0, 80.0, 840.0, -180.0, 0.0, 0.0),
        (593.0, 255.0, 840.0, -180.0, 0.0, 0.0),
        (593.0, 430.0, 840.0, -180.0, 0.0, 0.0),
        (593.0, 605.0, 840.0, -180.0, 0.0, 0.0),
        (593.0, 780.0, 840.0, -180.0, 0.0, 0.0),
        (593.0, 955.0, 840.0, -180.0, 0.0, 0.0),
        (593.0, 1130.0, 840.0, -180.0, 0.0, 0.0)
    ],
    # LAYER 7 (Right)
    [
        (905.0, 402.0, 961.0, -180.0, 0.0, -90.0),
        (417.0, 80.0, 961.0, -180.0, 0.0, 0.0),
        (417.0, 255.0, 961.0, -180.0, 0.0, 0.0),
        (417.0, 430.0, 719.0, -180.0, 0.0, 0.0),
        (417.0, 605.0, 961.0, -180.0, 0.0, 0.0),
        (417.0, 780.0, 961.0, -180.0, 0.0, 0.0),
        (417.0, 955.0, 961.0, -180.0, 0.0, 0.0),
        (417.0, 1130.0, 961.0, -180.0, 0.0, 0.0),
        (905.0, 1213.0, 961.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 8 (Right)
    [
        (95.0, 808.0, 1082.0, -180.0, 0.0, -90.0),
        (95.0, 808.0, 1082.0, -180.0, 0.0, -90.0),
        (593.0, 80.0, 1082.0, -180.0, 0.0, 0.0 ),
        (593.0, 255.0, 1082.0, -180.0, 0.0, 0.0),
        (593.0, 430.0, 1082.0, -180.0, 0.0, 0.0),
        (593.0, 605.0, 1082.0, -180.0, 0.0, 0.0),
        (593.0, 780.0, 1082.0, -180.0, 0.0, 0.0),
        (593.0, 955.0, 1082.0, -180.0, 0.0, 0.0),
        (593.0, 1130.0, 1082.0, -180.0, 0.0, 0.0)
    ],
    # LAYER 9 (Right)
    [
        (905.0, 402.0, 1203.0, -180.0, 0.0, -90.0),
        (417.0, 80.0, 1203.0, -180.0, 0.0, 0.0),
        (417.0, 255.0, 1203.0, -180.0, 0.0, 0.0),
        (417.0, 430.0, 1203.0, -180.0, 0.0, 0.0),
        (417.0, 605.0, 1203.0, -180.0, 0.0, 0.0),
        (417.0, 780.0, 1203.0, -180.0, 0.0, 0.0),
        (417.0, 955.0, 1203.0, -180.0, 0.0, 0.0),
        (417.0, 1130.0, 1203.0, -180.0, 0.0, 0.0),
        (905.0, 1213.0, 1203.0, -180.0, 0.0, -90.0)
    ]
]

# =====================================================================
# Half plan (A→B)
# =====================================================================
# Cada tupla: (layer_origen, slot_origen, layer_destino_halfB, slot_destino_halfB)
# Indica para qué slots la caja se pone en dos mitades:
# - Half-A en el origen
# - Half-B en un destino diferente

half_plan_left  = [(0,8,1,0), (2,8,3,0), (4,8,5,0), (6,8,7,0)]
half_plan_right = [(0,8,1,0), (2,8,3,0), (4,8,5,0), (6,8,7,0)]

# =====================================================================
# Mid por capa (MidA / MidB) en joints
# =====================================================================
# Estos son puntos intermedios en joint space para cada capa.
# Se utilizan para evitar singularidades o rotaciones bruscas de la muñeca.

mid_left_a = [
    posj(0.72, 58.86, 107.11, 0.00, 14.02, 0.72),
    posj(0.72, 49.68, 109.40, 0.00, 20.90, 0.72),
    posj(0.72, 40.89, 109.82, 0.00, 29.27, 0.72),
    posj(0.72, 32.94, 108.37, 0.00, 38.67, 0.72),
    posj(0.72, 52.23, 108.94, 0.00, 18.80, 0.72),
    posj(0.72, 43.37, 109.89, 0.00, 26.71, 0.72),
    posj(0.72, 35.16, 108.98, 0.00, 35.83, 0.72),
    posj(0.72, 27.97, 106.24, 0.00, 45.76, 0.72),
    posj(0.72, 22.09, 101.74, 0.00, 56.14, 0.72)
]

mid_right_a = [
    posj(-181.11, 58.26, 110.56, 0.00, 11.16, -1.11),
    posj(-181.11, 48.75, 112.90, 0.00, 18.33, -1.11),
    posj(-181.11, 39.58, 113.33, 0.00, 27.07, -1.11),
    posj(-181.11, 31.26, 111.85, 0.00, 36.88, -1.11),
    posj(-181.11, 51.64, 112.39, 0.00, 15.96, -1.11),
    posj(-181.11, 42.32, 113.41, 0.00, 24.25, -1.11),
    posj(-181.11, 33.65, 112.49, 0.00, 33.84, -1.11),
    posj(-181.11, 25.99, 109.65, 0.00, 44.35, -1.11),
    posj(-181.11, 19.81, 105.01, 0.00, 55.16, -1.11)
]

def _rot_j6(j, delta):
    """
    Devuelve un nuevo posj con el mismo J1..J5 y J6 rotado en 'delta'.
    Se usa para generar MidB a partir de MidA.
    """
    return posj(j[0], j[1], j[2], j[3], j[4], j[5] + delta)

# MidB = MidA con J6 rotado +90°
mid_left_b  = [ _rot_j6(j,  90.0) for j in mid_left_a  ]
mid_right_b = [ _rot_j6(j,  90.0) for j in mid_right_a ]

# ---------------------- mapa MidB configurable -------------
# Esta tabla define qué (layer,slot) deben usar MidB en lugar de MidA.
midB_map_left = [
    (0,0), (0,8),
    (1,0), (1,1),
    (2,0), (2,8),
    (3,0), (3,1),
    (4,0), (4,8),
    (5,0), (5,1),
    (6,0), (6,8),
    (7,0), (7,1),
    (8,0), (8,8)
]

midB_map_right = list(midB_map_left)

# =====================================================================
# Utilidades geométricas
# =====================================================================

def mk_off(dz):
    """
    Crea una posx de offset en Z (relativo) con orientaciones 0.
    Se usa para APPROACH/RETRACT en pick/place.
    """
    return posx(0.0, 0.0, dz, 0.0, 0.0, 0.0, rot_mode)

def mk_off_app():
    """
    Offset sólo para APPROACH de PLACE: (dx_app, dy_app, dz_app).
    Se suma al punto de place para generar el punto de aproximación.
    """
    return posx(dx_app, dy_app, dz_app, 0.0, 0.0, 0.0, rot_mode)

def get_place(side, layer, slot):
    """
    Devuelve:
      - La pose posx del PLACE (en el frame del pallet)
      - El ID de frame (left_frame/right_frame)
    """
    if side == "L":
        p = left_layers[layer][slot]
        return posx(p[0], p[1], p[2], p[3], p[4], p[5], rot_mode), left_frame
    else:
        p = right_layers[layer][slot]
        return posx(p[0], p[1], p[2], p[3], p[4], p[5], rot_mode), right_frame

def get_app(side, layer, slot):
    """
    Calcula la pose de APPROACH a partir del PLACE:
    PLACE + (dx_app, dy_app, dz_app) en el frame del pallet.
    """
    pl, rf = get_place(side, layer, slot)
    # trans(pl, offset, frame_origen, frame_destino)
    return trans(pl, mk_off_app(), rf, rf), rf

def get_ret(side, layer, slot):
    """
    Calcula la pose de RETRACT a partir del PLACE:
    PLACE + (0, 0, dz_ret) en el frame del pallet.
    """
    pl, rf = get_place(side, layer, slot)
    return trans(pl, mk_off(dz_ret), rf, rf), rf

def find_half(side, layer, slot):
    """
    Busca en half_plan_left/right si (layer,slot) es un ORIGEN Half-A.
    Devuelve:
      (True, dl, ds)  si es origen Half y (dl,ds) es el destino Half-B
      (False, 0, 0)   si no es origen Half
    """
    plan = half_plan_left if side == "L" else half_plan_right
    for t in plan:
        if t[0] == layer and t[1] == slot:
            return True, t[2], t[3]
    return False, 0, 0

def is_half_destination(side, layer, slot):
    """
    Indica si (layer,slot) es un DESTINO Half-B.
    Se usa para:
      - Saltar esos slots en la corrida normal (run_from).
      - Reconocer cuando el usuario arranca justo en un Half-B.
    """
    plan = half_plan_left if side == "L" else half_plan_right
    for t in plan:
        if t[2] == layer and t[3] == slot:
            return True
    return False

# --------- selección de MidA / MidB según tabla ----------
def _is_group_b(side, layer, slot):
    """
    Determina si este (layer,slot) debe usar MidB (J6 +90°)
    según midB_map_left/right.
    """
    if side == "L":
        return (layer, slot) in midB_map_left
    else:
        return (layer, slot) in midB_map_right

def get_mid(side, layer, slot):
    """
    Devuelve el joint target Mid adecuado (A o B) según:
      - Lado (Left/Right)
      - Capa (layer)
      - Slot
    Si la capa excede el tamaño de la lista de mids, devuelve None.
    """
    use_b = _is_group_b(side, layer, slot)
    if side == "L":
        if use_b:
            return mid_left_b[layer]  if layer < len(mid_left_b)  else None
        else:
            return mid_left_a[layer]  if layer < len(mid_left_a)  else None
    else:
        if use_b:
            return mid_right_b[layer] if layer < len(mid_right_b) else None
        else:
            return mid_right_a[layer] if layer < len(mid_right_a) else None

# =====================================================================
# Pick desde conveyor
# =====================================================================

# Pose cartesiana del pick en el conveyor (en conv_frame)
pick_pose = posx(422.00, -110.00, 810.00, 180.00, 0.00, 0.0, rot_mode)


def get_pick():
    """
    Devuelve la pose de pick y el frame del conveyor.
    """
    return pick_pose, conv_frame

def get_pick_app():
    """
    APPROACH del pick: pick_pose + dz_app en Z del conveyor.
    """
    return trans(pick_pose, mk_off(dz_app), conv_frame, conv_frame), conv_frame

def get_pick_ret():
    """
    RETRACT del pick: pick_pose + dz_ret en Z del conveyor.
    """
    return trans(pick_pose, mk_off(dz_ret), conv_frame, conv_frame), conv_frame

def plc_set_pick_mode(mode):
    """Envía al PLC el modo de pick como un entero.

    Mapeo propuesto:
      0 = idle
      1 = full
      2 = half_b

    half_a NO se usa en el proceso actual.
    """
    if mode == "full":
        val = 1
    elif mode == "half_b":
        val = 2
    else:
        # Cualquier otro valor (incluido "half_a") se mapea a 0
        val = 0

    tp_log("PLC pick_mode_cmd = " + str(val) + " (modo=" + str(mode) + ")")
    set_output_register_int(PICK_MODE_REG, val)

def plc_set_pick_vac_ok(ok_flag):
    """
    Bit que indica al PLC si el último pick tuvo vacío válido.

      ok_flag = True  -> bit = 1 (vacío OK, pick válido)
      ok_flag = False -> bit = 0 (sin vacío / pick fallido)
    """
    bit_val = 1 if ok_flag else 0
    tp_log("PLC pick_vac_ok_bit = " + str(bit_val))
    set_output_register_bit(VAC_OK_BIT, bit_val)



def plc_set_vacuum_loss(flag):
    """
    Envía al PLC el estado de 'pérdida de vacío'.

      flag = 0/False -> sin fallo / normal
      flag = 1/True  -> pérdida de vacío detectada
    """
    bit_val = 1 if flag else 0
    tp_log("PLC vac_loss_bit = " + str(bit_val))
    set_output_register_bit(VAC_LOSS_BIT, bit_val)


def plc_set_maintenance_state(is_on):
    """
    Envía al PLC si el robot está en modo mantenimiento.
    """
    bit_val = 1 if is_on else 0
    tp_log("PLC maint_state_bit = " + str(bit_val))
    set_output_register_bit(MAINT_BIT, bit_val)



def do_pick(mode):
    """
    Secuencia completa de pick con reintentos por fallo de vacío:

      - Hace hasta 2 intentos automáticos.
      - Si falla esos 2 intentos:
          * Pregunta UNA SOLA VEZ si quiere reintentar.
          * Si el usuario elige reintentar:
                - Se permiten otros 2 intentos.
          * Si vuelve a fallar estos 2 intentos, o el usuario elige no reintentar:
                - Se llama a modo mantenimiento (contraseña, sin pallets, etc.).

    Devuelve True si hubo vacío OK, False si se entra a modo mantenimiento.
    """
    # Avisar cómo se pretende hacer el pick (full / half_b)
    plc_set_pick_mode(mode)
    # Por defecto, asumimos que NO hay vacio valido hasta que se compruebe
    plc_set_pick_vac_ok(False)

    attempts = 0
    max_attempts = 2              # intentos por ronda
    extra_retry_used = False      # solo se permite una ronda extra

    while True:
        attempts = attempts + 1

        # 1) Esperar conveyor listo
        wait_conveyor_ready()

        # 2) Ir al hub sobre el conveyor
        movej(up_conv, vj_fast, aj_fast)

        # 3) Calcular APPROACH, PICK y RETRACT
        a, _ = get_pick_app()
        p, _ = get_pick()
        r, _ = get_pick_ret()

        # 4) Bajar a APPROACH y luego a PICK
        movel(a, v=vl_slow, a=al_slow, ref=conv_frame)
        movel(p, v=vl_slow, a=al_slow, ref=conv_frame)

        # 5) Activar gripper según el modo
        if mode == "full":
            grip_full()
        elif mode == "half_a":
            grip_half_a()
        elif mode == "half_b":
            grip_half_b()
        else:
            tp_log("Modo de pick desconocido: " + str(mode))

        # 6) Esperar vacío OK (si está habilitado)
        if wait_vacuum_ok(mode, timeout=1.5):
            # ÉXITO: subir y salir
            movel(r, v=vl_slow, a=al_slow, ref=conv_frame)
            movej(up_conv, vj_fast, aj_fast)

            # Avisar al PLC que este pick fue valido (hubo vacio)
            plc_set_pick_vac_ok(True)
            if attempts > 1:
                tp_log("Pick recuperado en intento " + str(attempts) +
                       " (modo=" + mode + ").")
            return True

        # 7) FALLO DE VACÍO en este intento
        tp_log("Fallo de vacio en intento " + str(attempts) +
               " (modo=" + mode + ").")

        # Soltar la caja en la posición de pick y subir
        rel_by_mode(mode)
        movel(r, v=vl_slow, a=al_slow, ref=conv_frame)
        movej(up_conv, vj_fast, aj_fast)

        # ¿Ya se terminaron los intentos de esta ronda?
        if attempts >= max_attempts:
            # Si ya usamos la ronda extra, se va directo a mantenimiento
            if extra_retry_used:
                tp_log("Fallo de vacio tras reintento extra. Llamando a mantenimiento.")
                plc_set_pick_vac_ok(False)
                go_to_maintenance_mode()
                return False

            # Primera vez que fallan los max_attempts
            tp_popup("Fallo de vacio en pick. Revise gripper y conveyor.", DR_PM_ALARM)
            resp = tp_get_user_input("1=Reintentar una vez mas, 2=Llamar mantenimiento", DR_VAR_INT)
            resp = clamp(resp, 1, 2)

            if resp == 1:
                tp_log("Operador eligio reintentar pick una vez mas.")
                extra_retry_used = True
                attempts = 0       # reseteamos contador para la nueva ronda
                continue
            else:
                tp_log("Operador eligio llamar a mantenimiento tras fallo de vacio en pick.")
                go_to_maintenance_mode()
                plc_set_pick_vac_ok(False)
                return False

        # Si aún no se llegaron a los max_attempts de esta ronda,
        # el while continua y se hace otro intento automáticamente.
        tp_log("Reintentando pick (intento " +
               str(attempts + 1) + " de " + str(max_attempts) + ").")




# =====================================================================
# Place (full / half)
# =====================================================================

def do_place(side, layer, slot, rtype):
    """
    Secuencia completa de place en un slot:
      - Mueve al hub del lado (up_left/up_right)
      - Pasa por MidA o MidB (si está definido para esa capa/slot)
      - Va al APPROACH (con offsets X/Y/Z)
      - Baja al PLACE
      - Suelta tipo rtype (full/half_a/half_b)
      - Sube a RETRACT
      - Regresa al hub del lado

    Además:
      - Si se detectó pérdida de vacío ANTES de bajar al pallet,
        después del place se avisa al PLC y se decide:
            1 = Continuar
            2 = Llamar mantenimiento

    Devuelve:
      True  -> place terminado y se puede continuar
      False -> se llamó a mantenimiento y NO se debe seguir
    """
    up = up_left if side == "L" else up_right

    pl, rp = get_place(side, layer, slot)
    ap, ra = get_app(side, layer, slot)
    rt, rr = get_ret(side, layer, slot)

    movej(up, vj_fast, aj_fast)

    # 1) Detectar posible pérdida de vacío ANTES de bajar
    lost_vacuum = False
    if not has_vacuum_for_mode(rtype):
        lost_vacuum = True
        tp_log("Perdida de vacio detectada antes de place. side=" +
               side + " layer=" + str(layer + 1) +
               " slot=" + str(slot + 1) +
               " tipo=" + str(rtype))

    # 2) Place normal
    use_b = _is_group_b(side, layer, slot)
    m = get_mid(side, layer, slot)
    if not (m == None):
        if use_b:
            tp_log("MidB en " + side + " L" + str(layer+1) + " S" + str(slot+1))
        else:
            tp_log("MidA en " + side + " L" + str(layer+1) + " S" + str(slot+1))
        movej(m, vj_fast, aj_fast)

    movel(ap, v=vl_slow, a=al_slow, ref=ra)
    movel(pl, v=vl_slow, a=al_slow, ref=rp)

    if   rtype == "full":
        rel_full()
    elif rtype == "half_a":
        rel_half_a()
    elif rtype == "half_b":
        rel_half_b()
    else:
        tp_log("WARNING: do_place con tipo desconocido: " + str(rtype))

    movel(rt, v=vl_slow, a=al_slow, ref=rr)
    movej(up, vj_fast, aj_fast)

    # 3) Si hubo pérdida de vacío, avisar al PLC y decidir
    if lost_vacuum:
        plc_set_vacuum_loss(1)

        tp_popup("Perdida de vacio antes de place. Revise la tarima.", DR_PM_ALARM)
        resp = tp_get_user_input("1=Continuar paletizado, 2=Llamar mantenimiento", DR_VAR_INT)
        resp = clamp(resp, 1, 2)

        if resp == 1:
            tp_log("Operador eligio continuar tras perdida de vacio en place.")
            plc_set_vacuum_loss(0)
            return True
        else:
            tp_log("Operador eligio llamar a mantenimiento tras perdida de vacio en place.")
            go_to_maintenance_mode()
            return False

    # Si no hubo pérdida de vacío, todo OK
    return True





# =====================================================================
# Lógica Half-A / Half-B
# =====================================================================

# Conjunto que almacena qué destinos Half-B ya han sido llenados
_halfB_filled = set()

# Conjunto que almacena qué destinos Half-B ya han sido llenados
_halfB_filled = set()

def do_half(side, layer, slot, is_half, dl, ds):
    """
    Maneja la lógica de Half-A / Half-B para un slot.

    Si is_half == True:
      - Coloca una Half-A en el slot origen
      - Coloca la Half-B en el destino indicado por (dl, ds) si está disponible

    Si is_half == False:
      - Coloca una caja FULL normal en el slot.

    Devuelve:
      True  -> se puede continuar paletizando
      False -> se pidió mantenimiento en algún place
    """
    global _halfB_filled

    if is_half:
        # Log de la relación Half-A origen -> Half-B destino
        tp_log("Half-A: L" + str(layer+1) + " S" + str(slot+1) +
               " → L" + str(dl+1) + " S" + str(ds+1))

        # 1) Colocar Half-A en el origen
        ok_a = do_place(side, layer, slot, "half_a")
        # Si en este place se pidió mantenimiento (pérdida de vacío + opción 2)
        if not ok_a:
            tp_log("do_half: mantenimiento solicitado al colocar Half-A.")
            return False

        # 2) Verificar si el destino Half-B ya fue llenado antes
        if (side, dl, ds) in _halfB_filled:
            tp_log("Half-B destino ya estaba lleno. Omitiendo: L" +
                   str(dl+1) + " S" + str(ds+1))
            return True  # No es error, simplemente no repetimos

        # 3) Verificar que el destino está dentro de rango en las tablas de layers
        if side == "L":
            ok_dest = (dl < len(left_layers) and ds < len(left_layers[dl]))
        else:
            ok_dest = (dl < len(right_layers) and ds < len(right_layers[dl]))

        if not ok_dest:
            tp_log("Destino Half-B fuera de rango. Solo Half-A en origen.")
            return True  # No paramos el ciclo, solo avisamos

        # 4) Ajustar nivel del lifter según la capa de destino
        dest_level = lifter_level_for_layer(dl)
        lifter_set_level(side, dest_level)

        # Ir al hub del lado (izquierdo o derecho)
        movej((up_right if side == "R" else up_left),
              v=vj_slow, a=aj_slow)

        tp_log("Colocando Half-B en destino L" +
               str(dl+1) + " S" + str(ds+1))

        # 5) Colocar la Half-B en el destino
        ok_b = do_place(side, dl, ds, "half_b")
        if not ok_b:
            tp_log("do_half: mantenimiento solicitado al colocar Half-B.")
            return False

        # 6) Registrar que este destino Half-B ya fue llenado
        _halfB_filled.add((side, dl, ds))
        return True

    else:
        # Si NO es slot Half, colocar caja completa
        ok_full = do_place(side, layer, slot, "full")
        if not ok_full:
            tp_log("do_half: mantenimiento solicitado al colocar FULL.")
            return False
        return True


# =====================================================================
# tp helpers (Teach Pendant)
# =====================================================================

def clamp(val, lo, hi):
    """
    Limita el valor 'val' al rango [lo, hi].
    """
    if val < lo: return lo
    if val > hi: return hi
    return val

def ask_mode():
    """
    Pregunta el modo de paletizado:
      1 -> Solo un lado (modo single)
      2 -> Ambos lados (modo dual)

    Devuelve 'single' o 'both'.
    """
    msg = "Seleccione modo de paletizado: 1 = Solo un lado, 2 = Ambos lados"
    v = tp_get_user_input(msg, DR_VAR_INT)
    v = clamp(v, 1, 2)

    if v == 1:
        tp_log("Modo seleccionado: SOLO UN LADO.")
        return "single"
    else:
        tp_log("Modo seleccionado: AMBOS LADOS.")
        return "both"

def ask_side():
    """
    Pregunta en qué lado quiere iniciar el usuario.
    El usuario introduce 'A' o 'B', que se mapean a:
      'A'/'a' -> 'L' (Left)
      'B'/'b' -> 'R' (Right)
    """
    s = tp_get_user_input("Seleccione en que Lado quiere iniciar A/B", DR_VAR_STR)
    if s == "A" or s == "a": return "L"
    if s == "B" or s == "b": return "R"
    tp_log("Entrada invalida, usa A o B")
    tp_popup("Entrada invalida, usa A o B", DR_PM_MESSAGE)
    return ask_side()  # Repetir la pregunta hasta que sea válido


def ask_layer(side):
    """
    Pregunta en qué cama (layer) quiere iniciar.
    El usuario responde 1..N y se convierte a índice 0-based.
    """
    n = len(left_layers) if side == "L" else len(right_layers)
    v = tp_get_user_input("Seleccione en que Cama quiere iniciar 1 - " + str(n), DR_VAR_INT)
    v = clamp(v, 1, n)
    return v - 1  # Convertir a 0-based

def ask_slot(side, layer):
    """
    Pregunta en qué slot de la cama quiere iniciar.
    El usuario responde 1..N y se convierte a índice 0-based.
    """
    n = len(left_layers[layer]) if side == "L" else len(right_layers[layer])
    v = tp_get_user_input("Seleccione en que Slot quiere iniciar 1 - " + str(n), DR_VAR_INT)
    v = clamp(v, 1, n)
    return v - 1  # Convertir a 0-based

def ask_initial_action():
    """
    Menu inicial:
      1 -> Home seguro
      2 -> Mantenimiento
      3 -> Paletizado
    """
    msg = "Seleccione accion inicial: 1=Home seguro, 2=Mantenimiento, 3=Paletizado"
    v = tp_get_user_input(msg, DR_VAR_INT)
    return clamp(v, 1, 3)


def ask_home_followup_action():
    """
    Menu despues de hacer home seguro:
      1 -> Mantenimiento
      2 -> Paletizado
    """
    msg = "Seleccione accion: 1=Mantenimiento, 2=Paletizado"
    v = tp_get_user_input(msg, DR_VAR_INT)
    return clamp(v, 1, 2)


# =====================================================================
# helpers para lecturas posx/posj y safe_home
# =====================================================================

# Valores de referencia en X para distinguir si el robot está sobre pallets o conveyor
_left_cx  =  250.0
_right_cx = -1266.0

def _pal_hub(cx):
    """
    Selecciona el hub (up_left o up_right) más cercano según la X actual (cx).
    """
    if abs(cx - _left_cx) <= abs(cx - _right_cx):
        return up_left
    else:
        return up_right

def _get_posx_only():
    """
    Devuelve solo la pose cartesiana actual (sin referencia) desde get_current_posx().
    Maneja ambos formatos posibles.
    """
    res = get_current_posx()
    try:
        pose, _ = res
        return pose
    except:
        return res

def _get_posj_only():
    """
    Devuelve solo la pose en joints actual desde get_current_posj().
    Maneja ambos formatos posibles.
    """
    res = get_current_posj()
    try:
        j, _ = res
        return j
    except:
        return res

# Tolerancia en grados para considerar que el robot está en home
tol_j_deg = 2.0

def _is_home():
    """
    Verifica si la posición actual del robot está dentro de una tolerancia
    alrededor de la posición 'home'.
    """
    jcur = _get_posj_only()
    return (abs(jcur[0] - home[0]) <= tol_j_deg and
            abs(jcur[1] - home[1]) <= tol_j_deg and
            abs(jcur[2] - home[2]) <= tol_j_deg and
            abs(jcur[3] - home[3]) <= tol_j_deg and
            abs(jcur[4] - home[4]) <= tol_j_deg and
            abs(jcur[5] - home[5]) <= tol_j_deg)

def safe_home():
    """
    Lleva al robot de forma segura a la posición 'home':
      - Si ya está en home, no hace nada.
      - Si no:
          1) Sube 100mm en Z en el frame base (movimiento relativo).
          2) Va al hub más cercano (pallets o conveyor) según la Y actual.
          3) Va a 'home'.
    """
    if _is_home():
        return

    # Obtener pose cartesiana actual
    cur = _get_posx_only()
    cx = cur[0]
    cy = cur[1]

    # Subir 100 mm en Z de forma relativa (para despegar del entorno)
    pz = posx(0, 0, 100, 0, 0, 0, rot_mode)
    movel(pz, time=2, ref=DR_BASE, mod=DR_MV_MOD_REL)

    # Elegir ruta segura según la Y actual (sobre pallets o sobre conveyor)
    if cy > 0:
        movej(_pal_hub(cx), v=vj_slow, a=aj_slow)
    else:
        movej(up_conv, v=vj_slow, a=aj_slow)

    # Finalmente ir a home
    movej(home, v=vj_slow, a=aj_slow)

def go_safe_before_lifter():
    """
    Movimiento a una pose segura antes de operar el lifter.
    Se usa para minimizar riesgos de colisión cuando se cambian niveles.
    """
    movej(safe_pose, v=vj_slow, a=aj_slow)

def go_to_maintenance_mode():
    """
    Rutina de llamada a mantenimiento:
      - Pide contraseña de mantenimiento (se repite hasta que sea correcta).
      - Verifica que no haya pallets presentes (L/R).
        * Si hay, pide retirar y espera a que los bits se apaguen.
      - Lleva al robot a una pose segura para mover el lifter.
      - Baja el lifter y restaura frames (nivel 0).
      - Lleva al robot a la pose de mantenimiento.
      - Detiene el programa.
    """
    global _in_maintenance

    # 1) Pedir contraseña en bucle hasta que sea correcta
    while True:
        pwd = tp_get_user_input("Ingrese contrasena de mantenimiento", DR_VAR_STR)

        if pwd == MAINT_PASSWORD:
            tp_log("Contrasena de mantenimiento correcta. Entrando a modo mantenimiento.")
            break

        tp_popup("Contrasena incorrecta. Intente de nuevo.", DR_PM_ALARM)
        tp_log("Contrasena de mantenimiento incorrecta. Reintentando...")

    # Marcamos modo mantenimiento activo
    _in_maintenance = True

    # Avisar al PLC que estamos en modo mantenimiento
    plc_set_maintenance_state(True)

    # 2) Verificar pallets presentes
    if is_pallet_present("L") or is_pallet_present("R"):
        tp_popup("Retire ambas tarimas antes de mantenimiento.", DR_PM_WARNING)
        tp_log("Esperando retiro de tarimas para mantenimiento.")

        if is_pallet_present("L"):
            wait_remove_finished_pallet("L")
        if is_pallet_present("R"):
            wait_remove_finished_pallet("R")

    # 3) Ir a pose segura antes de mover el lifter
    go_safe_before_lifter()

    # 4) Bajar lifter y restaurar frames (nivel 0)
    lifter_restore_frames()

    # 5) Llevar al robot a la pose de mantenimiento
    movej(maint_safe_pose, v=vj_slow, a=aj_slow)

    tp_log("Robot en pose de mantenimiento. Programa detenido.")
    stop(DR_QSTOP)


# =====================================================================
def finish_side(side):
    """
    Secuencia estándar de finalización de un lado:
      - Log de fin de lado.
      - Ir a posición segura antes de mover el lifter.
      - Pedir que retiren la tarima.
      - Esperar a que la tarima sea retirada.
      - Restaurar frames y nivel lógico del lifter a 0.
    """
    global _in_maintenance
    if _in_maintenance:
        tp_log("finish_side: omitido porque estamos en modo mantenimiento.")
        return
    tp_log("Lado " + side + " finalizado.")
    go_safe_before_lifter()

    tp_popup("Retire la tarima terminada del lado " + side + ".", DR_PM_MESSAGE)
    wait_remove_finished_pallet(side)

    lifter_restore_frames()

# =====================================================================
# rutina: ejecutar desde (layer,slot) hasta acabar el lado
# =====================================================================

def run_from(side, start_layer, start_slot):
    """
    Ejecuta la secuencia completa de paletizado desde (start_layer,start_slot)
    hasta completar todas las capas y slots del lado indicado.

    Maneja:
      - Ajuste de nivel del lifter por cada cama.
      - Slots destino Half-B que deben saltarse (ya llenados).
      - Caso especial: última caja de la cama 9 (solo Half-B).
      - Lógica general FULL / Half-A → Half-B.
    """
    #Seleccionar la tabla de layers según el lado
    layers = left_layers if side == "L" else right_layers
    n_layers = len(layers)
    layer = start_layer

    tp_log("run_from: lado " + side +
           " inicio en L" + str(start_layer+1) +
           " S" + str(start_slot+1))

    # Bucle por capas
    while layer < n_layers:
        # Determinar nivel lógico del lifter para esta capa
        lvl = lifter_level_for_layer(layer)
        lifter_set_level(side, lvl)

        # Número de slots en esta capa
        n_slots = len(layers[layer])

        # Si es la capa inicial, empezamos en start_slot; si no, desde 0
        s0 = start_slot if layer == start_layer else 0
        slot = s0

        # Bucle por slots dentro de la capa
        while slot < n_slots:
            # Saltar slots que son destino Half-B (ya fueron llenados por do_half)
            if is_half_destination(side, layer, slot):
                tp_log("run_from: saltando destino Half-B L" +
                       str(layer+1) + " S" + str(slot+1))
                slot = slot + 1
                continue

            # ---- CASO ESPECIAL: última caja de la cama 9 (solo Half-B) ----
            if (layer == n_layers - 1) and (slot == n_slots - 1):
                tp_log("Última caja de la cama 9: sólo Half-B en " +
                       side + " L" + str(layer+1) +
                       " S" + str(slot+1))

                # Aquí se toma directamente Half-B del conveyor
                ok_pick = do_pick("half_b")
                if not ok_pick:
                    tp_log("Abortando lado " + side +
                           " por fallo de vacío en la última caja.")
                    return

            # Se coloca como Half-B en el último slot
            ok_last = do_place(side, layer, slot, "half_b")
            if not ok_last:
                tp_log("run_from: mantenimiento solicitado en ultima caja; se aborta lado.")
                return

            tp_log("Última caja completada en " + side +
                " L" + str(layer+1) +
                " S" + str(slot+1) +
                ". Fin de run_from para este lado.")
            return

            # ---- CASO GENERAL: cajas FULL / Half-A → Half-B ----
            tp_log("run_from: Colocando en " + side +
                   " L" + str(layer+1) +
                   " S" + str(slot+1))

            # Tomar caja completa del conveyor
            ok_pick = do_pick("full")
            if not ok_pick:
                tp_log("Abortando lado " + side +
                       " por fallo de vacío en L" +
                       str(layer+1) + " S" + str(slot+1))
                return  # salir de run_from, no ir a place

            # Determinar si este slot es Half (origen) y su destino
            is_h, dl, ds = find_half(side, layer, slot)
            # Ejecutar lógica de Half-A/Half-B o FULL
            ok_place = do_half(side, layer, slot, is_h, dl, ds)
            if not ok_place:
                tp_log("run_from: se salio por mantenimiento en " +
                    side + " L" + str(layer+1) + " S" + str(slot+1))
                return

            slot = slot + 1  # avanzar al siguiente slot

        layer = layer + 1  # siguiente cama

    tp_log("run_from: lado " + side + " completado.")


# =====================================================================
def run_side_once(side, layer, slot):
    """
    Ejecuta un ciclo completo de paletizado SOLO para el lado 'side',
    comenzando en (layer, slot), respetando:
      - Caso especial: arranque exactamente en última caja (cama 9, slot 9).
      - Caso especial: arranque en destino Half-B.
      - Caso normal: FULL / Half-A → Half-B.

    Al terminar:
      - Deja el robot en posición segura de retirada (finish_side).
      - Espera a que retiren la tarima.
      - Restaura frames y lifter (nivel 0).

    NO toca el otro lado ni regresa a HOME.
    """
    global _halfB_filled
    _halfB_filled = set()

    layers = left_layers if side == "L" else right_layers

    # Asegurar pallet presente en el lado seleccionado
    if not is_pallet_present(side):
        tp_log("No hay tarima en el lado " + side + ". Esperando a que la coloquen...")
        tp_popup("No hay tarima esperando a que la coloquen...", DR_PM_MESSAGE)
        wait_pallet_present(side)

    n_layers = len(layers)
    n_slots_in_layer = len(layers[layer])

    # ---------- CASO ESPECIAL 1: arranque EXACTAMENTE en última caja ----------
    # Es decir, estamos iniciando directamente en la última cama y el último slot.
    if (layer == n_layers - 1) and (slot == n_slots_in_layer - 1):
        tp_log("Arranque en última caja de la cama 9: sólo Half-B.")

        # Ajustar nivel del lifter a esta cama
        lvl0 = lifter_level_for_layer(layer)
        lifter_set_level(side, lvl0)

        # Tomar una media pieza (Half-B) del conveyor
        ok_pick = do_pick("half_b")
        if not ok_pick:
            tp_log("Abortando lado " + side +
                   " por fallo de vacío en la última caja (arranque especial).")
            finish_side(side)
            return

        # Colocar Half-B en ese slot
        ok2 = do_place(side, layer, slot, "half_b")
        if not ok2:
            tp_log("run_side_once: mantenimiento solicitado en ultima caja (arranque especial).")
            finish_side(side)
            return

        # Finalizar lado (posición segura + retirar tarima + restaurar frames/lifter)
        finish_side(side)
        return

    # ---------- CASO ESPECIAL 2: slot inicial es destino Half-B ----------
    # Si el usuario empieza en un slot que es destino Half-B, significa que
    # hay que colocar solo la media caja B en ese slot, y luego continuar.
    if is_half_destination(side, layer, slot):
        tp_log("Arranque en Half-B: se toma media pieza y se coloca en este slot.")

        # Ajustar nivel del lifter para esa cama
        lvl0 = lifter_level_for_layer(layer)
        lifter_set_level(side, lvl0)

        # Tomar media caja Half-B del conveyor
        ok_pick = do_pick("half_b")
        if not ok_pick:
            tp_log("Abortando lado " + side +
                   " por fallo de vacío al arrancar en Half-B.")
            finish_side(side)
            return
            
        # Colocar Half-B en este slot
        ok2 = do_place(side, layer, slot, "half_b")
        if not ok2:
            tp_log("run_side_once: mantenimiento solicitado al colocar Half-B inicial.")
            finish_side(side)
            return

        # Registrar este destino Half-B como lleno
        _halfB_filled.add((side, layer, slot))


        # Calcular el siguiente slot donde continuar
        next_layer = layer
        next_slot  = slot + 1
        if next_slot >= n_slots_in_layer:
            # Si nos pasamos del último slot de la capa, avanzamos de capa
            next_layer = next_layer + 1
            next_slot  = 0

        # Si todavía hay capas por paletizar, continuar con run_from
        if next_layer < len(layers):
            run_from(side, next_layer, next_slot)

        # Al final, terminar el lado
        finish_side(side)
        return

    # ----------------- CASO NORMAL: slot inicial NO es destino Half-B -----------------
    # Se asume que arrancamos en un slot que es:
    #   - FULL normal, o
    #   - Origen Half-A.
    lvl0 = lifter_level_for_layer(layer)
    lifter_set_level(side, lvl0)

    # Tomar caja completa (FULL) para el primer slot
    ok_pick = do_pick("full")
    if not ok_pick:
        tp_log("Abortando lado " + side +
               " por fallo de vacío en el slot inicial L" +
               str(layer+1) + " S" + str(slot+1))
        finish_side(side)
        return

    # Revisar si este slot inicial es Half-A y su destino
    is_half, dl, ds = find_half(side, layer, slot)
    # Ejecutar lógica FULL o Half-A/Half-B
    ok_place = do_half(side, layer, slot, is_half, dl, ds)
    if not ok_place:
        tp_log("run_side_once: se salio por mantenimiento en slot inicial.")
        finish_side(side)
        return

    # Correr el resto del lado desde el siguiente slot
    run_from(side, layer, slot + 1)

    # Finalizar lado
    finish_side(side)


# =====================================================================
# MAIN
# =====================================================================

def main():
    """
    Flujo principal del programa.

    Flujo:
      1) Inicializar TCP, tool y lifter, y sincronizar frames segun nivel actual.
      2) Preguntar accion inicial:
           1 = Home seguro
           2 = Mantenimiento
           3 = Paletizado
      3) Si se elige Home seguro:
           - Ejecutar safe_home()
           - Preguntar:
                1 = Mantenimiento
                2 = Paletizado
      4) Si se elige Mantenimiento (directo o despues de Home):
           - Ejecutar go_to_maintenance_mode() y terminar.
      5) Si se elige Paletizado:
           - Entrar directo al flujo de paletizado
             (preguntar modo, lado, cama, slot, etc.)
           - SIN llamar a safe_home automaticamente.
    """
    global _lifter_level

    # ------------- Configuracion basica de herramienta -------------
    set_tcp("custom_gripper")
    set_tool_shape("gripper_shape")

    # ------------- Estado inicial hacia el PLC ---------------------
    plc_set_maintenance_state(False)
    plc_set_pick_vac_ok(False)
    plc_set_vacuum_loss(False)
    plc_set_pick_mode("idle")

    # ------------- Inicializacion / sincronizacion del lifter ------
    lifter_safe_init()

    if or_lift.isconn():
        pos = or_lift.get_pos()
        level_actual = lifter_level_from_pos(pos)
        tp_log("Lift100 detectado en pos=" + str(pos) +
               " mm, nivel logico estimado=" + str(level_actual))
    else:
        tp_log("Lift100 no conectado al inicio: se asume nivel 0.")
        level_actual = 0

    _lifter_level = level_actual
    apply_level_to_frames(level_actual)

    # ------------- Menu inicial: Home / Mantenimiento / Paletizado ---
    action = ask_initial_action()

    if action == 1:
        # Home seguro primero (SOLO si el usuario lo pide)
        safe_home()

        # Despues de home: elegir entre Mantenimiento o Paletizado
        next_action = ask_home_followup_action()
        if next_action == 1:
            # Mantenimiento
            go_to_maintenance_mode()
            return
        # Si next_action == 2 -> Paletizado; continua mas abajo SIN safe_home

    elif action == 2:
        # Mantenimiento directo
        go_to_maintenance_mode()
        return

    else:
        # action == 3: Paletizado directo
        # NO se llama safe_home aqui
        tp_log("Accion inicial: paletizado directo (sin home seguro).")

    # -----------------------------------------------------------------
    # A partir de aqui: flujo normal de paletizado (igual que antes)
    # -----------------------------------------------------------------

    mode = ask_mode()        # 'single' o 'both'

    side  = ask_side()       # 'L' o 'R'
    layer = ask_layer(side)  # 0-based
    slot  = ask_slot(side, layer)  # 0-based

    tp_log("Inicio en " + side +
           " L" + str(layer+1) +
           " S" + str(slot+1))

    other_side = "R" if side == "L" else "L"

    if mode == "single":
        while True:
            tp_log("Iniciando ciclo de tarima en lado " + side +
                   " desde L" + str(layer+1) +
                   " S" + str(slot+1))

            run_side_once(side, layer, slot)

            # Si durante el ciclo se entró a mantenimiento, salir del bucle
            if _in_maintenance:
                tp_log("Modo mantenimiento activo. Saliendo del bucle de tarimas (single).")
                return

            tp_log("Esperando nueva tarima en lado " + side +
                   " para iniciar una nueva paletizacion...")
            tp_popup("Coloque una NUEVA tarima en el lado " + side +
                     " para continuar.", DR_PM_MESSAGE)

            wait_pallet_present(side)

            layer = 0
            slot  = 0
            tp_log("Nueva tarima detectada en lado " + side +
                   ". Reiniciando desde L1 S1.")

    else:
        run_side_once(side, layer, slot)

        # Si se activó mantenimiento en el primer lado, no seguimos
        if _in_maintenance:
            tp_log("Modo mantenimiento activo tras primer lado. No se paletiza el otro lado.")
            return

        if not is_pallet_present(other_side):
            tp_log("No hay tarima en el lado " + other_side + ". Esperando a que la coloquen...")
            tp_popup("Coloque una tarima en el lado " + other_side + " para continuar.", DR_PM_MESSAGE)
            wait_pallet_present(other_side)

        tp_log("Iniciando lado " + other_side + " desde L1 S1.")
        run_from(other_side, 0, 0)


        # Si durante el segundo lado se entró en mantenimiento, no hacemos finish_side ni home
        if _in_maintenance:
            tp_log("Modo mantenimiento activo durante el segundo lado. Saliendo sin finish_side.")
            return

        finish_side(other_side)

    # Solo regresar a HOME si NO estamos en modo mantenimiento
    if not _in_maintenance:
        movej(home, v=vj_fast, a=aj_slow)
    else:
        tp_log("Modo mantenimiento activo. No se regresa a home.")


# Llamada al MAIN para iniciar el flujo cuando se ejecuta el script.
main()
