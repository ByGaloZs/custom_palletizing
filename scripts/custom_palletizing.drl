# ==============================    =======================================
# Palletizing Script (Doosan DRL)
# Autor: Mario Padilla
# =====================================================================
# Este programa controla un sistema de paletizado con:
# - Un robot Doosan
# - Un lifter (Lift100) que sube/baja la base del robot
# - Un conveyor (transportador) donde llegan las cajas
# - Dos pallets: izquierdo (L) y derecho (R)
# - Un gripper de dos mitades (Half-A y Half-B)
#
# Funcionalidades principales:
# - Pick de cajas (6 o 3) desde el conveyor
# - Colocación de cajas en patrones de paletizado por layer ("camas") y slots
# - Manejo de media carga (Half-A / Half-B) con un plan definido
# - Compensación automática de frames según la altura del lifter
# - Uso de señales de PLC para pallets presentes, conveyor listo, y estado del robot
# - Interacción con el operador a través del Teach Pendant (tp_popup, tp_get_user_input, etc.)
# =====================================================================

# ---------------------- frames ----------------------
# ID de los frames enseñados en el controlador

# Frames de TRABAJO (los que usa todo el programa para pick/place)
# Estos son los frames que se utilizan dinámicamente para cálculos de movimiento.
conv_frame  = 101   # Frame del conveyor (pick) - TRABAJO
left_frame  = 102   # Frame del pallet izquierdo - TRABAJO
right_frame = 103   # Frame del pallet derecho - TRABAJO

# Frames ORIGINALES nivel 0 (enseñados manualmente con el lifter abajo,
# todo respecto al WORLD). Estos NUNCA se modifican desde código.
# Se usan como referencia base para recalcular los frames de trabajo cuando cambia el nivel del lifter.
conv_frame_orig  = 191   # conveyor original nivel 0
left_frame_orig  = 192   # pallet izquierdo original nivel 0
right_frame_orig = 193   # pallet derecho original nivel 0

# ---------------------- parámetros globales ---------
# Modo de orientación: FIX XYZ (RX, RY, RZ fijos, no ELR).
# Es decir, se trabajan las orientaciones directamente en ángulos RX, RY, RZ.
rot_mode = DR_FIX_XYZ

# Offsets en Z para APPROACH y RETRACT con respecto al PLACE
# Sirven para aproximarse y retirarse verticalmente del punto de contacto.
dz_app = 200.0     # Distancia en Z para aproximación (APP) antes de llegar al punto de place/pick
dz_ret = 200.0     # Distancia en Z para retract (RET) después de soltar/tomar la caja

# ---------------------- velocidades -----------------
# Velocidades y aceleraciones de joint (vj/aj) y lineales (vl/al)
# Se separa en "rápido" y "lento" para poder controlar zonas seguras y zonas de trabajo fino.
vj_fast = 110;   aj_fast = 90
vj_slow = 90;   aj_slow = 70
vj_mto =  10;   aj_mto =  5
vl_fast = 1000; al_fast = 500
vl_slow = 550;  al_slow = 300
vl_mto =  50;  al_mto =  25

# ---------------------- poses joint auxiliares ------
# Home general del robot (posición segura de referencia)
home = posj(-90.00, 0.00, 90.00, 0.00, 90.00, 90.00)

# Posiciones "up" sobre zonas clave (hubs de seguridad):
# Estas son posturas en joint encima de las zonas principales. Se usan como puntos intermedios seguros.
up_conv  = posj(-100.00, 17.56, 78.28, 0.00, 84.16, 81.00)   # Hub sobre conveyor
up_left  = posj(4.58, -8.86, 98.00, 0.00, 90.85, 94.58)     # Hub sobre pallet izquierdo
up_right = posj(-175.42, -8.86, 98.01, 0.00, 90.86, 94.58)  # Hub sobre pallet derecho

# Posición segura antes de bajar el lifter por completo y retirar tarima.
# Esta postura busca minimizar riesgo de colisión cuando se mueve el Lift100.
safe_pose = posj(0.00, 0.00, 0.00, 0.00, 0.00, 90.00)

MAINT_PASSWORD = "tes3211"   # Contraseña de mantenimiento
maint_safe_pose = posj(90.00, 50.00, 115.00, 0, -75.00, 90.00)

# Flag global: indica si se ha entrado en modo mantenimiento
_in_maintenance = False

# Flag global: indica si en el ÚLTIMO do_place hubo pérdida de vacío
# y el operador eligió CONTINUAR (no mantenimiento).
_last_place_lost_vacuum = False

# ---------------------- I/O gripper -----------------
# Definición de las salidas digitales que controlan el gripper
# Se asume un gripper de doble vía, donde cada vía puede controlar media caja.
do_a = 1  # DO para "mitad A" o una vía del gripper
do_b = 2  # DO para "mitad B" o la otra vía del gripper
do_a_blow = 3
do_b_blow = 4

# Entradas digitales de retro de vacío
# Estas indican si hay vacío suficiente (pieza agarrada) en cada mitad.
di_vac_ok_a = 1    # DI para "vacío OK mitad A"
di_vac_ok_b = 2    # DI para "vacío OK mitad B"

# ---------------------- SALIDAS PLC (Robot -> PLC) ----------------------

# Salida INT registers
ROBOT_STATE_REG = 0   
VAC_STATUS_REG = 1  
PICK_MODE_REG   = 2   

VAC_STATUS_IDLE = 0
VAC_STATUS_OK   = 1
VAC_STATUS_LOST = 2

# Valores de estado del robot (INT)
ROBOT_STATE_IDLE        = 0
ROBOT_STATE_NORMAL      = 1   # palletizing (automatic cycle)
ROBOT_STATE_STANDBY     = 2   # menus / selections / waiting for operator choice
ROBOT_STATE_MANUAL      = 3   # manual action (RETIRAR TARIMA)
ROBOT_STATE_MAINTENANCE = 4   # maintenance mode

# Salida BIT registers 
STACK_ACK_BIT   = 0   
MAINT_BIT = 2       

# Funciones de control del gripper (FULL / HALF A / HALF B / RELEASE)
# Estas funciones encapsulan la lógica de encender/apagar las DO y agregar pequeñas esperas.

def grip_full():
    """
    Activa ambas salidas -> agarra 6 cajas.
    """
    set_digital_output(do_a, ON)
    set_digital_output(do_b, ON)
    wait(0.2)  # Tiempo para que el gripper genere vacío / cierre

def grip_half_a():
    """
    Sólo activa 'A' -> agarra 3 cajas lado A.
    """
    set_digital_output(do_a, ON)
    set_digital_output(do_b, OFF)
    wait(0.2)

def grip_half_b():
    """
    Sólo activa 'B' -> agarra 3 cajas lado B.
    """
    set_digital_output(do_a, OFF)
    set_digital_output(do_b, ON)
    wait(0.2)

def rel_full():
    """
    Libera ambas mitades -> suelta 6 cajas.
    """
    set_digital_output(do_a, OFF)
    set_digital_output(do_b, OFF)
    wait(0.2)
    set_digital_output(do_a_blow, ON)
    set_digital_output(do_b_blow, ON)
    wait(0.5)
    set_digital_output(do_a_blow, OFF)
    set_digital_output(do_b_blow, OFF)

def rel_half_a():
    """
    Libera sólo la mitad A (Half-A).
    """
    set_digital_output(do_a, OFF)
    wait(0.15)
    set_digital_output(do_a_blow, ON)
    wait(0.5)
    set_digital_output(do_a_blow, OFF)

def rel_half_b():
    """
    Libera sólo la mitad B (Half-B).
    """
    set_digital_output(do_b, OFF)
    wait(0.15)
    set_digital_output(do_b_blow, ON)
    wait(0.5)
    set_digital_output(do_b_blow, OFF)

# =====================================================================
# Retroalimentación de vacío
# =====================================================================
# Mientras USE_VAC_FEEDBACK = False, el programa ignora estas DI de vacío
# y asume que siempre se agarra correctamente la pieza.
USE_VAC_FEEDBACK = True

def _vac_ok_a():
    """
    Devuelve True si la mitad A del gripper tiene vacío OK.

    Lee directamente de una ENTRADA DIGITAL del robot:
        di_vac_ok_a -> get_digital_input(di_vac_ok_a)
    """
    return get_digital_input(di_vac_ok_a) == ON

def _vac_ok_b():
    """
    Devuelve True si la mitad B del gripper tiene vacío OK.

    Lee directamente de una ENTRADA DIGITAL del robot:
        di_vac_ok_b -> get_digital_input(di_vac_ok_b)
    """
    return get_digital_input(di_vac_ok_b) == ON

def wait_vacuum_ok(mode, timeout=2):
    """
    Espera a que el gripper confirme vacío OK según el modo:
        - "full"   -> A y B deben tener vacío
        - "half_a" -> sólo A debe tener vacío
        - "half_b" -> sólo B debe tener vacío

    Si USE_VAC_FEEDBACK == False, siempre devuelve True (sin sensores).

    timeout en segundos: tiempo máximo para esperar vacío antes de considerar fallo.
    """
    if not USE_VAC_FEEDBACK:
        # NO se verifica vacío, se asume OK
        return True

    # Determina qué mitades deben tener vacío según el modo
    need_a = (mode == "full" or mode == "half_a")
    need_b = (mode == "full" or mode == "half_b")

    t = 0.0
    dt = 0.5  # Periodo de muestreo de las entradas

    # Bucle hasta que haya vacío o se acabe el tiempo de espera
    while t < timeout:
        ok_a = (not need_a) or _vac_ok_a()
        ok_b = (not need_b) or _vac_ok_b()

        if ok_a and ok_b:
            # Ambas mitades requeridas tienen vacío correcto
            return True

        wait(dt)
        t = t + dt

    # Si llega aquí, no hubo vacío suficiente dentro del timeout
    tp_log("ADVERTENCIA: fallo de vacío en modo '" + mode + "'.")
    return False

def rel_by_mode(mode):
    """
    Libera el gripper según el modo de pick usado.
    """
    if mode == "full":
        rel_full()
    elif mode == "half_a":
        rel_half_a()
    elif mode == "half_b":
        rel_half_b()

def has_vacuum_for_mode(mode):
    """Comprueba de forma instantánea si el vacío sigue siendo válido
    para el modo indicado (full / half_a / half_b).

    Si USE_VAC_FEEDBACK == False, devuelve siempre True.
    """
    if not USE_VAC_FEEDBACK:
        return True

    need_a = (mode == "full") or (mode == "half_a")
    need_b = (mode == "full") or (mode == "half_b")

    ok_a = (not need_a) or _vac_ok_a()
    ok_b = (not need_b) or _vac_ok_b()

    return ok_a and ok_b

def calc_tool_weight_by_vacuum_feedback(rtype):
    """Determina qué peso debe setearse usando la retroalimentación de vacío (A/B).

    Reglas:
        - rtype == "full":
            * A=1 y B=1  -> full_weight
            * solo A o solo B -> half_weight
            * A=0 y B=0  -> gripper_weight
        - rtype == "half_a":
            * A=1 -> half_weight
            * A=0 -> gripper_weight
        - rtype == "half_b":
            * B=1 -> half_weight
            * B=0 -> gripper_weight
    """
    if not USE_VAC_FEEDBACK:
        # Conservador: sobreestimar payload si no hay feedback
        if rtype == "full":
            return "full_weight"
        if rtype == "half_a" or rtype == "half_b":
            return "half_weight"
        return "gripper_weight"

    a_ok = _vac_ok_a()
    b_ok = _vac_ok_b()

    if rtype == "full":
        if a_ok and b_ok:
            return "full_weight"
        elif a_ok or b_ok:
            return "half_weight"
        else:
            return "gripper_weight"

    if rtype == "half_a":
        return "half_weight" if a_ok else "gripper_weight"

    if rtype == "half_b":
        return "half_weight" if b_ok else "gripper_weight"

    return "gripper_weight"

def apply_tool_weight_after_place(rtype, lost_vacuum):
    """Aplica set_tool() justo DESPUÉS de soltar en el place y ANTES del retract.

    Caso A) NO hubo pérdida de vacío antes del place (lost_vacuum == False):
        - Se decide por retro (A/B) DESPUÉS del release para cubrir:
            * Pick FULL -> place half_* (queda media carga)
            * Pick half_* -> place half_* (queda vacío)
            * Cualquier variación si el vacío cambió durante approach/bajada

    Caso B) Sí hubo pérdida de vacío antes del place (lost_vacuum == True):
        - Se determina con retro (A/B) qué quedaba realmente y se setea:
            full_weight / half_weight / gripper_weight
    """
    if lost_vacuum:
        tool_name = calc_tool_weight_by_vacuum_feedback(rtype)
        set_tool(tool_name, 0.0, 0.2)
        return

    # Sin pérdida pre-place: decide el peso por retro A/B tras soltar.
    # Usamos rtype="full" para evaluar el estado global A/B (full/half/empty).
    tool_name = calc_tool_weight_by_vacuum_feedback("full")
    set_tool(tool_name, 0.0, 0.2)

# =====================================================================
# Sensores de seguridad
# =====================================================================
# ---------------------- I/O pallets desde PLC ----------------------
# Estos bits vienen del PLC y representan sensores físicos de presencia de tarima
# o estados de "conveyor listo".

CONV_READY_BIT   = 0   # Bit del PLC que indica "conveyor listo"
PALLET_LEFT_BIT  = 1   # Limit switch pallet izquierdo presente
PALLET_RIGHT_BIT = 2   # Limit switch pallet derecho presente

def _pallet_bit_index(side):
    """
    Devuelve el índice de bit correspondiente al lado:
        side == "L" -> PALLET_LEFT_BIT
        side == "R" -> PALLET_RIGHT_BIT
    """
    return PALLET_LEFT_BIT if side == "L" else PALLET_RIGHT_BIT

def is_pallet_present(side):
    """
    Devuelve True si el pallet está presente en el lado indicado ('L' o 'R').
    Lee el bit correspondiente del registro del PLC.
    """
    bit_idx = _pallet_bit_index(side)
    return get_input_register_bit(bit_idx) == ON

def wait_pallet_present(side):
    """
    Espera a que haya pallet presente en el lado indicado ('L' o 'R').

    Se asume:
        - bit == ON  -> hay tarima presente
        - bit == OFF -> NO hay tarima
    """
    bit_idx = _pallet_bit_index(side)

    tp_log("Esperando tarima en lado " + side + "...")
    while get_input_register_bit(bit_idx) == OFF:
        wait(0.5)  # Revisa el bit cada 0.5 segundos

    tp_log("Tarima detectada en lado " + side + ".")

def wait_remove_finished_pallet(side):
    """
    Espera a que retiren la tarima terminada del lado indicado ('L' o 'R').

    Se asume:
        - bit == ON  -> hay tarima presente
        - bit == OFF -> tarima retirada
    """
    bit_idx = _pallet_bit_index(side)

    tp_log("Esperando a que retiren la tarima del lado " + side + "...")
    while get_input_register_bit(bit_idx) == ON:
        wait(0.5)

    tp_log("Tarima retirada en lado " + side + ".")

def wait_no_pallets_present_both_sides():
    """
    Bloquea el movimiento del robot hasta que NO haya tarimas presentes
    en ninguno de los dos lados.

    Se usa principalmente al reiniciar el programa cuando el robot estaba
    en MAINTENANCE: antes de permitir Home seguro, se verifica que ambas
    estaciones estén libres.

    Se asume:
        - bit == ON  -> hay tarima presente
        - bit == OFF -> NO hay tarima
    """
    while is_pallet_present("L") or is_pallet_present("R"):
        msg = "RETIRE TARIMAS: No se permite movimiento hasta que ambos lados estén libres."
        tp_popup(msg, DR_PM_WARNING)
        tp_log("Bloqueo por tarimas presentes: L=" + str(is_pallet_present("L")) +
                ", R=" + str(is_pallet_present("R")))
        wait(0.5)

def wait_conveyor_ready():
    """
    Espera a que el PLC indique que la caja está lista para pick.
    El bit CONV_READY_BIT debe permanecer en ON para continuar.
    """
    tp_log("Esperando conveyor listo para pick...")
    while get_input_register_bit(CONV_READY_BIT) == OFF:
        wait(0.2)
    tp_log("Conveyor listo.")

# =====================================================================
# LIFTER100 (or_lift) - Lógica multinivel + seguridad + compensación
# =====================================================================
# Esta sección maneja el Lift100:
# - Convierte capas ("camas") a niveles de lifter (0,1,2)
# - Compensa los frames de trabajo según la altura
# - Verifica estados de error / posición del lifter

# Tramos mecánicos del lifter
DZ_LIFTER_1 = 400.0         # primer tramo (mm)
DZ_LIFTER_2 = 270.0         # segundo tramo (mm) (total ≈ 670 mm)

# Mapa lógico por cama (0-based):
#   0..3 -> nivel 0 (0 mm, lifter abajo)
#   4..6 -> nivel 1 (+400 mm)
#   7..8 -> nivel 2 (+400+270 mm)
def lifter_level_for_layer(layer):
    """
    Devuelve el nivel lógico del lifter según la cama (layer 0-based):
        0-3 -> 0
        4-6 -> 1
        7-8 -> 2
    """
    if layer <= 3:
        return 0
    elif layer <= 6:
        return 1
    else:
        return 2

def _level_offset(level):
    """
    Devuelve el offset total en Z según el nivel del lifter.
    Este offset se usa para compensar frames (bajan en Z cuando el lifter sube).
    """
    if level == 0:
        return 0.0
    elif level == 1:
        return DZ_LIFTER_1
    elif level == 2:
        return DZ_LIFTER_1 + DZ_LIFTER_2
    return 0.0

def lifter_target_pos_for_level(level):
    """
    Posición objetivo en mm del Lift100 para un nivel lógico:
        level 0 ->   0 mm
        level 1 -> 400 mm
        level 2 -> 670 mm
    """
    if level == 0:
        return 0.0
    elif level == 1:
        return 400.0
    elif level == 2:
        return 670.0
    return 0.0

def lifter_level_from_pos(pos):
    """
    Estima el nivel lógico (0,1,2) según la posición real [mm] del Lift100.
    Ajusta los umbrales según los valores reales de tu instalación.
    """
    # Ejemplo: 0..200 => nivel 0, 200..540 => nivel 1, >540 => nivel 2
    if pos < 200.0:
        return 0
    elif pos < 540.0:
        return 1
    else:
        return 2

# Estado actual del lifter (nivel lógico 0/1/2)
_lifter_level = 0

# ---------------------- helpers de seguridad Lift100 -----------------
def lifter_gate_or_stop():
    # 1) Debe estar conectado
    if not or_lift.isconn():
        tp_popup("ERROR LIFTER: No conectado.\nConecte el Lift100 y reinicie.", DR_PM_ALARM)
        return False

    # 2) Debe estar inicializado (referenciado)
    if not or_lift.isInit():
        # Si quieres auto-inicializar, hazlo SOLO desde safe_pose (ver nota abajo)
        tp_popup("ERROR LIFTER: No inicializado.\nInicialice Lift100 y reinicie.", DR_PM_ALARM)
        return False

    # 3) No debe tener error activo
    err = lifter_check_error()
    if err != 0:
        tp_popup("ERROR LIFTER: Código " + str(err) + "\nResetee el lifter y reinicie.", DR_PM_ALARM)
        return False

    # 4) Debe poder leerse posición (detecta fallas de comms)
    try:
        or_lift.get_pos()
    except:
        tp_popup("ERROR LIFTER: No se puede leer posición.\nRevise comunicación y reinicie.", DR_PM_ALARM)
        return False

    return True

def lifter_init_is_safe_by_progress():
    """:
      - True  => NO hay progreso guardado (Layer/Slot en 0) y se puede hacer init normal.
      - False => SÍ hay progreso guardado en cualquier lado y el init debe hacerse con
                la secuencia segura: safe_pose -> init -> re-subir nivel (se maneja en main()).
    """
    try:
        l_layer = (System_Layer_L if (System_Layer_L is not None) else 0)
        l_slot  = (System_Slot_L  if (System_Slot_L  is not None) else 0)
        r_layer = (System_Layer_R if (System_Layer_R is not None) else 0)
        r_slot  = (System_Slot_R  if (System_Slot_R  is not None) else 0)

        progress_exists = (l_layer > 0) or (l_slot > 0) or (r_layer > 0) or (r_slot > 0)

        # True = "safe en init normal" (sin progreso). False = "requiere secuencia safe_pose".
        return (not progress_exists)
    except:
        # Si algo está raro, por seguridad dejamos que el flujo normal continúe
        return True


def lifter_wait_ready(timeout=15.0):
    """
    Espera a que el Lift100 termine cualquier movimiento (isBusy == False).
    Devuelve True si quedó listo, False si hizo timeout.
    """
    t = 0.0
    while or_lift.isBusy():
        wait(0.1)
        t = t + 0.1
        if t >= timeout:
            tp_log("TIMEOUT esperando a que el Lift100 termine el movimiento.")
            return False
    return True

def lifter_check_error():
    """
    Consulta or_lift.get_error() y registra el código si no es 0.
    NO detiene el programa, sólo deja traza.
    """
    err = or_lift.get_error()
    if err != 0:
        tp_log("ADVERTENCIA: Lift100 error code = " + str(err))
    return err

def lifter_check_position(level, tol=5.0):
    """
    Verifica que el Lift100 esté dentro de una tolerancia ±tol [mm]
    alrededor de la posición esperada para 'level'.
    """
    if not or_lift.isconn():
        tp_log("Lift100 no conectado; no se puede verificar posición.")
        return False

    pos = or_lift.get_pos()
    tgt = lifter_target_pos_for_level(level)
    if abs(pos - tgt) <= tol:
        return True

    tp_log("ADVERTENCIA: Lift100 desincronizado. level=" + str(level) +
            " pos=" + str(pos) + " esperado=" + str(tgt))
    return False

def lifter_safe_init():
    """
    Verifica conexión e inicialización del Lift100.

    REGLA (según requisito actual):
    - Esta función NO inicializa el lifter.
    - La inicialización segura (safe_pose -> init -> re-subir nivel -> home)
      se maneja EXCLUSIVAMENTE en main().

    Comportamiento:
    - Si no está conectado: log y return
    - Si ya está init: log y return
    - Si no está init: log y return (main() lo resolverá)
    """
    if not or_lift.isconn():
        tp_log("ERROR: Lift100 no conectado (or_lift.isconn() == False).")
        return

    if or_lift.isInit():
        tp_log("Lift100 ya está inicializado.")
        return

    # Caso: lifter NO inicializado
    tp_log(
        "Lift100 NO está inicializado. "
        "La inicialización segura se ejecuta en main() "
        "(safe_pose -> init -> re-subir nivel -> home)."
    )
    return


# ---------------------- frames + nivel lifter ------------------------

def _lifter_do_set_level(level):
    """
    Ajusta el Lift100 al nivel indicado usando or_lift.move().
    Devuelve True si el nivel quedó OK, False si falló.
    """
    if not or_lift.isconn():
        tp_log("No se puede mover Lift100: sin conexión.")
        return False

    if not or_lift.isInit():
        tp_log("No se puede mover Lift100: no está inicializado (init se hace en main).")
        return False

    if not (level == 0 or level == 1 or level == 2):
        tp_log("Nivel Lift100 inválido: " + str(level) + ". No se mueve Lift100.")
        return False

    tgt = lifter_target_pos_for_level(level)

    cur = or_lift.get_pos()
    if abs(cur - tgt) < 2.0 and (not or_lift.isBusy()):
        tp_log("Lift100 ya en nivel " + str(level) + " (pos=" + str(cur) + " mm).")
        return True

    tp_log("Moviendo Lift100 a nivel " + str(level) + " (" + str(tgt) + " mm).")
    or_lift.move(tgt, 30.0)

    if not lifter_wait_ready():
        tp_log("ERROR: Lift100 no terminó movimiento (timeout).")
        return False

    err = lifter_check_error()
    if not (err == 0):
        tp_log("ERROR: Lift100 reporta error tras move().")
        return False

    if not lifter_check_position(level):
        tp_log("ERROR: Lift100 no llegó a la posición objetivo (fuera de tolerancia).")
        return False

    return True

def apply_level_to_frames(level):
    """
    A partir de los frames ORIGINALES nivel 0 (191, 192, 193),
    escribe los frames de trabajo (101, 102, 103) compensando en Z
    según el nivel lógico del lifter (0,1,2).

    Regla:
        new_z = z_original - offset(level)
    donde offset(level) usa _level_offset(level).
    """
    dz = _level_offset(level)

    # Lista de mapeos (frame_original -> frame_trabajo)
    pairs = [
        (conv_frame_orig,  conv_frame),
        (left_frame_orig,  left_frame),
        (right_frame_orig, right_frame)
    ]

    for f_orig, f_work in pairs:
        # Obtener pose del frame original (nivel 0)
        pose_orig, ref_orig = get_user_cart_coord(f_orig)

        # Se mantiene X, Y, RX, RY, RZ; sólo se compensa Z
        new_pose = posx(
            pose_orig[0],              # X
            pose_orig[1],              # Y
            pose_orig[2] - dz,         # Z compensada hacia abajo
            pose_orig[3],              # RX
            pose_orig[4],              # RY
            pose_orig[5],              # RZ
            rot_mode
        )

        # Escribimos en el frame de TRABAJO correspondiente
        overwrite_user_cart_coord(f_work, new_pose, ref_orig, DR_TEMPORARY)

def lifter_set_level(side, level):
    """
    Mueve el lifter al nivel indicado (0,1,2) y ajusta SIEMPRE los frames
    de TRABAJO (101,102,103) a partir de los frames ORIGINALES nivel 0
    (191,192,193), sin modificar jamás los originales.

    Pasos:
        - Si el nivel ya es _lifter_level, no hace nada.
        - Mueve físicamente el lifter al nivel deseado.
        - Aplica la compensación de frames con apply_level_to_frames(level).
        - Actualiza _lifter_level.
    """
    global _lifter_level
    # Protección: si ya estamos en ese nivel lógico, no hacer nada
    if level == _lifter_level:
        tp_log("Lift100 ya en nivel lógico " + str(level) + ".")
        return

    tp_log("Cambiando lifter a nivel " + str(level) +
            " (offset Z = " + str(_level_offset(level)) + " mm).")

    # Mover físicamente el lifter
    ok = _lifter_do_set_level(level)
    if not ok:
        tp_popup("ERROR LIFTER: Fallo moviendo a nivel " + str(level) + ".\nPrograma detenido.", DR_PM_ALARM)
        stop(DR_QSTOP)
        return


    # Ajustar frames de trabajo en función de los frames originales
    apply_level_to_frames(level)

    # Actualizar estado lógico
    _lifter_level = level

def lifter_restore_frames():
    """
    Restaura el sistema a nivel 0:
        - Mueve físicamente el lifter a nivel 0.
        - Aplica apply_level_to_frames(0) para que 101/102/103 coincidan
        con los frames originales nivel 0.
        - Actualiza _lifter_level = 0.
    """
    global _lifter_level

    # Mover lifter físicamente a nivel 0
    ok = _lifter_do_set_level(0)
    if not ok:
        tp_popup("ERROR LIFTER: No se pudo restaurar a nivel 0.\nPrograma detenido.", DR_PM_ALARM)
        stop(DR_QSTOP)
        return


    # Aplicar compensación de nivel 0 (sin desplazamiento en Z)
    apply_level_to_frames(0)

    # Estado lógico
    _lifter_level = 0

# =====================================================================
# Datos PLACE (por capas y lados)
# =====================================================================
# Estructura:
#   left_layers / right_layers: lista de layers (0..N-1).
#   Cada layer: lista de 9 slots (0..8).
#   Cada slot: (X, Y, Z, RX, RY, RZ) en el frame del pallet.
#
# Estas tablas definen el patrón exacto de paletizado.

left_layers = [
    # LAYER 1 (Left)
    [
        (105.0, 432.0, 235.0, -180.0, 0.0, 90.0),
        (588.0, 115.0, 235.0, -180.0, 0.0, -180.0),
        (588.0, 290.0, 235.0, -180.0, 0.0, -180.0),
        (588.0, 465.0, 235.0, -180.0, 0.0, -180.0),
        (588.0, 640.0, 235.0, -180.0, 0.0, -180.0),
        (588.0, 815.0, 235.0, -180.0, 0.0, -180.0),
        (588.0, 990.0, 235.0, -180.0, 0.0, -180.0),
        (588.0, 1165.0, 235.0, -180.0, 0.0, -180.0),
        (105.0, 1243.0, 235.0, -180.0, 0.0, 90.0)
    ],
    # LAYER 2 (Left)
    [
        (900.0, 853.0, 365.0, -180.0, 0.0,  90.0),
        (900.0, 437.0, 365.0, -180.0, 0.0,  90.0),
        (425.0, 115.0, 365.0, -180.0, 0.0, -180.0),
        (425.0, 290.0, 365.0, -180.0, 0.0, -180.0),
        (425.0, 465.0, 365.0, -180.0, 0.0, -180.0),
        (425.0, 640.0, 365.0, -180.0, 0.0, -180.0),
        (425.0, 815.0, 365.0, -180.0, 0.0, -180.0),
        (425.0, 990.0, 365.0, -180.0, 0.0, -180.0),
        (425.0, 1165.0, 365.0, -180.0, 0.0, -180.0)
    ],
    # LAYER 3 (Left)
    [
        (105.0, 432.0, 495.0, -180.0, 0.0,  90.0),
        (588.0, 115.0, 495.0, -180.0, 0.0, -180.0),
        (588.0, 290.0, 495.0, -180.0, 0.0, -180.0),
        (588.0, 465.0, 495.0, -180.0, 0.0, -180.0),
        (588.0, 640.0, 495.0, -180.0, 0.0, -180.0),
        (588.0, 815.0, 495.0, -180.0, 0.0, -180.0),
        (588.0, 990.0, 495.0, -180.0, 0.0, -180.0),
        (588.0, 1165.0, 495.0, -180.0, 0.0, -180.0),
        (105.0, 1243.0, 495.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 4 (Left)
    [
        (900.0, 853.0, 625.0, -180.0, 0.0,  90.0),
        (900.0, 437.0, 625.0, -180.0, 0.0,  90.0),
        (425.0, 115.0, 625.0, -180.0, 0.0, -180.0),
        (425.0, 290.0, 625.0, -180.0, 0.0, -180.0),
        (425.0, 465.0, 625.0, -180.0, 0.0, -180.0),
        (425.0, 640.0, 625.0, -180.0, 0.0, -180.0),
        (425.0, 815.0, 625.0, -180.0, 0.0, -180.0),
        (425.0, 990.0, 625.0, -180.0, 0.0, -180.0),
        (425.0, 1165.0, 625.0, -180.0, 0.0, -180.0)
    ],
    # LAYER 5 (Left)
    [
        (105.0, 432.0, 735.0, -180.0, 0.0,  90.0),
        (588.0, 115.0, 735.0, -180.0, 0.0, -180.0),
        (588.0, 290.0, 735.0, -180.0, 0.0, -180.0),
        (588.0, 465.0, 735.0, -180.0, 0.0, -180.0),
        (588.0, 640.0, 735.0, -180.0, 0.0, -180.0),
        (588.0, 815.0, 735.0, -180.0, 0.0, -180.0),
        (588.0, 990.0, 735.0, -180.0, 0.0, -180.0),
        (588.0, 1165.0, 735.0, -180.0, 0.0, -180.0),
        (105.0, 1243.0, 735.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 6 (Left)
    [
        (900.0, 853.0, 865.0, -180.0, 0.0,  90.0),
        (900.0, 437.0, 865.0, -180.0, 0.0,  90.0),
        (425.0, 115.0, 865.0, -180.0, 0.0, -180.0),
        (425.0, 290.0, 865.0, -180.0, 0.0, -180.0),
        (425.0, 465.0, 865.0, -180.0, 0.0, -180.0),
        (425.0, 640.0, 865.0, -180.0, 0.0, -180.0),
        (425.0, 815.0, 865.0, -180.0, 0.0, -180.0),
        (425.0, 990.0, 865.0, -180.0, 0.0, -180.0),
        (425.0, 1165.0, 865.0, -180.0, 0.0, -180.0)
    ],
    # LAYER 7 (Left)
    [
        (105.0, 432.0, 995.0, -180.0, 0.0,  90.0),
        (588.0, 115.0, 995.0, -180.0, 0.0, -180.0),
        (588.0, 290.0, 995.0, -180.0, 0.0, -180.0),
        (588.0, 465.0, 995.0, -180.0, 0.0, -180.0),
        (588.0, 640.0, 995.0, -180.0, 0.0, -180.0),
        (588.0, 815.0, 995.0, -180.0, 0.0, -180.0),
        (588.0, 990.0, 995.0, -180.0, 0.0, -180.0),
        (588.0, 1165.0, 995.0, -180.0, 0.0, -180.0),
        (105.0, 1243.0, 995.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 8 (Left)
    [
        (900.0, 853.0, 1115.0, -180.0, 0.0,  90.0),
        (900.0, 437.0, 1115.0, -180.0, 0.0,  90.0),
        (425.0, 115.0, 1115.0, -180.0, 0.0, -180.0),
        (425.0, 290.0, 1115.0, -180.0, 0.0, -180.0),
        (425.0, 465.0, 1115.0, -180.0, 0.0, -180.0),
        (425.0, 640.0, 1115.0, -180.0, 0.0, -180.0),
        (425.0, 815.0, 1115.0, -180.0, 0.0, -180.0),
        (425.0, 990.0, 1115.0, -180.0, 0.0, -180.0),
        (425.0, 1165.0, 1115.0, -180.0, 0.0, -180.0)
    ],
    # LAYER 9 (Left)
    [
        (105.0, 432.0, 1245.0, -180.0, 0.0,  90.0),
        (588.0, 115.0, 1245.0, -180.0, 0.0, -180.0),
        (588.0, 290.0, 1245.0, -180.0, 0.0, -180.0),
        (588.0, 465.0, 1245.0, -180.0, 0.0, -180.0),
        (588.0, 640.0, 1245.0, -180.0, 0.0, -180.0),
        (588.0, 815.0, 1245.0, -180.0, 0.0, -180.0),
        (588.0, 990.0, 1245.0, -180.0, 0.0, -180.0),
        (588.0, 1165.0, 1245.0, -180.0, 0.0, -180.0),
        (105.0, 1243.0, 1245.0, -180.0, 0.0,  -90.0)
    ]
]

right_layers = [
    # LAYER 1 (Right)
    [
        (915.0, 432.0, 235.0, -180.0, 0.0, -90.0),
        (432.0, 115.0, 235.0, -180.0, 0.0,   0.0),
        (432.0, 290.0, 235.0, -180.0, 0.0,   0.0),
        (432.0, 465.0, 235.0, -180.0, 0.0,   0.0),
        (432.0, 640.0, 235.0, -180.0, 0.0,   0.0),
        (432.0, 815.0, 235.0, -180.0, 0.0,   0.0),
        (432.0, 990.0, 235.0, -180.0, 0.0,   0.0),
        (432.0, 1165.0, 235.0, -180.0, 0.0,   0.0),
        (915.0, 1243.0, 235.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 2 (Right)
    [
        (140.0, 853.0, 365.0, -180.0, 0.0, -90.0),
        (140.0, 437.0, 365.0, -180.0, 0.0, -90.0),
        (608.0, 115.0, 365.0, -180.0, 0.0,   0.0),
        (608.0, 290.0, 365.0, -180.0, 0.0,   0.0),
        (608.0, 465.0, 365.0, -180.0, 0.0,   0.0),
        (608.0, 640.0, 365.0, -180.0, 0.0,   0.0),
        (608.0, 815.0, 365.0, -180.0, 0.0,   0.0),
        (608.0, 990.0, 365.0, -180.0, 0.0,   0.0),
        (608.0, 1165.0, 365.0, -180.0, 0.0,   0.0)
    ],
    # LAYER 3 (Right)
    [
        (915.0, 432.0, 495.0, -180.0, 0.0, -90.0),
        (432.0, 115.0, 495.0, -180.0, 0.0,   0.0),
        (432.0, 290.0, 495.0, -180.0, 0.0,   0.0),
        (432.0, 465.0, 495.0, -180.0, 0.0,   0.0),
        (432.0, 640.0, 495.0, -180.0, 0.0,   0.0),
        (432.0, 815.0, 495.0, -180.0, 0.0,   0.0),
        (432.0, 990.0, 495.0, -180.0, 0.0,   0.0),
        (432.0, 1165.0, 495.0, -180.0, 0.0,   0.0),
        (915.0, 1243.0, 495.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 4 (Right)
    [
        (140.0, 853.0, 625.0, -180.0, 0.0, -90.0),
        (140.0, 437.0, 625.0, -180.0, 0.0, -90.0),
        (608.0, 115.0, 625.0, -180.0, 0.0,   0.0),
        (608.0, 290.0, 625.0, -180.0, 0.0,   0.0),
        (608.0, 465.0, 625.0, -180.0, 0.0,   0.0),
        (608.0, 640.0, 625.0, -180.0, 0.0,   0.0),
        (608.0, 815.0, 625.0, -180.0, 0.0,   0.0),
        (608.0, 990.0, 625.0, -180.0, 0.0,   0.0),
        (608.0, 1165.0, 625.0, -180.0, 0.0,   0.0)
    ],
    # LAYER 5 (Right)
    [
        (915.0, 432.0, 735.0, -180.0, 0.0, -90.0),
        (432.0, 115.0, 735.0, -180.0, 0.0, 0.0),
        (432.0, 290.0, 735.0, -180.0, 0.0, 0.0),
        (432.0, 465.0, 735.0, -180.0, 0.0, 0.0),
        (432.0, 640.0, 735.0, -180.0, 0.0, 0.0),
        (432.0, 815.0, 735.0, -180.0, 0.0, 0.0),
        (432.0, 990.0, 735.0, -180.0, 0.0, 0.0),
        (432.0, 1165.0, 735.0, -180.0, 0.0, 0.0),
        (915.0, 1243.0, 735.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 6 (Right)
    [
        (140.0, 853.0, 865.0, -180.0, 0.0, -90.0),
        (140.0, 437.0, 865.0, -180.0, 0.0, -90.0),
        (608.0, 115.0, 865.0, -180.0, 0.0, 0.0),
        (608.0, 290.0, 865.0, -180.0, 0.0, 0.0),
        (608.0, 465.0, 865.0, -180.0, 0.0, 0.0),
        (608.0, 640.0, 865.0, -180.0, 0.0, 0.0),
        (608.0, 815.0, 865.0, -180.0, 0.0, 0.0),
        (608.0, 990.0, 865.0, -180.0, 0.0, 0.0),
        (608.0, 1165.0, 865.0, -180.0, 0.0, 0.0)
    ],
    # LAYER 7 (Right)
    [
        (915.0, 432.0, 995.0, -180.0, 0.0, -90.0),
        (432.0, 115.0, 995.0, -180.0, 0.0, 0.0),
        (432.0, 290.0, 995.0, -180.0, 0.0, 0.0),
        (432.0, 465.0, 995.0, -180.0, 0.0, 0.0),
        (432.0, 640.0, 995.0, -180.0, 0.0, 0.0),
        (432.0, 815.0, 995.0, -180.0, 0.0, 0.0),
        (432.0, 990.0, 995.0, -180.0, 0.0, 0.0),
        (432.0, 1165.0, 995.0, -180.0, 0.0, 0.0),
        (915.0, 1243.0, 995.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 8 (Right)
    [
        (140.0, 853.0, 1115.0, -180.0, 0.0, -90.0),
        (140.0, 437.0, 1115.0, -180.0, 0.0, -90.0),
        (608.0, 115.0, 1115.0, -180.0, 0.0, 0.0 ),
        (608.0, 290.0, 1115.0, -180.0, 0.0, 0.0),
        (608.0, 465.0, 1115.0, -180.0, 0.0, 0.0),
        (608.0, 640.0, 1115.0, -180.0, 0.0, 0.0),
        (608.0, 815.0, 1115.0, -180.0, 0.0, 0.0),
        (608.0, 990.0, 1115.0, -180.0, 0.0, 0.0),
        (608.0, 1165.0, 1115.0, -180.0, 0.0, 0.0)
    ],
    # LAYER 9 (Right)
    [
        (915.0, 432.0, 1245.0, -180.0, 0.0, -90.0),
        (432.0, 115.0, 1245.0, -180.0, 0.0, 0.0),
        (432.0, 290.0, 1245.0, -180.0, 0.0, 0.0),
        (432.0, 465.0, 1245.0, -180.0, 0.0, 0.0),
        (432.0, 640.0, 1245.0, -180.0, 0.0, 0.0),
        (432.0, 815.0, 1245.0, -180.0, 0.0, 0.0),
        (432.0, 990.0, 1245.0, -180.0, 0.0, 0.0),
        (432.0, 1165.0, 1245.0, -180.0, 0.0, 0.0),
        (915.0, 1243.0, 1245.0, -180.0, 0.0, -90.0)
    ]
]

# =====================================================================
# Half plan (A→B)
# =====================================================================
# Cada tupla: (layer_origen, slot_origen, layer_destino_halfB, slot_destino_halfB)
# Indica para qué slots la caja se pone en dos mitades:
# - Half-A en el origen
# - Half-B en un destino diferente

half_plan_left  = [(0,8,1,0), (2,8,3,0), (4,8,5,0), (6,8,7,0)]
half_plan_right = [(0,8,1,0), (2,8,3,0), (4,8,5,0), (6,8,7,0)]

# =====================================================================
# Mid por capa (MidA / MidB) en joints
# =====================================================================
# Estos son puntos intermedios en joint space para cada capa.
# Se utilizan para evitar singularidades o rotaciones bruscas de la muñeca.

mid_left_a = [
    posj(0.72, 58.86, 107.11, 0.00, 14.02, 0.72),
    posj(0.72, 49.68, 109.40, 0.00, 20.90, 0.72),
    posj(0.72, 40.89, 109.82, 0.00, 29.27, 0.72),
    posj(0.72, 32.94, 108.37, 0.00, 38.67, 0.72),
    posj(0.72, 52.23, 108.94, 0.00, 18.80, 0.72),
    posj(0.72, 43.37, 109.89, 0.00, 26.71, 0.72),
    posj(0.72, 35.16, 108.98, 0.00, 35.83, 0.72),
    posj(0.72, 27.97, 106.24, 0.00, 45.76, 0.72),
    posj(0.72, 22.09, 101.74, 0.00, 56.14, 0.72)
]

mid_right_a = [
    posj(-181.11, 58.26, 110.56, 0.00, 11.16, -1.11),
    posj(-181.11, 48.75, 112.90, 0.00, 18.33, -1.11),
    posj(-181.11, 39.58, 113.33, 0.00, 27.07, -1.11),
    posj(-181.11, 31.26, 111.85, 0.00, 36.88, -1.11),
    posj(-181.11, 51.64, 112.39, 0.00, 15.96, -1.11),
    posj(-181.11, 42.32, 113.41, 0.00, 24.25, -1.11),
    posj(-181.11, 33.65, 112.49, 0.00, 33.84, -1.11),
    posj(-181.11, 25.99, 109.65, 0.00, 44.35, -1.11),
    posj(-181.11, 19.81, 105.01, 0.00, 55.16, -1.11)
]

def _rot_j6(j, delta):
    """
    Devuelve un nuevo posj con el mismo J1..J5 y J6 rotado en 'delta'.
    Se usa para generar MidB a partir de MidA.
    """
    return posj(j[0], j[1], j[2], j[3], j[4], j[5] + delta)

# MidB = MidA con J6 rotado +90°
mid_left_b  = [ _rot_j6(j,  90.0) for j in mid_left_a  ]
mid_right_b = [ _rot_j6(j,  90.0) for j in mid_right_a ]

# ---------------------- mapa MidB configurable -------------
# Esta tabla define qué (layer,slot) deben usar MidB en lugar de MidA.
midB_map_left = [
    (0,0), (0,8),
    (1,0), (1,1),
    (2,0), (2,8),
    (3,0), (3,1),
    (4,0), (4,8),
    (5,0), (5,1),
    (6,0), (6,8),
    (7,0), (7,1),
    (8,0), (8,8)
]

midB_map_right = list(midB_map_left)

# =====================================================================
# Utilidades geométricas (APPROACH / RETRACT)
# =====================================================================

def mk_off(dz):
    """
    Crea una posx de offset en Z (relativo) con orientaciones 0.
    Se usa para APPROACH/RETRACT en pick/place.
    """
    return posx(0.0, 0.0, dz, 0.0, 0.0, 0.0, rot_mode)

def _approach_offset(side, layer, slot):
    """
    Devuelve el offset (dx, dy) para el APPROACH del PLACE según:
    - Lado (L/R)
    - Cama impar/par
    - Slot 1..9 (slot 9 tiene caso especial en ambos lados)

    layer y slot son 0-based.
    """
    cama = layer + 1    # 1..9
    pos  = slot + 1     # 1..9

    # ================================
    # LADO IZQUIERDO (L)
    # ================================
    if side == "L":
        if cama % 2 == 1:   # camas 1,3,5,7,9
            if pos == 9:
                return (-50.0, 50.0)      # slot final -> offset Y
            else:
                return (50.0, 50.0)      # slots 1..8 -> offset X
        else:
            # camas pares
            if pos == 2:
                return (-50.0, -50.0)
            else:
                return (-50.0, 50.0)

    # ================================
    # LADO DERECHO (R)
    # ================================
    if side == "R":
        if cama % 2 == 1:   # camas 1,3,5,7,9
            if pos == 9:
                return (50.0, 50.0)
            else:
                return (-50.0, 50.0)
        else:
            # camas pares
            if pos == 2:
                return (50.0, -50.0)
            else:
                return (+50.0, 50.0)

    # Si por alguna razón el lado no es L/R:
    return (0.0, 0.0)

def mk_off_app(side, layer, slot):
    dx, dy = _approach_offset(side, layer, slot)
    return posx(dx, dy, dz_app, 0.0, 0.0, 0.0, rot_mode)

def get_place(side, layer, slot):
    """
    Devuelve:
        - La pose posx del PLACE (en el frame del pallet)
        - El ID de frame (left_frame/right_frame)
    """
    if side == "L":
        p = left_layers[layer][slot]
        return posx(p[0], p[1], p[2], p[3], p[4], p[5], rot_mode), left_frame
    else:
        p = right_layers[layer][slot]
        return posx(p[0], p[1], p[2], p[3], p[4], p[5], rot_mode), right_frame

def get_app(side, layer, slot):
    pl, rf = get_place(side, layer, slot)
    return trans(pl, mk_off_app(side, layer, slot), rf, rf), rf

def get_ret(side, layer, slot):
    """
    Calcula la pose de RETRACT a partir del PLACE:
    PLACE + (0, 0, dz_ret) en el frame del pallet.
    """
    pl, rf = get_place(side, layer, slot)
    return trans(pl, mk_off(dz_ret), rf, rf), rf

# --------- selección de Half A/B según tabla ----------

def find_half(side, layer, slot):
    """
    Busca en half_plan_left/right si (layer,slot) es un ORIGEN Half-A.
    Devuelve:
        (True, dl, ds)  si es origen Half y (dl,ds) es el destino Half-B
        (False, 0, 0)   si no es origen Half
    """
    plan = half_plan_left if side == "L" else half_plan_right
    for t in plan:
        if t[0] == layer and t[1] == slot:
            return True, t[2], t[3]
    return False, 0, 0

def is_half_destination(side, layer, slot):
    """
    Indica si (layer,slot) es un DESTINO Half-B.
    Se usa para:
        - Saltar esos slots en la corrida normal (run_from).
        - Reconocer cuando el usuario arranca justo en un Half-B.
    """
    plan = half_plan_left if side == "L" else half_plan_right
    for t in plan:
        if t[2] == layer and t[3] == slot:
            return True
    return False

def _is_group_b(side, layer, slot):
    """
    Determina si este (layer,slot) debe usar MidB (J6 +90°)
    según midB_map_left/right.
    """
    if side == "L":
        return (layer, slot) in midB_map_left
    else:
        return (layer, slot) in midB_map_right

def get_mid(side, layer, slot):
    """
    Devuelve el joint target Mid adecuado (A o B) según:
        - Lado (Left/Right)
        - Capa (layer)
        - Slot
    Si la capa excede el tamaño de la lista de mids, devuelve None.
    """
    use_b = _is_group_b(side, layer, slot)
    if side == "L":
        if use_b:
            return mid_left_b[layer]  if layer < len(mid_left_b)  else None
        else:
            return mid_left_a[layer]  if layer < len(mid_left_a)  else None
    else:
        if use_b:
            return mid_right_b[layer] if layer < len(mid_right_b) else None
        else:
            return mid_right_a[layer] if layer < len(mid_right_a) else None

# =====================================================================
# Pick desde conveyor
# =====================================================================

# Pose cartesiana del pick en el conveyor (en conv_frame)
pick_pose = posx(107.594, -358.00, 875.00, 180.00, 0.50, -1.0, rot_mode)

def get_pick():
    """
    Devuelve la pose de pick y el frame del conveyor.
    """
    return pick_pose, conv_frame

def get_pick_app():
    """
    APPROACH del pick: pick_pose + dz_app en Z del conveyor.
    """
    return trans(pick_pose, mk_off(dz_app), conv_frame, conv_frame), conv_frame

def get_pick_ret():
    """
    RETRACT del pick: pick_pose + dz_ret en Z del conveyor.
    """
    return trans(pick_pose, mk_off(dz_ret), conv_frame, conv_frame), conv_frame

def plc_set_robot_state(state_int):
    """Publica el estado del robot al PLC (Robot -> PLC INT %ID344).

    NOTA:
        - El modo MANTENIMIENTO tiene prioridad. Una vez que _in_maintenance es True,
        NO se permite que otros estados (StandBy/Normal/Manual/Idle) lo sobreescriban.
    """
    global _in_maintenance
    if _in_maintenance and state_int != ROBOT_STATE_MAINTENANCE:
        # Bloquea el estado en MANTENIMIENTO hasta que el programa se detenga / reinicie.
        return
    tp_log("PLC estado_robot = " + str(state_int))
    set_output_register_int(ROBOT_STATE_REG, state_int)


def plc_vacuum_idle():
    """ACK del compilador en IDLE (0): no se ha tomado el stack / reset."""
    set_output_register_bit(STACK_ACK_BIT, 0)


def plc_vacuum_ok():
    """ACK del compilador en OK (1): el robot ya tomó el stack y el PLC puede seguir compilando."""
    set_output_register_bit(STACK_ACK_BIT, 1)


def plc_enter_maintenance():
    """Force PLC outputs to MAINTENANCE and clear other transient states.

    Call this anytime maintenance is requested, so:
        - Robot state stays in MAINTENANCE.
        - Vacuum bits are cleared (no stale VAC_LOST / VAC_OK).
        - Pick mode is set to idle.
        - Maintenance flag bit is asserted.
    """
    global _in_maintenance, System_InMaintenance
    _in_maintenance = True
    System_InMaintenance = 1
    plc_set_robot_state(ROBOT_STATE_MAINTENANCE)
    plc_set_maintenance_state(True)
    plc_vacuum_idle()
    set_output_register_int(VAC_STATUS_REG, VAC_STATUS_IDLE)
    plc_set_pick_mode("idle")
    set_output_register_int(VAC_STATUS_REG, VAC_STATUS_IDLE)

def plc_exit_maintenance():
    """Clear maintenance latch (allows other states again)."""
    global _in_maintenance, System_InMaintenance
    System_InMaintenance = 0
    _in_maintenance = False
    plc_set_maintenance_state(False)
    plc_vacuum_idle()
    plc_set_pick_mode("idle")
    set_output_register_int(VAC_STATUS_REG, VAC_STATUS_IDLE)
def plc_set_pick_mode(mode):
    """Envía al PLC el modo de pick como un entero.

    Mapeo propuesto:
        0 = idle
        1 = full
        2 = half_b

    half_a NO se usa en el proceso actual.
    """
    if mode == "full":
        val = 1
    elif mode == "half_b":
        val = 2
    else:
        # Cualquier otro valor (incluido "half_a") se mapea a 0
        val = 0

    tp_log("PLC pick_mode_cmd = " + str(val) + " (modo=" + str(mode) + ")")
    set_output_register_int(PICK_MODE_REG, val)


def plc_set_vac_status(vac_status_int):
    global _in_maintenance
    if _in_maintenance:
        # En mantenimiento no permitir que se borre/actualice el estado de vacío desde lógica normal
        return
    set_output_register_int(VAC_STATUS_REG, vac_status_int)


def plc_set_stack_ack(ok_flag):
    global _in_maintenance
    if _in_maintenance and ok_flag:
        # En mantenimiento no permitir ACK=OK
        return

    if ok_flag:
        tp_log("PLC stack_ack = ON")
        plc_vacuum_ok()
    else:
        tp_log("PLC stack_ack = OFF")
        plc_vacuum_idle()


def plc_set_maintenance_state(is_on):
    """Publish maintenance flag bit to the PLC (aux bit)."""
    bit_val = 1 if is_on else 0
    tp_log("PLC maint_state_bit = " + str(bit_val))
    set_output_register_bit(MAINT_BIT, bit_val)

def do_pick(mode):
    """
    Secuencia completa de pick con reintentos por fallo de vacío:

        - Hace hasta 2 intentos automáticos.
        - Si falla esos 2 intentos:
            * Pregunta UNA SOLA VEZ si quiere reintentar.
            * Si el usuario elige reintentar:
                - Se permiten otros 2 intentos.
            * Si vuelve a fallar estos 2 intentos, o el usuario elige no reintentar:
                - Se llama a modo mantenimiento (contraseña, sin pallets, etc.).

    Devuelve True si hubo vacío OK, False si se entra a modo mantenimiento.
    """

    plc_set_pick_mode(mode)
    plc_set_stack_ack(False)

    attempts = 0
    max_attempts = 2
    extra_retry_used = False

    # 1) Ir una sola vez al hub sobre el conveyor (entrada al ciclo)
    movej(up_conv, v=50, a=25)

    # 2) Calcular APPROACH, PICK y RETRACT (si no cambian, calcúlalos una vez)
    a, _ = get_pick_app()
    p, _ = get_pick()
    r, _ = get_pick_ret()

    while True:
        attempts = attempts + 1

        # 3) Ir a approach (desde donde estés: up_conv o retract)
        movej(a, v=vj_slow, a=aj_slow, ref=conv_frame)

        # 4) Esperar conveyor listo (antes de bajar a pick)
        wait_conveyor_ready()

        # 5) Preparar tool weight vacío y bajar a pick
        set_tool("gripper_weight", 0.0, 0.2)
        movel(p, v=vl_slow, a=al_slow, ref=conv_frame)

        # 6) Activar gripper según el modo
        if mode == "full":
            grip_full()
        elif mode == "half_a":
            grip_half_a()
        elif mode == "half_b":
            grip_half_b()
        else:
            tp_log("Modo de pick desconocido: " + str(mode))

        # 7) Esperar vacío OK
        if wait_vacuum_ok(mode, timeout=1.5):
            if mode == "full":
                set_tool("full_weight", 0.0, 0.3)
            else:
                set_tool("half_weight", 0.0, 0.3)
            wait(0.3)

            # ÉXITO: retract y salida a up_conv
            movel(r, v=vl_slow, a=al_slow, ref=conv_frame)
            movej(up_conv, vj_fast, aj_fast)

            plc_set_stack_ack(True)
            plc_set_vac_status(VAC_STATUS_OK)

            if attempts > 1:
                tp_log("Pick recuperado en intento " + str(attempts) +
                       " (modo=" + mode + ").")
            return True

        # 8) FALLO: NO subir a up_conv, solo retract y reintentar
        tp_log("Fallo de vacio en intento " + str(attempts) +
               " (modo=" + mode + ").")

        plc_set_vac_status(VAC_STATUS_LOST)

        # Soltar en pick y retract (quedarte en zona segura cercana)
        rel_by_mode(mode)
        movel(r, v=vl_slow, a=al_slow, ref=conv_frame)

        # 9) Control de rondas (ciclado: siempre vuelve a preguntar)
        if attempts >= max_attempts:
            # Reporta al PLC que hubo fallo de vacío (INT)
            plc_set_vac_status(VAC_STATUS_LOST)

            resp = ask_int_required("1 -->Reintentar \n2 -->Mantenimiento", 1, 2)

            if resp == 1:
                tp_log("Operador eligio reintentar pick.")
                # opcional: al decidir reintentar, volvemos a IDLE para indicar 'reintentando'
                plc_set_vac_status(VAC_STATUS_IDLE)
                attempts = 0
                continue
            else:
                tp_log("Operador eligio llamar a mantenimiento tras fallo de vacio en pick.")
                movej(up_conv, vj_mto, aj_mto)
                go_to_maintenance_mode()
                return False

        tp_log("Reintentando pick (intento " +
            str(attempts + 1) + " de " + str(max_attempts) + ").")



# =====================================================================
# Place (full / half)
# =====================================================================

def do_place(side, layer, slot, rtype):
    """
    Secuencia completa de place en un slot:
        - Mueve al hub del lado (up_left/up_right)
        - Pasa por MidA o MidB (si está definido para esa capa/slot)
        - Va al APPROACH (con offsets X/Y/Z)
        - Baja al PLACE
        - Suelta tipo rtype (full/half_a/half_b)
        - Sube a RETRACT
        - Regresa al hub del lado

    Comportamiento especial ante pérdida de vacío ANTES del place:
        - Se detecta antes de bajar al pallet.
        - Aun así se hace todo el movimiento de place.
        - Ya en el hub se notifica al operador y se pregunta:
            1 = Continuar (se considera un place "bueno" y se sigue al siguiente pick)
            2 = Mantenimiento (se llama go_to_maintenance_mode)

    Devuelve:
        True  -> place terminado y se puede continuar (siguiente acción será un pick)
        False -> se llamó a mantenimiento y NO se debe seguir.
    """
    global _last_place_lost_vacuum
    _last_place_lost_vacuum = False  # por defecto, sin problema

    # Hub según lado
    up = up_left if side == "L" else up_right

    # Calcular place / app / ret
    pl, rp = get_place(side, layer, slot)
    ap, ra = get_app(side, layer, slot)
    rt, rr = get_ret(side, layer, slot)

    # 1) Ir al hub del lado
    movej(up, vj_fast, aj_fast)

    # 2) Detectar posible pérdida de vacío ANTES de bajar
    lost_vacuum = False
    if not has_vacuum_for_mode(rtype):
        lost_vacuum = True
        plc_set_vac_status(VAC_STATUS_LOST)
        tp_log("Perdida de vacio detectada ANTES de place. side=" +
                side + " layer=" + str(layer + 1) +
                " slot=" + str(slot + 1) +
                " tipo=" + str(rtype))

    # 3) Movimiento normal de place (siempre se hace)
    use_b = _is_group_b(side, layer, slot)
    m = get_mid(side, layer, slot)
    if not (m == None):
        if use_b:
            tp_log("MidB en " + side + " L" + str(layer+1) + " S" + str(slot+1))
        else:
            tp_log("MidA en " + side + " L" + str(layer+1) + " S" + str(slot+1))
        movej(m, vj_fast, aj_fast)

    movej(ap, v=vj_slow, a=aj_slow, ref=ra)
    movel(pl, v=vl_slow, a=al_slow, ref=rp)

    # Soltar según tipo
    if   rtype == "full":
        rel_full()
    elif rtype == "half_a":
        rel_half_a()
    elif rtype == "half_b":
        rel_half_b()
    else:
        tp_log("WARNING: do_place con tipo desconocido: " + str(rtype))

    apply_tool_weight_after_place(rtype, lost_vacuum)

    if not lost_vacuum:
        plc_set_vac_status(VAC_STATUS_IDLE)



    movel(rt, v=vl_slow, a=al_slow, ref=rr)

    # Regresar al hub
    movej(up, vj_fast, aj_fast)

    # 4) Si NO hubo pérdida de vacío -> todo OK
    if not lost_vacuum:
        return True

    plc_set_vac_status(VAC_STATUS_LOST)

    # 5) Si hubo pérdida de vacío ANTES de place:
    # ya estamos en el hub; ahora se le pregunta al operador qué hacer.
    resp = ask_int_required("1=Continuar paletizado \n2=Llamar mantenimiento", 1, 2)

    if resp == 1:
        tp_log("Operador eligio CONTINUAR tras perdida de vacio en place. "
                "Se considerara este place como COMPLETADO.")
        plc_set_vac_status(VAC_STATUS_IDLE)

        # Muy importante:
        # Este flag permite que la lógica externa (Half, etc.) sepa que
        # hubo pérdida de vacío pero el operador decidió continuar.
        _last_place_lost_vacuum = True
        return True

    else:
        tp_log("Operador eligio llamar a mantenimiento tras perdida de vacio en place.")
        plc_set_vac_status(VAC_STATUS_LOST)
        plc_set_stack_ack(False)
        go_to_maintenance_mode()
        return False


# =====================================================================
# Lógica Half-A / Half-B
# =====================================================================

# Conjunto que almacena qué destinos Half-B ya han sido llenados
_halfB_filled = set()

def do_half(side, layer, slot, is_half, dl, ds):
    """
    Maneja la lógica de Half-A / Half-B para un slot.

    Si is_half == True:
        - Coloca una mitad en el slot origen
        - Coloca la otra mitad en el destino (dl, ds), si procede.

    IMPORTANTE (por espejo físico):
        Lado izquierdo  (side == "L"):
        - Origen  -> Half-A
        - Destino -> Half-B

        Lado derecho   (side == "R"):
        - Origen  -> Half-B
        - Destino -> Half-A

    Si en el place de origen hay pérdida de vacío y el operador elige CONTINUAR,
    se considera completado el origen y NO se intenta el destino.
    """
    global _halfB_filled
    global _last_place_lost_vacuum

    if is_half:
        # Decidir qué mitad va en origen/destino según el lado
        if side == "L":
            origin_rtype = "half_a"
            dest_rtype   = "half_b"
        else:  # side == "R"
            origin_rtype = "half_b"
            dest_rtype   = "half_a"

        tp_log("Half: side=" + side +
                " ORIG L" + str(layer+1) + " S" + str(slot+1) +
                " (" + origin_rtype + ")" +
                " -> DEST L" + str(dl+1) + " S" + str(ds+1) +
                " (" + dest_rtype + ")")

        # 1) Colocar mitad en el ORIGEN
        ok_origin = do_place(side, layer, slot, origin_rtype)
        if not ok_origin:
            tp_log("do_half: mantenimiento solicitado al colocar mitad de origen.")
            return False

        # Si hubo pérdida de vacío y el operador eligió continuar,
        # NO intentamos la segunda mitad.
        if _last_place_lost_vacuum:
            tp_log("do_half: perdida de vacio en origen, operador continuo. "
                    "Se omite destino y se continua con siguiente slot.")
            return True

        # 2) Verificar si el DESTINO ya fue llenado antes
        if (side, dl, ds) in _halfB_filled:
            tp_log("Destino Half ya estaba lleno. Omitiendo: side=" + side +
                    " L" + str(dl+1) + " S" + str(ds+1))
            return True

        # 3) Comprobar que el destino es válido en la tabla
        if side == "L":
            ok_dest = (dl < len(left_layers) and ds < len(left_layers[dl]))
        else:
            ok_dest = (dl < len(right_layers) and ds < len(right_layers[dl]))

        if not ok_dest:
            tp_log("Destino Half fuera de rango. Solo se coloca la mitad de origen.")
            return True

        # 4) Ajustar nivel de lifter para la capa de destino
        dest_level = lifter_level_for_layer(dl)
        lifter_set_level(side, dest_level)

        movej((up_right if side == "R" else up_left),
                v=vj_slow, a=aj_slow)

        tp_log("Colocando mitad destino en side=" + side +
                " L" + str(dl+1) + " S" + str(ds+1) +
                " (" + dest_rtype + ")")

        ok_dest_place = do_place(side, dl, ds, dest_rtype)
        if not ok_dest_place:
            tp_log("do_half: mantenimiento solicitado al colocar mitad de destino.")
            return False

        # Registrar este destino como lleno
        _halfB_filled.add((side, dl, ds))
        return True

    else:
        # NO es slot Half: caja FULL normal
        ok_full = do_place(side, layer, slot, "full")
        if not ok_full:
            tp_log("do_half: mantenimiento solicitado al colocar FULL.")
            return False

        return True

# =====================================================================
# tp helpers (Teach Pendant)
# =====================================================================

def ask_int_required(prompt, lo, hi):
    """
    Pide un entero entre [lo, hi] y NO deja continuar hasta que el operador
    ingrese un valor válido dentro del rango.
    """
    while True:
        v = tp_get_user_input(prompt, DR_VAR_INT)

        # Si por cualquier razón viene algo raro, lo tratamos como inválido
        if (v >= lo) and (v <= hi):
            return v

        msg = "Valor invalido. Ingrese un numero entre " + str(lo) + " y " + str(hi)
        tp_popup(msg, DR_PM_WARNING)
        tp_log("ask_int_required: valor fuera de rango (" + str(v) + "). Reintentando...")


# ===================== SYSTEM PERSISTENT VARIABLES =====================
# Variables persistentes en el controlador (prefijo System_)
# Guardan el progreso por lado (independiente L/R).
#
# Nota: No se inicializan aqui para NO sobreescribir valores persistidos.
# Se actualizan SOLO cuando el usuario selecciona inicio o cuando avanza el ciclo.

def system_update_progress(side, layer, slot):
    """Actualizar variables persistentes de progreso.

    - System_Side: lado actual en ejecución ("L" o "R")
    - System_Layer_L/System_Slot_L: progreso del lado izquierdo (0-based)
    - System_Layer_R/System_Slot_R: progreso del lado derecho (0-based)
    """
    global System_Side, System_Layer_L, System_Slot_L, System_Layer_R, System_Slot_R

    System_Side = side

    if side == "L":
        System_Layer_L = layer
        System_Slot_L  = slot
    else:
        System_Layer_R = layer
        System_Slot_R  = slot

        tp_log("System progress -> side=" + str(side) + " layer=" + str(layer) + " slot=" + str(slot))


def warn_if_starting_before_last(side, layer, slot):
    """
    Si el operador intenta iniciar ANTES del último punto guardado para ese lado,
    muestra advertencia por posible bajada del lifter y riesgo de colisión.
    Devuelve True si se permite continuar, False si se debe volver a pedir datos.
    """
    # Último progreso guardado por lado
    if side == "L":
        last_layer = System_Layer_L
        last_slot  = System_Slot_L
    else:
        last_layer = System_Layer_R
        last_slot  = System_Slot_R

    # Si no tienes valores inicializados o vienen raros, mejor no bloquear
    # (asumiendo que 0..8 capas y 0..8 slots)
    if last_layer is None or last_slot is None:
        return True

    # Comparación lexicográfica (layer primero, luego slot)
    going_back = (layer < last_layer) or ((layer == last_layer) and (slot < last_slot))

    if not going_back:
        return True

    # Advertencia fuerte + confirmación
    msg = ("La Cama y Slot seleccionados son menores a los usados anteriormente.")
    tp_popup(msg, DR_PM_WARNING)

    resp = ask_int_required("1 -->Continuar \n2 -->Reingresar", 1, 2)
    return (resp == 1)

def ask_layer(side):
    """
    Pregunta en qué cama (layer) quiere iniciar.
    El usuario responde 1..N y se convierte a índice 0-based.
    """
    n = len(left_layers) if side == "L" else len(right_layers)
    v = ask_int_required("Seleccione la Cama 1 - " + str(n), 1, n)
    return v - 1  # 0-based

def ask_slot(side, layer):
    """
    Pregunta en qué slot de la cama quiere iniciar.
    El usuario responde 1..N y se convierte a índice 0-based.
    """
    n = len(left_layers[layer]) if side == "L" else len(right_layers[layer])
    v = ask_int_required("Seleccione el Slot 1 - " + str(n), 1, n)
    return v - 1  # 0-based

def get_configured_start_side():
    """
    Devuelve el lado inicial configurado por variable de sistema.

    Reglas:
        - El sistema SIEMPRE paletiza en ambos lados.
        - El lado inicial NO lo elige el operador; se define con System_StartSide.

    Se espera:
        System_StartSide = "L" o "R"

    Si la variable no existe, es invalida, o viene vacia, se asume "R".
    """
    try:
        s = System_StartSide
    except:
        s = "R"

    if s is None:
        return "R"

    # Normalizar a string y mayuscula
    try:
        s2 = str(s).strip().upper()
    except:
        s2 = "R"

    if s2 == "L":
        return "L"
    return "R"

def get_start_side_with_resume_priority():
    try:
        s = str(System_Side).strip().upper()
        if s == "L" or s == "R":
            return s
    except:
        pass
    return get_configured_start_side()


def ask_main_operation():
    """
    Popup inicial del programa (nuevo flujo):

        1 -> Paletizar
        2 -> Enviar a mantenimiento

    Devuelve 1 o 2.
    """
    msg = "Ingrese un numero:" "\n 1 -->Paletizar  2 -->Mantenimiento"
    return ask_int_required(msg, 1, 2)

# =====================================================================
# helpers para lecturas posx/posj y safe_home
# =====================================================================

# Valores de referencia en X para distinguir si el robot está sobre pallets o conveyor
_left_cx  =  250.0
_right_cx = -1266.0
_conv_cx = 0.00


_left_j1 = up_left[0]
_right_j1 = up_right[0]
_conv_j1 = up_conv[0]

def _nearest_hub_by_j1(j1):
    d_left  = abs(j1 - _left_j1)
    d_right = abs(j1 - _right_j1)
    d_conv  = abs(j1 - _conv_j1)

    if d_left <= d_right and d_left <= d_conv:
        return up_left
    elif d_right <= d_left and d_right <= d_conv:
        return up_right
    else:
        return up_conv

def _get_posx_only():
    """
    Devuelve solo la pose cartesiana actual (sin referencia) desde get_current_posx().
    Maneja ambos formatos posibles.
    """
    res = get_current_posx()
    try:
        pose, _ = res
        return pose
    except:
        return res

def _get_posj_only():
    """
    Devuelve solo la pose en joints actual desde get_current_posj().
    Maneja ambos formatos posibles.
    """
    res = get_current_posj()
    try:
        j, _ = res
        return j
    except:
        return res

# Tolerancia en grados para considerar que el robot está en home
tol_j_deg = 2.0

def _is_home():
    """
    Verifica si la posición actual del robot está dentro de una tolerancia
    alrededor de la posición 'home'.
    """
    jcur = _get_posj_only()
    return (abs(jcur[0] - home[0]) <= tol_j_deg and
            abs(jcur[1] - home[1]) <= tol_j_deg and
            abs(jcur[2] - home[2]) <= tol_j_deg and
            abs(jcur[3] - home[3]) <= tol_j_deg and
            abs(jcur[4] - home[4]) <= tol_j_deg and
            abs(jcur[5] - home[5]) <= tol_j_deg)

def _is_safe_pose():
    """
    Verifica si la posición actual del robot está dentro de una tolerancia
    alrededor de la posición 'safe_pose'.
    """
    jcur = _get_posj_only()
    return (abs(jcur[0] - safe_pose[0]) <= tol_j_deg and
            abs(jcur[1] - safe_pose[1]) <= tol_j_deg and
            abs(jcur[2] - safe_pose[2]) <= tol_j_deg and
            abs(jcur[3] - safe_pose[3]) <= tol_j_deg and
            abs(jcur[4] - safe_pose[4]) <= tol_j_deg and
            abs(jcur[5] - safe_pose[5]) <= tol_j_deg)

def safe_home():
    """
    Lleva al robot de forma segura a la posición 'home':
        - Si ya está en home, no hace nada.
        -Si esta en safe pose se va a home.
        - Si no:
            1) Sube 100mm en Z en el frame base (movimiento relativo).
            2) Va al hub más cercano (pallets o conveyor) según la Y actual.
            3) Va a 'home'.
    """
    if _is_home():
        return

    if _is_safe_pose():
        movej(home, v=vj_mto, a=aj_mto)
        return

    # Obtener pose cartesiana actual
    cur = _get_posx_only()
    cx = cur[0]
    cy = cur[1]

    # Subir 100 mm en Z de forma relativa (para despegar del entorno)
    pz = posx(0, 0, 100, 0, 0, 0, rot_mode)
    movel(pz, time=2, ref=DR_BASE, mod=DR_MV_MOD_REL)

    # Elegir ruta segura según la Y actual (sobre pallets o sobre conveyor)
    curj = _get_posj_only()
    hub = _nearest_hub_by_j1(curj[0])
    movej(hub, v=vj_slow, a=aj_slow)

    # Finalmente ir a home
    movej(home, v=vj_slow, a=aj_slow)

def go_safe_before_lifter():
    """
    Movimiento a una pose segura antes de operar el lifter.
    Se usa para minimizar riesgos de colisión cuando se cambian niveles.
    """
    movej(safe_pose, v=vj_mto, a=aj_mto)

def go_to_maintenance_mode():
    """
    Rutina de llamada a mantenimiento:
        - Pide contraseña de mantenimiento (se repite hasta que sea correcta).
        - Verifica que no haya pallets presentes (L/R).
        * Si hay, pide retirar y espera a que los bits se apaguen.
        - Lleva al robot a una pose segura para mover el lifter.
        - Baja el lifter y restaura frames (nivel 0).
        - Lleva al robot a la pose de mantenimiento.
        - Detiene el programa.
    """
    global _in_maintenance, System_InMaintenance
    _in_maintenance = True
    System_InMaintenance = 1

    set_tool("gripper_weight", 0.0, 0.2)
    rel_full()

    # Enter/lock maintenance immediately (clear other transient outputs)
    plc_enter_maintenance()

    # Al entrar a mantenimiento, NO queremos estados transitorios activos
    plc_set_stack_ack(False)
    plc_set_pick_mode("idle")


    # 1) Pedir contraseña en bucle hasta que sea correcta
    while True:
        pwd = tp_get_user_input("Ingrese contrasena de mantenimiento", DR_VAR_STR)

        if pwd == MAINT_PASSWORD:
            tp_log("Contrasena de mantenimiento correcta. Entrando a modo mantenimiento.")
            break

        tp_popup("Contrasena incorrecta. Intente de nuevo.", DR_PM_ALARM)
        tp_log("Contrasena de mantenimiento incorrecta. Reintentando...")

    # 2) Verificar pallets presentes
    if is_pallet_present("L") or is_pallet_present("R"):
        tp_popup("Retire ambas tarimas antes de mantenimiento.", DR_PM_WARNING)
        tp_log("Esperando retiro de tarimas para mantenimiento.")

        if is_pallet_present("L"):
            wait_remove_finished_pallet("L")
        if is_pallet_present("R"):
            wait_remove_finished_pallet("R")

    # 3) Ir a pose segura antes de mover el lifter
    go_safe_before_lifter()

    # 4) Bajar lifter y restaurar frames (nivel 0)
    lifter_restore_frames()

    # 5) Llevar al robot a la pose de mantenimiento
    movej(maint_safe_pose, v=vj_mto, a=aj_mto)

    tp_log("Robot en pose de mantenimiento. Programa detenido.")
    stop(DR_QSTOP)


# =====================================================================
def finish_side(side):
    """
    Secuencia estándar de finalización de un lado:
        - Log de fin de lado.
        - Ir a posición segura antes de mover el lifter.
        - Pedir que retiren la tarima.
        - Esperar a que la tarima sea retirada.
        - Restaurar frames y nivel lógico del lifter a 0.
    """
    global _in_maintenance
    if _in_maintenance:
        tp_log("finish_side: omitido porque estamos en modo mantenimiento.")
        return
    tp_log("Lado " + side + " finalizado.")
    go_safe_before_lifter()

    plc_set_robot_state(ROBOT_STATE_MANUAL)
    wait_remove_finished_pallet(side)

    lifter_restore_frames()
    # After manual pallet removal, we are back to standby (waiting / next decisions)
    plc_set_robot_state(ROBOT_STATE_STANDBY)

# =====================================================================
# PROGRESO: reset de variables de sistema por lado (solo cuando un lado termina)
# =====================================================================

# =====================================================================
# PENDING PALLET REMOVAL LATCH (persistente por lado)
# - Evita el caso: lado terminado -> reset progreso -> operador NO retira tarima -> reinicio -> lifter puede bajar.
# - System_PendingPalletRemoval_L/R deben existir como variables de sistema (int 0/1) en el controlador.
#   0 = no pendiente, 1 = pendiente de retirar tarima y confirmar con PLC.
# =====================================================================
def get_pending_pallet_removal(side):
    """Devuelve 1 si ese lado tiene tarima terminada pendiente de retiro; si no existe la variable, asume 0."""
    try:
        if side == "L":
            return 1 if (System_PendingPalletRemoval_L == 1) else 0
        else:
            return 1 if (System_PendingPalletRemoval_R == 1) else 0
    except:
        return 0

def set_pending_pallet_removal(side, val):
    """Setea latch persistente de retiro de tarima (0/1). Requiere variables de sistema creadas en el controlador."""
    global System_PendingPalletRemoval_L, System_PendingPalletRemoval_R
    if side == "L":
        System_PendingPalletRemoval_L = (1 if val else 0)
    else:
        System_PendingPalletRemoval_R = (1 if val else 0)

def reset_side_progress(side):
    """Resetear SOLO el progreso persistente del lado indicado a (0,0) 0-based."""
    global System_Layer_L, System_Slot_L, System_Layer_R, System_Slot_R

    if side == "L":
        System_Layer_L = 0
        System_Slot_L  = 0
    else:
        System_Layer_R = 0
        System_Slot_R  = 0

def complete_side(side):
    """
    Finalizar lado de forma robusta ante paros/reinicios:
    Nota: Si el programa se detiene en cualquier punto después de (1) y antes de limpiar el latch,
    al reiniciar main() obligará a confirmar retiro de tarima antes de permitir bajadas del lifter.
    """
    global _in_maintenance
    set_pending_pallet_removal(side, 1)
    reset_side_progress(side)
    finish_side(side)
    # Si finish_side fue omitido por mantenimiento, NO limpiamos el latch (más seguro).
    if not _in_maintenance:
        set_pending_pallet_removal(side, 0)

# =====================================================================
# rutina: ejecutar desde (layer,slot) hasta acabar el lado
# =====================================================================

def run_from(side, start_layer, start_slot):
    """
    Ejecuta la secuencia completa de paletizado desde (start_layer,start_slot)
    hasta completar todas las capas y slots del lado indicado.

    Maneja:
        - Ajuste de nivel del lifter por cada cama.
        - Slots destino Half-B que deben saltarse (ya llenados).
        - Caso especial: última caja de la cama 9 (solo Half-B).
        - Lógica general FULL / Half-A → Half-B.
    """
    # Seleccionar la tabla de layers según el lado
    layers = left_layers if side == "L" else right_layers
    n_layers = len(layers)
    layer = start_layer

    tp_log("run_from: lado " + side +
            " inicio en L" + str(start_layer+1) +
            " S" + str(start_slot+1))

    # Actualizar progreso persistente al inicio del ciclo
    system_update_progress(side, start_layer, start_slot)

    # Bucle por capas
    while layer < n_layers:
        # Determinar nivel lógico del lifter para esta capa
        lvl = lifter_level_for_layer(layer)
        lifter_set_level(side, lvl)

        # Número de slots en esta capa
        n_slots = len(layers[layer])

        # Si es la capa inicial, empezamos en start_slot; si no, desde 0
        s0 = start_slot if layer == start_layer else 0
        slot = s0

        # Bucle por slots dentro de la capa
        while slot < n_slots:
            # Saltar slots que son destino Half-B (ya fueron llenados por do_half)
            if is_half_destination(side, layer, slot):
                tp_log("run_from: saltando destino Half-B L" +
                        str(layer+1) + " S" + str(slot+1))
                slot = slot + 1
                continue

            # Actualizar progreso persistente para este slot
            system_update_progress(side, layer, slot)

            # ---- CASO ESPECIAL: última caja de la cama 9 (solo Half-B) ----
            if (layer == n_layers - 1) and (slot == n_slots - 1):
                tp_log("Última caja de la cama 9: sólo Half-B en " +
                        side + " L" + str(layer+1) +
                        " S" + str(slot+1))

                # Aquí se toma directamente Half-B del conveyor
                ok_pick = do_pick("half_b")
                if not ok_pick:
                    tp_log("Abortando lado " + side +
                            " por fallo de vacío en la última caja.")
                    return

                # Se coloca como Half-B en el último slot
                ok_last = do_place(side, layer, slot, "half_b")
                if not ok_last:
                    tp_log("run_from: mantenimiento solicitado en ultima caja; se aborta lado.")
                    return

                tp_log("Última caja completada en " + side +
                        " L" + str(layer+1) +
                        " S" + str(slot+1) +
                        ". Fin de run_from para este lado.")
                return

            # ---- CASO GENERAL: cajas FULL / Half-A → Half-B ----
            tp_log("run_from: Colocando en " + side +
                    " L" + str(layer+1) +
                    " S" + str(slot+1))

            # Tomar caja completa del conveyor
            ok_pick = do_pick("full")
            if not ok_pick:
                tp_log("Abortando lado " + side +
                        " por fallo de vacío en L" +
                        str(layer+1) + " S" + str(slot+1))
                return  # salir de run_from, no ir a place

            # Determinar si este slot es Half (origen) y su destino
            is_h, dl, ds = find_half(side, layer, slot)

            # Ejecutar lógica de Half-A/Half-B o FULL
            ok_place = do_half(side, layer, slot, is_h, dl, ds)
            if not ok_place:
                tp_log("run_from: se salio por mantenimiento en " +
                        side + " L" + str(layer+1) + " S" + str(slot+1))
                return

            # Avanzar al siguiente slot
            slot = slot + 1

        # Siguiente capa
        layer = layer + 1

    tp_log("run_from: lado " + side + " completado.")

# =====================================================================
def run_side_once(side, layer, slot):
    """
    Ejecuta un ciclo completo de paletizado SOLO para el lado 'side',
    comenzando en (layer, slot), respetando:
        - Caso especial: arranque exactamente en última caja (cama 9, slot 9).
        - Caso especial: arranque en destino Half-B.
        - Caso normal: FULL / Half-A → Half-B.

    Al terminar:
        - Deja el robot en posición segura de retirada (finish_side).
        - Espera a que retiren la tarima.
        - Restaura frames y lifter (nivel 0).

    NO toca el otro lado ni regresa a HOME.
    """
    global _halfB_filled
    _halfB_filled = set()

    layers = left_layers if side == "L" else right_layers

    # Asegurar pallet presente en el lado seleccionado
    if not is_pallet_present(side):
        tp_log("No hay tarima en el lado " + side + ". Esperando a que la coloquen...")
        wait_pallet_present(side)

    n_layers = len(layers)
    n_slots_in_layer = len(layers[layer])

    # ---------- CASO ESPECIAL 1: arranque EXACTAMENTE en última caja ----------
    # Es decir, estamos iniciando directamente en la última cama y el último slot.
    if (layer == n_layers - 1) and (slot == n_slots_in_layer - 1):
        tp_log("Arranque en última caja de la cama 9: sólo Half-B.")

        # Ajustar nivel del lifter a esta cama
        lvl0 = lifter_level_for_layer(layer)
        lifter_set_level(side, lvl0)

        # Tomar una media pieza (Half-B) del conveyor
        ok_pick = do_pick("half_b")
        if not ok_pick:
            tp_log("Abortando lado " + side +
                    " por fallo de vacío en la última caja (arranque especial).")
            finish_side(side)
            return False

        # Colocar Half-B en ese slot
        place_rtype = "half_b" if side == "L" else "half_a"
        ok2 = do_place(side, layer, slot, place_rtype)

        if not ok2:
            tp_log("run_side_once: mantenimiento solicitado en ultima caja (arranque especial).")
            finish_side(side)
            return False

        # Finalizar lado (posición segura + retirar tarima + restaurar frames/lifter)
        complete_side(side)
        return True

    # ---------- CASO ESPECIAL 2: slot inicial es destino Half-B ----------
    # Si el usuario empieza en un slot que es destino Half-B, significa que
    # hay que colocar solo la media caja B en ese slot, y luego continuar.
    if is_half_destination(side, layer, slot):
        tp_log("Arranque en Half-B: se toma media pieza y se coloca en este slot.")

        # Ajustar nivel del lifter para esa cama
        lvl0 = lifter_level_for_layer(layer)
        lifter_set_level(side, lvl0)

        # Tomar media caja Half-B del conveyor
        ok_pick = do_pick("half_b")
        if not ok_pick:
            tp_log("Abortando lado " + side +
                    " por fallo de vacío al arrancar en Half-B.")
            finish_side(side)
            return False

        # Colocar Half-B en este slot
        place_rtype = "half_b" if side == "L" else "half_a"
        ok2 = do_place(side, layer, slot, place_rtype)

        if not ok2:
            tp_log("run_side_once: mantenimiento solicitado al colocar Half-B inicial.")
            finish_side(side)
            return False

        # Registrar este destino Half-B como lleno
        _halfB_filled.add((side, layer, slot))

        # Calcular el siguiente slot donde continuar
        next_layer = layer
        next_slot  = slot + 1
        if next_slot >= n_slots_in_layer:
            # Si nos pasamos del último slot de la capa, avanzamos de capa
            next_layer = next_layer + 1
            next_slot  = 0

        # Si todavía hay capas por paletizar, continuar con run_from
        if next_layer < len(layers):
            run_from(side, next_layer, next_slot)

        # Si se activó mantenimiento en este lado, salir (evita tocar el otro lado en main)
        if _in_maintenance:
            tp_log("run_side_once: mantenimiento activo. Saliendo del lado " + side + ".")
            finish_side(side)
            return False

        # Al final, terminar el lado
        complete_side(side)
        return True

    # ----------------- CASO NORMAL: slot inicial NO es destino Half-B -----------------
    # Se asume que arrancamos en un slot que es:
    #   - FULL normal, o
    #   - Origen Half-A.
    lvl0 = lifter_level_for_layer(layer)
    lifter_set_level(side, lvl0)

    # Tomar caja completa (FULL) para el primer slot
    ok_pick = do_pick("full")
    if not ok_pick:
        tp_log("Abortando lado " + side +
                " por fallo de vacío en el slot inicial L" +
                str(layer+1) + " S" + str(slot+1))
        finish_side(side)
        return False

    # Revisar si este slot inicial es Half-A y su destino
    is_half, dl, ds = find_half(side, layer, slot)
    # Ejecutar lógica FULL o Half-A/Half-B
    ok_place = do_half(side, layer, slot, is_half, dl, ds)
    if not ok_place:
        tp_log("run_side_once: se salio por mantenimiento en slot inicial.")
        finish_side(side)
        return False

    # Correr el resto del lado desde el siguiente slot
    run_from(side, layer, slot + 1)

    # Si se activó mantenimiento en este lado, no continuar (evita tocar el otro lado en main)
    if _in_maintenance:
        tp_log("run_side_once: mantenimiento activo. Saliendo del lado " + side + ".")
        finish_side(side)
        return False

    # Finalizar lado
    complete_side(side)
    return True

# =====================================================================
# MAIN
# =====================================================================
def main():
    global _lifter_level, System_InMaintenance, _in_maintenance

    # ----------------- Configuracion herramienta -----------------
    set_tcp("custom_gripper")
    set_tool_shape("gripper_shape")
    set_tool("gripper_weight", 0.0, 0.2)
    rel_full()

    # ----------------- Estado inicial hacia PLC ------------------
    # System_InMaintenance: 1 => viene de mantenimiento, 0 => normal
    _in_maintenance = (System_InMaintenance == 1)

    if _in_maintenance:
        # Evitar que STANDBY u otros estados sobreescriban MAINTENANCE
        plc_enter_maintenance()
    else:
        plc_set_robot_state(ROBOT_STATE_STANDBY)
        plc_set_maintenance_state(False)
        plc_set_pick_mode("idle")

    # ----------------- Recuperacion tras mantenimiento ------------
    if _in_maintenance:
        # Reinicio despues de mantenimiento:
        # 1) Validar que NO haya tarimas presentes (seguridad)
        # 2) safe_pose -> home global (SIN safe_home para evitar singularidad)
        wait_no_pallets_present_both_sides()

        if not _is_safe_pose():
            movej(safe_pose, v=vj_mto, a=aj_mto)

        movej(home, v=vj_mto, a=aj_mto)

        # Limpiar latch de mantenimiento y continuar flujo normal
        plc_exit_maintenance()

        # (Opcional) Si tu proceso requiere quedar siempre en home seguro:
        # safe_home()

    # ------------------------------------------------------------
    # ARRANQUE NORMAL (SE EJECUTA SIEMPRE):
    # 1) Resolver Lift100 (init desde safe_pose y restore si hay progreso)
    # 2) Sincronizar frames por posición real
    # 3) Luego Home Seguro
    # ------------------------------------------------------------

    # ----------------- PENDING PALLET REMOVAL (anti-paros) --------
    # Si un lado terminó y se reseteó progreso, pero NO se confirmó retiro de tarima,
    # este latch obliga a confirmar retiro ANTES de permitir cualquier bajada/init del lifter.
    pend_L = get_pending_pallet_removal("L")
    pend_R = get_pending_pallet_removal("R")
    if (pend_L == 1) or (pend_R == 1):
        tp_log("Detectado PENDING PALLET REMOVAL (L=" + str(pend_L) + ", R=" + str(pend_R) + ").")
        tp_log("Se requiere confirmar retiro de tarima(s) antes de continuar.")

        # Ir a safe_pose antes de solicitar retiro / mover lifter
        if not _is_safe_pose():
            movej(safe_pose, v=vj_mto, a=aj_mto)

        plc_set_robot_state(ROBOT_STATE_MANUAL)

        if pend_L == 1:
            wait_remove_finished_pallet("L")
        if pend_R == 1:
            wait_remove_finished_pallet("R")

        # Con tarima(s) retiradas, restaurar lifter/frames a nivel 0
        lifter_restore_frames()

        plc_set_robot_state(ROBOT_STATE_STANDBY)

        # Limpiar latches (ya confirmado retiro)
        if pend_L == 1:
            set_pending_pallet_removal("L", 0)
        if pend_R == 1:
            set_pending_pallet_removal("R", 0)

    # ----------------- Lifter init + sincronizacion frames --------
    # Regla: si Lift100 NO está inicializado, SIEMPRE inicializar desde safe_pose.
    # Si hay progreso guardado, después de init re-subir al nivel correspondiente.
    if or_lift.isconn() and (not or_lift.isInit()):
        tp_log("Lift100 NO inicializado. Secuencia segura: safe_pose -> init -> (re-subir si hay progreso) -> continuar.")

        # 1) Ir a safe_pose antes de inicializar
        if not _is_safe_pose():
            movej(safe_pose, v=vj_mto, a=aj_mto)

        # 2) Inicializar (referenciar) lifter
        tp_log("Inicializando Lift100 desde safe_pose...")
        or_lift.init()
    if not lifter_wait_ready():
        tp_popup("ERROR LIFTER: Timeout en init().\nPrograma detenido.", DR_PM_ALARM)
        stop(DR_QSTOP)
        return

    if not (lifter_check_error() == 0):
        tp_popup("ERROR LIFTER: Error tras init().\nPrograma detenido.", DR_PM_ALARM)
        stop(DR_QSTOP)
        return

        lifter_wait_ready()
        lifter_check_error()

        # 3) Si hay progreso guardado: re-subir al nivel que corresponde
        if not lifter_init_is_safe_by_progress():
            try:
                l_layer = (System_Layer_L if (System_Layer_L is not None) else 0)
                r_layer = (System_Layer_R if (System_Layer_R is not None) else 0)
            except:
                l_layer = 0
                r_layer = 0

            tgt_layer = (l_layer if l_layer >= r_layer else r_layer)

            # Clamp de seguridad (layers 0..8, 0-based)
            if tgt_layer < 0:
                tgt_layer = 0
            elif tgt_layer > 8:
                tgt_layer = 8

            tgt_level = lifter_level_for_layer(tgt_layer)

            tp_log("Re-subiendo Lift100 a nivel " + str(tgt_level) +
                   " segun progreso (L=" + str(l_layer) + ", R=" + str(r_layer) + ").")

            if not _lifter_do_set_level(tgt_level):
                tp_popup("ERROR LIFTER: No se pudo re-subir al nivel guardado.\nPrograma detenido.", DR_PM_ALARM)
                stop(DR_QSTOP)
                return
            _lifter_level = tgt_level
            apply_level_to_frames(tgt_level)

    # 4) Sincronizar frames por posición real (si está conectado)
    if or_lift.isconn():
        pos = or_lift.get_pos()
        level_actual = lifter_level_from_pos(pos)
        tp_log("Lift100 detectado en pos=" + str(pos) +
               " mm, nivel logico estimado=" + str(level_actual))
    else:
        tp_log("Lift100 no conectado al inicio: se asume nivel 0.")
        level_actual = 0

    _lifter_level = level_actual
    apply_level_to_frames(level_actual)

    # ============================================================
    # GATE DEL LIFTER (ANTES DEL PRE-MENU y ANTES DEL MENU)
    # - Si lifter no está OK (conectado/init/sin error/pos OK), NO avanza.
    # ============================================================
    if not lifter_gate_or_stop():
        stop(DR_QSTOP)
        return

    # 5) Ahora sí: Home Seguro
    safe_home()


    # ============================
    # PRE-MENU: ajustar lifter según progreso guardado
    # (SIN try/except pass; si falla, debe detenerse y NO mostrar menú)
    # ============================
    pos = or_lift.get_pos()
    _lifter_level = lifter_level_from_pos(pos)

    try:
        l_layer = (System_Layer_L if (System_Layer_L is not None) else 0)
        r_layer = (System_Layer_R if (System_Layer_R is not None) else 0)
    except:
        l_layer = 0
        r_layer = 0

    saved_layer = (l_layer if (l_layer >= r_layer) else r_layer)
    target_level = lifter_level_for_layer(saved_layer)

    if target_level != _lifter_level:
        if not _is_safe_pose():
            movej(safe_pose, v=vj_mto, a=aj_mto)

        lifter_set_level("L", target_level)
        safe_home()
        _lifter_level = target_level

    # ----------------- Menu principal -----------------------------
    op = ask_main_operation()

    if op == 2:
        go_to_maintenance_mode()
        return

    tp_log("Operacion seleccionada: PALETIZAR (ciclo continuo L/R).")

    # Selección inicial SOLO una vez (para arrancar o reanudar un pallet)
    start_side = get_start_side_with_resume_priority()
    layer = ask_layer(start_side)
    slot  = ask_slot(start_side, layer)

    while not warn_if_starting_before_last(start_side, layer, slot):
        layer = ask_layer(start_side)
        slot  = ask_slot(start_side, layer)

    # Guardar progreso inicial seleccionado
    system_update_progress(start_side, layer, slot)

    other_side = "R" if start_side == "L" else "L"

    plc_set_robot_state(ROBOT_STATE_NORMAL)
    tp_log("Inicio en " + start_side +
            " L" + str(layer+1) +
            " S" + str(slot+1) +
            ". Entrando a ciclo infinito: " + start_side + " -> " + other_side + ".")

    # ============================================================
    # CICLO INFINITO
    # - NO vuelve a preguntar 'Paletizar/Mantenimiento'
    # - Ejecuta un lado completo, luego el otro, indefinidamente
    # - Entre ciclos, espera tarimas presentes (nuevas tarimas) según PLC/sensores
    # ============================================================

    order = [start_side, other_side]

    while True:
        for side in order:
            if _in_maintenance:
                tp_log("Modo mantenimiento activo. Saliendo del ciclo continuo.")
                return

            # Asegurar tarima presente antes de iniciar el lado
            if not is_pallet_present(side):
                tp_log("No hay tarima en el lado " + side + ". Esperando a que la coloquen...")
                wait_pallet_present(side)

            # Recuperar progreso persistido del lado
            try:
                if side == "L":
                    layer = (System_Layer_L if (System_Layer_L is not None) else 0)
                    slot  = (System_Slot_L  if (System_Slot_L  is not None) else 0)
                else:
                    layer = (System_Layer_R if (System_Layer_R is not None) else 0)
                    slot  = (System_Slot_R  if (System_Slot_R  is not None) else 0)
            except:
                layer = 0
                slot  = 0

            system_update_progress(side, layer, slot)

            tp_log("Iniciando lado " + side + " desde L" + str(layer+1) + " S" + str(slot+1) + ".")
            plc_set_robot_state(ROBOT_STATE_NORMAL)

            ok = run_side_once(side, layer, slot)

            if (not ok) or _in_maintenance:
                tp_log("Abortando ciclo continuo (fallo o mantenimiento) en lado " + side + ".")
                return

        # Fin de ambos lados -> regresar a home y quedar en IDLE, pero CONTINUAR ciclo
        if not _in_maintenance:
            movej(home, v=vj_slow, a=aj_slow)
            plc_set_robot_state(ROBOT_STATE_IDLE)
            plc_vacuum_idle()
            plc_set_pick_mode("idle")
            # Loop continua (esperará nuevas tarimas en cada lado)
            continue
        else:
            tp_log("Modo mantenimiento activo. No se regresa a home.")
            return


# Llamada al MAIN para iniciar el flujo cuando se ejecuta el script.
main()