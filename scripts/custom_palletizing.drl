# =====================================================================
# Palletizing Script (Doosan DRL)
# Autor: Mario Padilla
# =====================================================================
# Este programa controla un sistema de paletizado con:
# - Un robot Doosan
# - Un lifter (Lift100) que sube/baja la base del robot
# - Un conveyor (transportador) donde llegan las cajas
# - Dos pallets: izquierdo (L) y derecho (R)
# - Un gripper de dos mitades (Half-A y Half-B)
#
# Funcionalidades principales:
# - Pick de cajas (6 o 3) desde el conveyor
# - Colocación de cajas en patrones de paletizado por layer ("camas") y slots
# - Manejo de media carga (Half-A / Half-B) con un plan definido
# - Compensación automática de frames según la altura del lifter
# - Uso de señales de PLC para pallets presentes, conveyor listo, y estado del robot
# - Interacción con el operador a través del Teach Pendant (tp_popup, tp_get_user_input, etc.)
# =====================================================================

# ---------------------- frames ----------------------
# ID de los frames enseñados en el controlador

# Frames de TRABAJO (los que usa todo el programa para pick/place)
# Estos son los frames que se utilizan dinámicamente para cálculos de movimiento.
conv_frame  = 101   # Frame del conveyor (pick) - TRABAJO
left_frame  = 102   # Frame del pallet izquierdo - TRABAJO
right_frame = 103   # Frame del pallet derecho - TRABAJO

# Frames ORIGINALES nivel 0 (enseñados manualmente con el lifter abajo,
# todo respecto al WORLD). Estos NUNCA se modifican desde código.
# Se usan como referencia base para recalcular los frames de trabajo cuando cambia el nivel del lifter.
conv_frame_orig  = 191   # conveyor original nivel 0
left_frame_orig  = 192   # pallet izquierdo original nivel 0
right_frame_orig = 193   # pallet derecho original nivel 0

# ---------------------- parámetros globales ---------
# Modo de orientación: FIX XYZ (RX, RY, RZ fijos, no ELR).
# Es decir, se trabajan las orientaciones directamente en ángulos RX, RY, RZ.
rot_mode = DR_FIX_XYZ

# Offsets en Z para APPROACH y RETRACT con respecto al PLACE
# Sirven para aproximarse y retirarse verticalmente del punto de contacto.
dz_app = 200.0     # Distancia en Z para aproximación (APP) antes de llegar al punto de place/pick
dz_ret = 200.0     # Distancia en Z para retract (RET) después de soltar/tomar la caja

# ---------------------- velocidades -----------------
# Velocidades y aceleraciones de joint (vj/aj) y lineales (vl/al)
# Se separa en "rápido" y "lento" para poder controlar zonas seguras y zonas de trabajo fino.
vj_fast = 60;  aj_fast = 50   # Movimiento rápido en juntas (movej)
vj_slow = 40;  aj_slow = 30   # Movimiento más lento en juntas (para zonas sensibles)
vl_fast = 1000; al_fast = 1000  # Movimiento rápido lineal (movel)
vl_slow = 800;  al_slow = 800   # Movimiento lento lineal (para acercamiento / contacto)

# ---------------------- poses joint auxiliares ------  
# Home general del robot (posición segura de referencia)
home = posj(-90.00, 0.00, 90.00, 0.00, 90.00, 90.00)

# Posiciones "up" sobre zonas clave (hubs de seguridad):
# Estas son posturas en joint encima de las zonas principales. Se usan como puntos intermedios seguros.
up_conv  = posj(-80.61, 29.87, 65.62, 0.00, 84.50, 99.38)   # Hub sobre conveyor
up_left  = posj(4.58, -8.86, 98.00, 0.00, 90.85, 94.58)     # Hub sobre pallet izquierdo
up_right = posj(-175.42, -8.86, 98.01, 0.00, 90.86, 94.58)  # Hub sobre pallet derecho


# Posición segura antes de bajar el lifter por completo y retirar tarima.
# Esta postura busca minimizar riesgo de colisión cuando se mueve el Lift100.
safe_pose = posj(0.00, 0.00, 0.00, 0.00, 0.00, 90.00)


MAINT_PASSWORD = "1234"   # Contraseña de mantenimiento
maint_safe_pose = posj(90.00, 50.00, 115.00, 0, -75.00, 90.00)

# Flag global: indica si se ha entrado en modo mantenimiento
_in_maintenance = False

# Flag global: indica si en el ÚLTIMO do_place hubo pérdida de vacío
# y el operador eligió CONTINUAR (no mantenimiento).
_last_place_lost_vacuum = False


# ---------------------- I/O gripper -----------------
# Definición de las salidas digitales que controlan el gripper
# Se asume un gripper de doble vía, donde cada vía puede controlar media caja.
do_a = 1  # DO para "mitad A" o una vía del gripper
do_b = 2  # DO para "mitad B" o la otra vía del gripper
do_a_blow = 3
do_b_blow = 4

# Entradas digitales de retro de vacío
# Estas indican si hay vacío suficiente (pieza agarrada) en cada mitad.
di_vac_ok_a = 1    # DI para "vacío OK mitad A" 
di_vac_ok_b = 2    # DI para "vacío OK mitad B" 

# ---------------------- PLC OUTPUT (Robot -> PLC) ----------------------
# IMPORTANT:
# - Robot State (%ID344) is mapped to Output INT Register 0
# - Pick Mode   (%ID348) is mapped to Output INT Register 1
# - Vacuum State bits are mapped to Output BIT Register 0..1
#
# See: "PLC Signal Mapping.txt" for the official mapping.

# Output INT registers
ROBOT_STATE_REG = 0   # %ID344
PICK_MODE_REG   = 1   # %ID348

# Robot state values (INT)
ROBOT_STATE_IDLE        = 0
ROBOT_STATE_NORMAL      = 1   # palletizing (automatic cycle)
ROBOT_STATE_STANDBY     = 2   # menus / selections / waiting for operator choice
ROBOT_STATE_MANUAL      = 3   # manual action (RETIRAR TARIMA)
ROBOT_STATE_MAINTENANCE = 4   # maintenance mode

# Output BIT registers (Vacuum state)
VAC_OK_BIT   = 0   # %I38.0 -> VACUUM OK
VAC_LOST_BIT = 1   # %I38.1 -> VACUUM LOST

# Optional status bit (kept from your script)
MAINT_BIT = 2       # 1 = robot in maintenance mode (aux bit to PLC)


# Funciones de control del gripper (FULL / HALF A / HALF B / RELEASE)
# Estas funciones encapsulan la lógica de encender/apagar las DO y agregar pequeñas esperas.

def grip_full():
    """
    Activa ambas salidas -> agarra 6 cajas.
    """
    set_digital_output(do_a, ON)
    set_digital_output(do_b, ON)
    wait(0.2)  # Tiempo para que el gripper genere vacío / cierre

def grip_half_a():
    """
    Sólo activa 'A' -> agarra 3 cajas lado A.
    """
    set_digital_output(do_a, ON)
    set_digital_output(do_b, OFF)
    wait(0.2)

def grip_half_b():
    """
    Sólo activa 'B' -> agarra 3 cajas lado B.
    """
    set_digital_output(do_a, OFF)
    set_digital_output(do_b, ON)
    wait(0.2)

def rel_full():
    """
    Libera ambas mitades -> suelta 6 cajas.
    """
    set_digital_output(do_a, OFF)
    set_digital_output(do_b, OFF)
    wait(0.2)
    set_digital_output(do_a_blow, ON)
    set_digital_output(do_b_blow, ON)
    wait(0.5)
    set_digital_output(do_a_blow, OFF)
    set_digital_output(do_b_blow, OFF)

def rel_half_a():
    """
    Libera sólo la mitad A (Half-A).
    """
    set_digital_output(do_a, OFF)
    wait(0.15)
    set_digital_output(do_a_blow, ON)
    wait(0.5)
    set_digital_output(do_a_blow, OFF)


def rel_half_b():
    """
    Libera sólo la mitad B (Half-B).
    """
    set_digital_output(do_b, OFF)
    wait(0.15)
    set_digital_output(do_b_blow, ON)
    wait(0.5)
    set_digital_output(do_b_blow, OFF)


# =====================================================================
# Retroalimentación de vacío
# =====================================================================
# Mientras USE_VAC_FEEDBACK = False, el programa ignora estas DI de vacío
# y asume que siempre se agarra correctamente la pieza.
USE_VAC_FEEDBACK = True 

def _vac_ok_a():
    """
    Devuelve True si la mitad A del gripper tiene vacío OK.

    Lee directamente de una ENTRADA DIGITAL del robot:
      di_vac_ok_a -> get_digital_input(di_vac_ok_a)
    """
    return get_digital_input(di_vac_ok_a) == ON

def _vac_ok_b():
    """
    Devuelve True si la mitad B del gripper tiene vacío OK.

    Lee directamente de una ENTRADA DIGITAL del robot:
      di_vac_ok_b -> get_digital_input(di_vac_ok_b)
    """
    return get_digital_input(di_vac_ok_b) == ON

def wait_vacuum_ok(mode, timeout=2):
    """
    Espera a que el gripper confirme vacío OK según el modo:
      - "full"   -> A y B deben tener vacío
      - "half_a" -> sólo A debe tener vacío
      - "half_b" -> sólo B debe tener vacío

    Si USE_VAC_FEEDBACK == False, siempre devuelve True (sin sensores).

    timeout en segundos: tiempo máximo para esperar vacío antes de considerar fallo.
    """
    if not USE_VAC_FEEDBACK:
        # NO se verifica vacío, se asume OK
        return True

    # Determina qué mitades deben tener vacío según el modo
    need_a = (mode == "full" or mode == "half_a")
    need_b = (mode == "full" or mode == "half_b")

    t = 0.0
    dt = 0.5  # Periodo de muestreo de las entradas

    # Bucle hasta que haya vacío o se acabe el tiempo de espera
    while t < timeout:
        ok_a = (not need_a) or _vac_ok_a()
        ok_b = (not need_b) or _vac_ok_b()

        if ok_a and ok_b:
            # Ambas mitades requeridas tienen vacío correcto
            return True

        wait(dt)
        t = t + dt

    # Si llega aquí, no hubo vacío suficiente dentro del timeout
    tp_log("ADVERTENCIA: fallo de vacío en modo '" + mode + "'.")
    return False

def rel_by_mode(mode):
    """
    Libera el gripper según el modo de pick usado.
    """
    if mode == "full":
        rel_full()
    elif mode == "half_a":
        rel_half_a()
    elif mode == "half_b":
        rel_half_b()

def has_vacuum_for_mode(mode):
    """Comprueba de forma instantánea si el vacío sigue siendo válido
    para el modo indicado (full / half_a / half_b).

    Si USE_VAC_FEEDBACK == False, devuelve siempre True.
    """
    if not USE_VAC_FEEDBACK:
        return True

    need_a = (mode == "full") or (mode == "half_a")
    need_b = (mode == "full") or (mode == "half_b")

    ok_a = (not need_a) or _vac_ok_a()
    ok_b = (not need_b) or _vac_ok_b()

    return ok_a and ok_b

def calc_tool_weight_by_vacuum_feedback(rtype):
    """Determina qué peso debe setearse usando la retroalimentación de vacío (A/B).

    Reglas:
      - rtype == "full":
          * A=1 y B=1  -> full_weight
          * solo A o solo B -> half_weight
          * A=0 y B=0  -> gripper_weight
      - rtype == "half_a":
          * A=1 -> half_weight
          * A=0 -> gripper_weight
      - rtype == "half_b":
          * B=1 -> half_weight
          * B=0 -> gripper_weight
    """
    a_ok = _vac_ok_a()
    b_ok = _vac_ok_b()

    if rtype == "full":
        if a_ok and b_ok:
            return "full_weight"
        elif a_ok or b_ok:
            return "half_weight"
        else:
            return "gripper_weight"

    if rtype == "half_a":
        return "half_weight" if a_ok else "gripper_weight"

    if rtype == "half_b":
        return "half_weight" if b_ok else "gripper_weight"

    return "gripper_weight"


def apply_tool_weight_after_place(rtype, lost_vacuum):
    """Aplica set_tool() justo DESPUÉS de soltar en el place y ANTES del retract.

    Caso A) NO hubo pérdida de vacío antes del place (lost_vacuum == False):
      - Se decide por retro (A/B) DESPUÉS del release para cubrir:
          * Pick FULL -> place half_* (queda media carga)
          * Pick half_* -> place half_* (queda vacío)
          * Cualquier variación si el vacío cambió durante approach/bajada

    Caso B) Sí hubo pérdida de vacío antes del place (lost_vacuum == True):
      - Se determina con retro (A/B) qué quedaba realmente y se setea:
            full_weight / half_weight / gripper_weight
    """
    if lost_vacuum:
        tool_name = calc_tool_weight_by_vacuum_feedback(rtype)
        set_tool(tool_name, 0.0, 0.2)
        return

    # Sin pérdida pre-place: decide el peso por retro A/B tras soltar.
    # Usamos rtype="full" para evaluar el estado global A/B (full/half/empty).
    tool_name = calc_tool_weight_by_vacuum_feedback("full")
    set_tool(tool_name, 0.0, 0.2)





# =====================================================================
# Sensores de seguridad
# =====================================================================
# ---------------------- I/O pallets desde PLC ----------------------
# Estos bits vienen del PLC y representan sensores físicos de presencia de tarima
# o estados de "conveyor listo".

CONV_READY_BIT   = 0   # Bit del PLC que indica "conveyor listo"
PALLET_LEFT_BIT  = 1   # Limit switch pallet izquierdo presente
PALLET_RIGHT_BIT = 2   # Limit switch pallet derecho presente


def _pallet_bit_index(side):
    """
    Devuelve el índice de bit correspondiente al lado:
      side == "L" -> PALLET_LEFT_BIT
      side == "R" -> PALLET_RIGHT_BIT
    """
    return PALLET_LEFT_BIT if side == "L" else PALLET_RIGHT_BIT

def is_pallet_present(side):
    """
    Devuelve True si el pallet está presente en el lado indicado ('L' o 'R').
    Lee el bit correspondiente del registro del PLC.
    """
    bit_idx = _pallet_bit_index(side)
    return get_input_register_bit(bit_idx) == ON

def wait_pallet_present(side):
    """
    Espera a que haya pallet presente en el lado indicado ('L' o 'R').

    Se asume:
      - bit == ON  -> hay tarima presente
      - bit == OFF -> NO hay tarima
    """
    bit_idx = _pallet_bit_index(side)

    tp_log("Esperando tarima en lado " + side + "...")
    while get_input_register_bit(bit_idx) == OFF:
        wait(0.5)  # Revisa el bit cada 0.5 segundos

    tp_log("Tarima detectada en lado " + side + ".")

def wait_remove_finished_pallet(side):
    """
    Espera a que retiren la tarima terminada del lado indicado ('L' o 'R').

    Se asume:
      - bit == ON  -> hay tarima presente
      - bit == OFF -> tarima retirada
    """
    bit_idx = _pallet_bit_index(side)

    tp_log("Esperando a que retiren la tarima del lado " + side + "...")
    while get_input_register_bit(bit_idx) == ON:
        wait(0.5)

    tp_log("Tarima retirada en lado " + side + ".")


def wait_no_pallets_present_both_sides():
    """
    Bloquea el movimiento del robot hasta que NO haya tarimas presentes
    en ninguno de los dos lados.

    Se usa principalmente al reiniciar el programa cuando el robot estaba
    en MAINTENANCE: antes de permitir Home seguro, se verifica que ambas
    estaciones estén libres.

    Se asume:
      - bit == ON  -> hay tarima presente
      - bit == OFF -> NO hay tarima
    """
    while is_pallet_present("L") or is_pallet_present("R"):
        msg = "RETIRE TARIMAS: No se permite movimiento hasta que ambos lados estén libres."
        tp_popup(msg, DR_PM_WARNING)
        tp_log("Bloqueo por tarimas presentes: L=" + str(is_pallet_present("L")) +
               ", R=" + str(is_pallet_present("R")))
        wait(0.5)

def wait_conveyor_ready():
    """
    Espera a que el PLC indique que la caja está lista para pick.
    El bit CONV_READY_BIT debe permanecer en ON para continuar.
    """
    tp_log("Esperando conveyor listo para pick...")
    while get_input_register_bit(CONV_READY_BIT) == OFF:
        wait(0.2)
    tp_log("Conveyor listo.")



# =====================================================================
# LIFTER100 (or_lift) - Lógica multinivel + seguridad + compensación
# =====================================================================
# Esta sección maneja el Lift100:
# - Convierte capas ("camas") a niveles de lifter (0,1,2)
# - Compensa los frames de trabajo según la altura
# - Verifica estados de error / posición del lifter

# Tramos mecánicos del lifter
DZ_LIFTER_1 = 400.0         # primer tramo (mm)
DZ_LIFTER_2 = 270.0         # segundo tramo (mm) (total ≈ 670 mm)

# Mapa lógico por cama (0-based):
#   0..3 -> nivel 0 (0 mm, lifter abajo)
#   4..6 -> nivel 1 (+400 mm)
#   7..8 -> nivel 2 (+400+270 mm)
def lifter_level_for_layer(layer):
    """
    Devuelve el nivel lógico del lifter según la cama (layer 0-based):
      0-3 -> 0
      4-6 -> 1
      7-8 -> 2
    """
    if layer <= 3:
        return 0
    elif layer <= 6:
        return 1
    else:
        return 2

def _level_offset(level):
    """
    Devuelve el offset total en Z según el nivel del lifter.
    Este offset se usa para compensar frames (bajan en Z cuando el lifter sube).
    """
    if level == 0:
        return 0.0
    elif level == 1:
        return DZ_LIFTER_1
    elif level == 2:
        return DZ_LIFTER_1 + DZ_LIFTER_2
    return 0.0

def lifter_target_pos_for_level(level):
    """
    Posición objetivo en mm del Lift100 para un nivel lógico:
      level 0 ->   0 mm
      level 1 -> 400 mm
      level 2 -> 670 mm
    """
    if level == 0:
        return 0.0
    elif level == 1:
        return 400.0
    elif level == 2:
        return 670.0
    return 0.0


def lifter_level_from_pos(pos):
    """
    Estima el nivel lógico (0,1,2) según la posición real [mm] del Lift100.
    Ajusta los umbrales según los valores reales de tu instalación.
    """
    # Ejemplo: 0..200 => nivel 0, 200..540 => nivel 1, >540 => nivel 2
    if pos < 200.0:
        return 0
    elif pos < 540.0:
        return 1
    else:
        return 2


# Estado actual del lifter (nivel lógico 0/1/2)
_lifter_level = 0


# ---------------------- helpers de seguridad Lift100 -----------------
def lifter_init_is_safe_by_progress():
    """
    Devuelve False si NO es seguro inicializar el lifter (porque init puede bajar a 0).
    Regla solicitada:
      - Si AMBOS lados tienen progreso (cama) > 5, NO permitir init.

    Nota: tus layers son 0-based.
      - "mayor a 5" en 1-based = capas 6..9
      - en 0-based eso es layer >= 5
    """
    # Si por alguna razón no existen aún, por seguridad permitir
    try:
        l_ok = (System_Layer_L is not None)
        r_ok = (System_Layer_R is not None)
        if not (l_ok and r_ok):
            return True

        # 0-based: layer >= 5 equivale a cama >= 6 (1-based)
        if (System_Layer_L >= 5) and (System_Layer_R >= 5):
            return False

        return True
    except:
        return True


def lifter_wait_ready(timeout=15.0):
    """
    Espera a que el Lift100 termine cualquier movimiento (isBusy == False).
    Usa un timeout para evitar bucles infinitos.
    """
    t = 0.0
    while or_lift.isBusy():
        wait(0.1)
        t = t + 0.1
        if t >= timeout:
            tp_log("TIMEOUT esperando a que el Lift100 termine el movimiento.")
            break

def lifter_check_error():
    """
    Consulta or_lift.get_error() y registra el código si no es 0.
    NO detiene el programa, sólo deja traza.
    """
    err = or_lift.get_error()
    if err != 0:
        tp_log("ADVERTENCIA: Lift100 error code = " + str(err))
    return err

def lifter_check_position(level, tol=5.0):
    """
    Verifica que el Lift100 esté dentro de una tolerancia ±tol [mm]
    alrededor de la posición esperada para 'level'.
    """
    if not or_lift.isconn():
        tp_log("Lift100 no conectado; no se puede verificar posición.")
        return False

    pos = or_lift.get_pos()
    tgt = lifter_target_pos_for_level(level)
    if abs(pos - tgt) <= tol:
        return True

    tp_log("ADVERTENCIA: Lift100 desincronizado. level=" + str(level) +
           " pos=" + str(pos) + " esperado=" + str(tgt))
    return False

def lifter_safe_init():
    """
    Verifica conexión e inicialización del Lift100.
    Si no está inicializado, ejecuta or_lift.init() y espera a que termine.
    NO toca frames ni niveles, sólo deja el Lift100 referenciado.
    """
    if not or_lift.isconn():
        tp_log("ERROR: Lift100 no conectado (or_lift.isconn() == False).")
        return

    if or_lift.isInit():
        tp_log("Lift100 ya está inicializado.")
        return

    # --- GUARD: evitar init si puede aplastar tarimas ---
    if not lifter_init_is_safe_by_progress():
        tp_popup("NO ES SEGURO inicializar el Lift100.", DR_PM_ALARM)
        tp_log("Bloqueado lifter_safe_init(): progreso alto en ambos lados.")
        return

    tp_log("Inicializando Lift100...")
    or_lift.init()
    lifter_wait_ready()


    if not or_lift.isInit():
        tp_log("ADVERTENCIA: or_lift.isInit() sigue en False después de init().")
    else:
        tp_log("Lift100 inicializado correctamente.")


# ---------------------- frames + nivel lifter ------------------------

def _lifter_do_set_level(level):
    """
    Ajusta el Lift100 al nivel indicado usando or_lift.move().
    Niveles permitidos:
      0 -> ~0 mm
      1 -> ~400 mm
      2 -> ~670 mm
    Incluye:
      - Verificación de conexión.
      - Inicialización segura si aún no está init.
      - Espera a que termine el movimiento (isBusy).
      - Chequeo de error y de posición final.
    """
    # Asegurar conexión e init
    lifter_safe_init()
    if not or_lift.isconn():
        tp_log("No se puede mover Lift100: sin conexión.")
        return

    # Validar nivel
    if not (level == 0 or level == 1 or level == 2):
        tp_log("Nivel Lift100 inválido: " + str(level) +
               ". Re-inicializando a posición 0.")
        or_lift.init()
        lifter_wait_ready()
        lifter_check_error()
        return

    # Calcular posición objetivo en mm
    tgt = lifter_target_pos_for_level(level)

    # Si ya está dentro de tolerancia y no está ocupado, no mover
    cur = or_lift.get_pos()
    if abs(cur - tgt) < 2.0 and (not or_lift.isBusy()):
        tp_log("Lift100 ya en nivel " + str(level) +
               " (pos=" + str(cur) + " mm).")
        return

    tp_log("Moviendo Lift100 a nivel " + str(level) +
           " (" + str(tgt) + " mm).")

    # Movimiento con velocidad razonable dentro del rango 10–100 mm/s
    or_lift.move(tgt, 80.0)

    # Esperar a que termine
    lifter_wait_ready()

    # Revisar si hay errores
    lifter_check_error()

    # Verificar posición final
    lifter_check_position(level)


def apply_level_to_frames(level):
    """
    A partir de los frames ORIGINALES nivel 0 (191, 192, 193),
    escribe los frames de trabajo (101, 102, 103) compensando en Z
    según el nivel lógico del lifter (0,1,2).

    Regla:
      new_z = z_original - offset(level)
    donde offset(level) usa _level_offset(level).
    """
    dz = _level_offset(level)

    # Lista de mapeos (frame_original -> frame_trabajo)
    pairs = [
        (conv_frame_orig,  conv_frame),
        (left_frame_orig,  left_frame),
        (right_frame_orig, right_frame)
    ]

    for f_orig, f_work in pairs:
        # Obtener pose del frame original (nivel 0)
        pose_orig, ref_orig = get_user_cart_coord(f_orig)

        # Se mantiene X, Y, RX, RY, RZ; sólo se compensa Z
        new_pose = posx(
            pose_orig[0],              # X
            pose_orig[1],              # Y
            pose_orig[2] - dz,         # Z compensada hacia abajo
            pose_orig[3],              # RX
            pose_orig[4],              # RY
            pose_orig[5],              # RZ
            rot_mode
        )

        # Escribimos en el frame de TRABAJO correspondiente
        overwrite_user_cart_coord(f_work, new_pose, ref_orig, DR_TEMPORARY)


def lifter_set_level(side, level):
    """
    Mueve el lifter al nivel indicado (0,1,2) y ajusta SIEMPRE los frames
    de TRABAJO (101,102,103) a partir de los frames ORIGINALES nivel 0
    (191,192,193), sin modificar jamás los originales.

    Pasos:
      - Si el nivel ya es _lifter_level, no hace nada.
      - Mueve físicamente el lifter al nivel deseado.
      - Aplica la compensación de frames con apply_level_to_frames(level).
      - Actualiza _lifter_level.
    """
    global _lifter_level, _in_maintenance
    # Protección: si ya estamos en ese nivel lógico, no hacer nada
    if level == _lifter_level:
        tp_log("Lift100 ya en nivel lógico " + str(level) + ".")
        return

    tp_log("Cambiando lifter a nivel " + str(level) +
           " (offset Z = " + str(_level_offset(level)) + " mm).")

    # Mover físicamente el lifter
    _lifter_do_set_level(level)

    # Ajustar frames de trabajo en función de los frames originales
    apply_level_to_frames(level)

    # Actualizar estado lógico
    _lifter_level = level


def lifter_restore_frames():
    """
    Restaura el sistema a nivel 0:
      - Mueve físicamente el lifter a nivel 0.
      - Aplica apply_level_to_frames(0) para que 101/102/103 coincidan
        con los frames originales nivel 0.
      - Actualiza _lifter_level = 0.
    """
    global _lifter_level

    # Mover lifter físicamente a nivel 0
    _lifter_do_set_level(0)

    # Aplicar compensación de nivel 0 (sin desplazamiento en Z)
    apply_level_to_frames(0)

    # Estado lógico
    _lifter_level = 0



# =====================================================================
# Datos PLACE (por capas y lados)
# =====================================================================
# Estructura:
#   left_layers / right_layers: lista de layers (0..N-1).
#   Cada layer: lista de 9 slots (0..8).
#   Cada slot: (X, Y, Z, RX, RY, RZ) en el frame del pallet.
#
# Estas tablas definen el patrón exacto de paletizado.

left_layers = [
    # LAYER 1 (Left)
    [
        (105.0, 402.0, 265.0, -180.0, 0.0,  90.0),
        (593.0,  90.0, 265.0, -180.0, 0.0, -180.0), #
        (593.0, 265.0, 265.0, -180.0, 0.0, -180.0),
        (593.0, 440.0, 265.0, -180.0, 0.0, -180.0),
        (593.0, 615.0, 265.0, -180.0, 0.0, -180.0),
        (593.0, 790.0, 265.0, -180.0, 0.0, -180.0),
        (593.0, 965.0, 265.0, -180.0, 0.0, -180.0),
        (593.0,1140.0, 265.0, -180.0, 0.0, -180.0),
        (105.0,1212.0, 265.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 2 (Left)
    [
        (915.0, 812.0, 386.0, -180.0, 0.0,  90.0),
        (915.0, 407.0, 386.0, -180.0, 0.0,  90.0),
        (418.0,  90.0, 386.0, -180.0, 0.0, -180.0),
        (418.0, 265.0, 386.0, -180.0, 0.0, -180.0), #
        (418.0, 440.0, 386.0, -180.0, 0.0, -180.0),
        (418.0, 615.0, 386.0, -180.0, 0.0, -180.0),
        (418.0, 790.0, 386.0, -180.0, 0.0, -180.0),
        (418.0, 965.0, 386.0, -180.0, 0.0, -180.0),
        (418.0,1140.0, 386.0, -180.0, 0.0, -180.0)
    ],
    # LAYER 3 (Left)
    [
        (105.0, 402.0, 507.0, -180.0, 0.0,  90.0),
        (593.0,  90.0, 507.0, -180.0, 0.0, -180.0),
        (593.0, 265.0, 507.0, -180.0, 0.0, -180.0),
        (593.0, 440.0, 507.0, -180.0, 0.0, -180.0),
        (593.0, 615.0, 507.0, -180.0, 0.0, -180.0),
        (593.0, 790.0, 507.0, -180.0, 0.0, -180.0),
        (593.0, 965.0, 507.0, -180.0, 0.0, -180.0),
        (593.0,1140.0, 507.0, -180.0, 0.0, -180.0),
        (105.0,1212.0, 507.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 4 (Left)
    [
        (915.0, 812.0, 628.0, -180.0, 0.0,  90.0),
        (915.0, 407.0, 628.0, -180.0, 0.0,  90.0), 
        (418.0,  90.0, 628.0, -180.0, 0.0, -180.0), #
        (418.0, 265.0, 628.0, -180.0, 0.0, -180.0),
        (418.0, 440.0, 628.0, -180.0, 0.0, -180.0),
        (418.0, 615.0, 628.0, -180.0, 0.0, -180.0),
        (418.0, 790.0, 628.0, -180.0, 0.0, -180.0),
        (418.0, 965.0, 628.0, -180.0, 0.0, -180.0),
        (418.0,1140.0, 628.0, -180.0, 0.0, -180.0)
    ],
    # LAYER 5 (Left)
    [
        (105.0, 402.0, 749.0, -180.0, 0.0,  90.0),
        (593.0,  90.0, 749.0, -180.0, 0.0, -180.0),
        (593.0, 265.0, 749.0, -180.0, 0.0, -180.0),
        (593.0, 440.0, 749.0, -180.0, 0.0, -180.0),
        (593.0, 615.0, 749.0, -180.0, 0.0, -180.0),
        (593.0, 790.0, 749.0, -180.0, 0.0, -180.0),
        (593.0, 965.0, 749.0, -180.0, 0.0, -180.0),
        (593.0,1140.0, 749.0, -180.0, 0.0, -180.0),
        (105.0,1212.0, 749.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 6 (Left)
    [
        (915.0, 812.0, 867.0, -180.0, 0.0,  90.0),
        (915.0, 407.0, 867.0, -180.0, 0.0,  90.0),
        (418.0,  90.0, 867.0, -180.0, 0.0, -180.0), #
        (418.0, 265.0, 867.0, -180.0, 0.0, -180.0),
        (418.0, 440.0, 867.0, -180.0, 0.0, -180.0), #
        (418.0, 615.0, 867.0, -180.0, 0.0, -180.0),
        (418.0, 790.0, 867.0, -180.0, 0.0, -180.0), #
        (418.0, 965.0, 867.0, -180.0, 0.0, -180.0),
        (418.0,1140.0, 867.0, -180.0, 0.0, -180.0)
    ],
    # LAYER 7 (Left)
    [
        (105.0, 402.0, 991.0, -180.0, 0.0,  90.0),
        (593.0,  90.0, 991.0, -180.0, 0.0, -180.0),
        (593.0, 265.0, 991.0, -180.0, 0.0, -180.0),
        (593.0, 440.0, 991.0, -180.0, 0.0, -180.0),
        (593.0, 615.0, 991.0, -180.0, 0.0, -180.0),
        (593.0, 790.0, 991.0, -180.0, 0.0, -180.0),
        (593.0, 965.0, 991.0, -180.0, 0.0, -180.0), #
        (593.0,1140.0, 991.0, -180.0, 0.0, -180.0),
        (105.0,1212.0, 991.0, -180.0, 0.0,  90.0)
    ],
    # LAYER 8 (Left)
    [
        (915.0, 812.0, 1107.0, -180.0, 0.0,  90.0),
        (915.0, 407.0, 1107.0, -180.0, 0.0,  90.0),
        (418.0,  90.0, 1107.0, -180.0, 0.0, -180.0),
        (418.0, 265.0, 1107.0, -180.0, 0.0, -180.0),
        (418.0, 440.0, 1107.0, -180.0, 0.0, -180.0),
        (418.0, 615.0, 1107.0, -180.0, 0.0, -180.0),
        (418.0, 790.0, 1107.0, -180.0, 0.0, -180.0),
        (418.0, 965.0, 1107.0, -180.0, 0.0, -180.0), #
        (418.0,1140.0, 1107.0, -180.0, 0.0, -180.0)
    ],
    # LAYER 9 (Left)
    [
        (105.0, 402.0,1227.0, -180.0, 0.0,  90.0),
        (593.0,  90.0,1227.0, -180.0, 0.0, -180.0),
        (593.0, 265.0,1227.0, -180.0, 0.0, -180.0),
        (593.0, 440.0,1227.0, -180.0, 0.0, -180.0),
        (593.0, 615.0,1227.0, -180.0, 0.0, -180.0),
        (593.0, 790.0,1227.0, -180.0, 0.0, -180.0),
        (593.0, 965.0,1227.0, -180.0, 0.0, -180.0), #
        (593.0,1140.0,1227.0, -180.0, 0.0, -180.0),
        (105.0,1212.0,1227.0, -180.0, 0.0,  90.0)
    ]
]

right_layers = [
    # LAYER 1 (Right)
    [
        (905.0, 402.0, 265.0, -180.0, 0.0, -90.0),
        (417.0,  80.0, 265.0, -180.0, 0.0,   0.0),
        (417.0, 255.0, 265.0, -180.0, 0.0,   0.0),
        (417.0, 430.0, 265.0, -180.0, 0.0,   0.0),
        (417.0, 605.0, 265.0, -180.0, 0.0,   0.0),
        (417.0, 780.0, 265.0, -180.0, 0.0,   0.0),
        (417.0, 955.0, 265.0, -180.0, 0.0,   0.0),
        (417.0,1130.0, 265.0, -180.0, 0.0,   0.0),
        (905.0,1213.0, 265.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 2 (Right)
    [
        ( 95.0, 808.0, 386.0, -180.0, 0.0, -90.0),
        ( 95.0, 402.0, 386.0, -180.0, 0.0, -90.0),
        (593.0,  80.0, 386.0, -180.0, 0.0,   0.0),
        (593.0, 255.0, 386.0, -180.0, 0.0,   0.0),
        (593.0, 430.0, 386.0, -180.0, 0.0,   0.0),
        (593.0, 605.0, 386.0, -180.0, 0.0,   0.0),
        (593.0, 780.0, 386.0, -180.0, 0.0,   0.0),
        (593.0, 955.0, 386.0, -180.0, 0.0,   0.0),
        (593.0,1130.0, 386.0, -180.0, 0.0,   0.0)
    ],
    # LAYER 3 (Right)
    [
        (905.0, 402.0, 507.0, -180.0, 0.0, -90.0),
        (417.0,  80.0, 507.0, -180.0, 0.0,   0.0),
        (417.0, 255.0, 507.0, -180.0, 0.0,   0.0),
        (417.0, 430.0, 507.0, -180.0, 0.0,   0.0),
        (417.0, 605.0, 507.0, -180.0, 0.0,   0.0),
        (417.0, 780.0, 507.0, -180.0, 0.0,   0.0),
        (417.0, 955.0, 507.0, -180.0, 0.0,   0.0),
        (417.0,1130.0, 507.0, -180.0, 0.0,   0.0),
        (905.0,1213.0, 507.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 4 (Right)
    [
        ( 95.0, 808.0, 628.0, -180.0, 0.0, -90.0),
        ( 95.0, 402.0, 628.0, -180.0, 0.0, -90.0),
        (593.0,  80.0, 628.0, -180.0, 0.0,   0.0),
        (593.0, 255.0, 628.0, -180.0, 0.0,   0.0),
        (593.0, 430.0, 628.0, -180.0, 0.0,   0.0),
        (593.0, 605.0, 628.0, -180.0, 0.0,   0.0),
        (593.0, 780.0, 628.0, -180.0, 0.0,   0.0),
        (593.0, 955.0, 628.0, -180.0, 0.0,   0.0),
        (593.0,1130.0, 628.0, -180.0, 0.0,   0.0)
    ],
    # LAYER 5 (Right)
    [
        (905.0, 402.0, 749.0, -180.0, 0.0, -90.0),
        (417.0, 80.0, 749.0, -180.0, 0.0, 0.0),
        (417.0, 255.0, 749.0, -180.0, 0.0, 0.0),
        (417.0, 430.0, 749.0, -180.0, 0.0, 0.0),
        (417.0, 605.0, 749.0, -180.0, 0.0, 0.0),
        (417.0, 780.0, 749.0, -180.0, 0.0, 0.0),
        (417.0, 955.0, 749.0, -180.0, 0.0, 0.0),
        (417.0, 1130.0, 749.0, -180.0, 0.0, 0.0),
        (905.0, 1213.0, 749.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 6 (Right)
    [
        (95.0, 808.0, 867.0, -180.0, 0.0, -90.0),
        (95.0, 402.0, 867.0, -180.0, 0.0, -90.0),
        (593.0, 80.0, 867.0, -180.0, 0.0, 0.0),
        (593.0, 255.0, 867.0, -180.0, 0.0, 0.0),
        (593.0, 430.0, 867.0, -180.0, 0.0, 0.0),
        (593.0, 605.0, 867.0, -180.0, 0.0, 0.0),
        (593.0, 780.0, 867.0, -180.0, 0.0, 0.0),
        (593.0, 955.0, 867.0, -180.0, 0.0, 0.0),
        (593.0, 1130.0, 867.0, -180.0, 0.0, 0.0)
    ],
    # LAYER 7 (Right)
    [
        (905.0, 402.0, 991.0, -180.0, 0.0, -90.0),
        (417.0, 80.0, 991.0, -180.0, 0.0, 0.0),
        (417.0, 255.0, 991.0, -180.0, 0.0, 0.0),
        (417.0, 430.0, 991.0, -180.0, 0.0, 0.0),
        (417.0, 605.0, 991.0, -180.0, 0.0, 0.0),
        (417.0, 780.0, 991.0, -180.0, 0.0, 0.0),
        (417.0, 955.0, 991.0, -180.0, 0.0, 0.0),
        (417.0, 1130.0, 991.0, -180.0, 0.0, 0.0),
        (905.0, 1213.0, 991.0, -180.0, 0.0, -90.0)
    ],
    # LAYER 8 (Right)
    [
        (95.0, 808.0, 1107.0, -180.0, 0.0, -90.0),
        (95.0, 402.0, 1107.0, -180.0, 0.0, -90.0),
        (593.0, 80.0, 1107.0, -180.0, 0.0, 0.0 ),
        (593.0, 255.0, 1107.0, -180.0, 0.0, 0.0),
        (593.0, 430.0, 1107.0, -180.0, 0.0, 0.0),
        (593.0, 605.0, 1107.0, -180.0, 0.0, 0.0),
        (593.0, 780.0, 1107.0, -180.0, 0.0, 0.0),
        (593.0, 955.0, 1107.0, -180.0, 0.0, 0.0),
        (593.0, 1130.0, 1107.0, -180.0, 0.0, 0.0)
    ],
    # LAYER 9 (Right)
    [
        (905.0, 402.0, 1227.0, -180.0, 0.0, -90.0),
        (417.0, 80.0, 1227.0, -180.0, 0.0, 0.0),
        (417.0, 255.0, 1227.0, -180.0, 0.0, 0.0),
        (417.0, 430.0, 1227.0, -180.0, 0.0, 0.0),
        (417.0, 605.0, 1227.0, -180.0, 0.0, 0.0),
        (417.0, 780.0, 1227.0, -180.0, 0.0, 0.0),
        (417.0, 955.0, 1227.0, -180.0, 0.0, 0.0),
        (417.0, 1130.0, 1227.0, -180.0, 0.0, 0.0),
        (905.0, 1213.0, 1227.0, -180.0, 0.0, -90.0)
    ]
]

# =====================================================================
# Half plan (A→B)
# =====================================================================
# Cada tupla: (layer_origen, slot_origen, layer_destino_halfB, slot_destino_halfB)
# Indica para qué slots la caja se pone en dos mitades:
# - Half-A en el origen
# - Half-B en un destino diferente

half_plan_left  = [(0,8,1,0), (2,8,3,0), (4,8,5,0), (6,8,7,0)]
half_plan_right = [(0,8,1,0), (2,8,3,0), (4,8,5,0), (6,8,7,0)]

# =====================================================================
# Mid por capa (MidA / MidB) en joints
# =====================================================================
# Estos son puntos intermedios en joint space para cada capa.
# Se utilizan para evitar singularidades o rotaciones bruscas de la muñeca.

mid_left_a = [
    posj(0.72, 58.86, 107.11, 0.00, 14.02, 0.72),
    posj(0.72, 49.68, 109.40, 0.00, 20.90, 0.72),
    posj(0.72, 40.89, 109.82, 0.00, 29.27, 0.72),
    posj(0.72, 32.94, 108.37, 0.00, 38.67, 0.72),
    posj(0.72, 52.23, 108.94, 0.00, 18.80, 0.72),
    posj(0.72, 43.37, 109.89, 0.00, 26.71, 0.72),
    posj(0.72, 35.16, 108.98, 0.00, 35.83, 0.72),
    posj(0.72, 27.97, 106.24, 0.00, 45.76, 0.72),
    posj(0.72, 22.09, 101.74, 0.00, 56.14, 0.72)
]

mid_right_a = [
    posj(-181.11, 58.26, 110.56, 0.00, 11.16, -1.11),
    posj(-181.11, 48.75, 112.90, 0.00, 18.33, -1.11),
    posj(-181.11, 39.58, 113.33, 0.00, 27.07, -1.11),
    posj(-181.11, 31.26, 111.85, 0.00, 36.88, -1.11),
    posj(-181.11, 51.64, 112.39, 0.00, 15.96, -1.11),
    posj(-181.11, 42.32, 113.41, 0.00, 24.25, -1.11),
    posj(-181.11, 33.65, 112.49, 0.00, 33.84, -1.11),
    posj(-181.11, 25.99, 109.65, 0.00, 44.35, -1.11),
    posj(-181.11, 19.81, 105.01, 0.00, 55.16, -1.11)
]

def _rot_j6(j, delta):
    """
    Devuelve un nuevo posj con el mismo J1..J5 y J6 rotado en 'delta'.
    Se usa para generar MidB a partir de MidA.
    """
    return posj(j[0], j[1], j[2], j[3], j[4], j[5] + delta)

# MidB = MidA con J6 rotado +90°
mid_left_b  = [ _rot_j6(j,  90.0) for j in mid_left_a  ]
mid_right_b = [ _rot_j6(j,  90.0) for j in mid_right_a ]

# ---------------------- mapa MidB configurable -------------
# Esta tabla define qué (layer,slot) deben usar MidB en lugar de MidA.
midB_map_left = [
    (0,0), (0,8),
    (1,0), (1,1),
    (2,0), (2,8),
    (3,0), (3,1),
    (4,0), (4,8),
    (5,0), (5,1),
    (6,0), (6,8),
    (7,0), (7,1),
    (8,0), (8,8)
]

midB_map_right = list(midB_map_left)

# =====================================================================
# Utilidades geométricas (APPROACH / RETRACT)
# =====================================================================

def mk_off(dz):
    """
    Crea una posx de offset en Z (relativo) con orientaciones 0.
    Se usa para APPROACH/RETRACT en pick/place.
    """
    return posx(0.0, 0.0, dz, 0.0, 0.0, 0.0, rot_mode)


def _approach_offset(side, layer, slot):
    """
    Devuelve el offset (dx, dy) para el APPROACH del PLACE según:
    - Lado (L/R)
    - Cama impar/par
    - Slot 1..9 (slot 9 tiene caso especial en ambos lados)

    layer y slot son 0-based.
    """
    cama = layer + 1    # 1..9
    pos  = slot + 1     # 1..9

    # ================================
    # LADO IZQUIERDO (L)
    # ================================
    if side == "L":
        if cama % 2 == 1:   # camas 1,3,5,7,9
            if pos == 9:
                return (0.0, 50.0)      # slot final -> offset Y
            else:
                return (50.0, 50.0)      # slots 1..8 -> offset X
        else:
            # camas pares
            if pos == 2:
                return (-50.0, -50.0)
            else:
                return (-50.0, 50.0)

    # ================================
    # LADO DERECHO (R)
    # ================================
    if side == "R":
        if cama % 2 == 1:   # camas 1,3,5,7,9
            if pos == 9:
                return (0.0, 50.0)
            else:
                return (-50.0, -50.0)
        else:
            # camas pares
            if pos == 2:
                return (50.0, -50.0)
            else:
                return (+50.0, 50.0)

    # Si por alguna razón el lado no es L/R:
    return (0.0, 0.0)



def mk_off_app(side, layer, slot):
    dx, dy = _approach_offset(side, layer, slot)
    return posx(dx, dy, dz_app, 0.0, 0.0, 0.0, rot_mode)



def get_place(side, layer, slot):
    """
    Devuelve:
      - La pose posx del PLACE (en el frame del pallet)
      - El ID de frame (left_frame/right_frame)
    """
    if side == "L":
        p = left_layers[layer][slot]
        return posx(p[0], p[1], p[2], p[3], p[4], p[5], rot_mode), left_frame
    else:
        p = right_layers[layer][slot]
        return posx(p[0], p[1], p[2], p[3], p[4], p[5], rot_mode), right_frame


def get_app(side, layer, slot):
    pl, rf = get_place(side, layer, slot)
    return trans(pl, mk_off_app(side, layer, slot), rf, rf), rf


def get_ret(side, layer, slot):
    """
    Calcula la pose de RETRACT a partir del PLACE:
    PLACE + (0, 0, dz_ret) en el frame del pallet.
    """
    pl, rf = get_place(side, layer, slot)
    return trans(pl, mk_off(dz_ret), rf, rf), rf


# --------- selección de Half A/B según tabla ----------

def find_half(side, layer, slot):
    """
    Busca en half_plan_left/right si (layer,slot) es un ORIGEN Half-A.
    Devuelve:
      (True, dl, ds)  si es origen Half y (dl,ds) es el destino Half-B
      (False, 0, 0)   si no es origen Half
    """
    plan = half_plan_left if side == "L" else half_plan_right
    for t in plan:
        if t[0] == layer and t[1] == slot:
            return True, t[2], t[3]
    return False, 0, 0

def is_half_destination(side, layer, slot):
    """
    Indica si (layer,slot) es un DESTINO Half-B.
    Se usa para:
      - Saltar esos slots en la corrida normal (run_from).
      - Reconocer cuando el usuario arranca justo en un Half-B.
    """
    plan = half_plan_left if side == "L" else half_plan_right
    for t in plan:
        if t[2] == layer and t[3] == slot:
            return True
    return False

def _is_group_b(side, layer, slot):
    """
    Determina si este (layer,slot) debe usar MidB (J6 +90°)
    según midB_map_left/right.
    """
    if side == "L":
        return (layer, slot) in midB_map_left
    else:
        return (layer, slot) in midB_map_right

def get_mid(side, layer, slot):
    """
    Devuelve el joint target Mid adecuado (A o B) según:
      - Lado (Left/Right)
      - Capa (layer)
      - Slot
    Si la capa excede el tamaño de la lista de mids, devuelve None.
    """
    use_b = _is_group_b(side, layer, slot)
    if side == "L":
        if use_b:
            return mid_left_b[layer]  if layer < len(mid_left_b)  else None
        else:
            return mid_left_a[layer]  if layer < len(mid_left_a)  else None
    else:
        if use_b:
            return mid_right_b[layer] if layer < len(mid_right_b) else None
        else:
            return mid_right_a[layer] if layer < len(mid_right_a) else None

# =====================================================================
# Pick desde conveyor
# =====================================================================

# Pose cartesiana del pick en el conveyor (en conv_frame)
pick_pose = posx(216.513, -393.457, 851.443, 180.00, 0.00, 0.0, rot_mode)


def get_pick():
    """
    Devuelve la pose de pick y el frame del conveyor.
    """
    return pick_pose, conv_frame

def get_pick_app():
    """
    APPROACH del pick: pick_pose + dz_app en Z del conveyor.
    """
    return trans(pick_pose, mk_off(dz_app), conv_frame, conv_frame), conv_frame

def get_pick_ret():
    """
    RETRACT del pick: pick_pose + dz_ret en Z del conveyor.
    """
    return trans(pick_pose, mk_off(dz_ret), conv_frame, conv_frame), conv_frame


def plc_set_robot_state(state_int):
    """Publica el estado del robot al PLC (Robot -> PLC INT %ID344).

    NOTA:
      - El modo MANTENIMIENTO tiene prioridad. Una vez que _in_maintenance es True,
        NO se permite que otros estados (StandBy/Normal/Manual/Idle) lo sobreescriban.
    """
    global _in_maintenance
    if _in_maintenance and state_int != ROBOT_STATE_MAINTENANCE:
        # Bloquea el estado en MANTENIMIENTO hasta que el programa se detenga / reinicie.
        return
    tp_log("PLC estado_robot = " + str(state_int))
    set_output_register_int(ROBOT_STATE_REG, state_int)

def plc_force_robot_state(state_int):
    """Fuerza la publicación del estado al PLC ignorando el 'lock' de mantenimiento.

    Usar SOLO para movimientos controlados como Home seguro, donde queremos que el PLC
    vea que el robot está en movimiento (NORMAL), y al final regresar a MANTENIMIENTO.
    """
    tp_log("PLC robot_state (FORZADO) = " + str(state_int))
    set_output_register_int(ROBOT_STATE_REG, state_int)

def plc_vacuum_idle():
    """Clear vacuum status bits (no vacuum expected)."""
    set_output_register_bit(VAC_OK_BIT, 0)
    set_output_register_bit(VAC_LOST_BIT, 0)

def plc_vacuum_ok():
    """VACUUM OK (mutually exclusive with VACUUM LOST)."""
    set_output_register_bit(VAC_OK_BIT, 1)
    set_output_register_bit(VAC_LOST_BIT, 0)

def plc_vacuum_lost():
    """VACUUM LOST (mutually exclusive with VACUUM OK)."""
    set_output_register_bit(VAC_OK_BIT, 0)
    set_output_register_bit(VAC_LOST_BIT, 1)



def plc_enter_maintenance():
    """Force PLC outputs to MAINTENANCE and clear other transient states.

    Call this anytime maintenance is requested, so:
      - Robot state stays in MAINTENANCE.
      - Vacuum bits are cleared (no stale VAC_LOST / VAC_OK).
      - Pick mode is set to idle.
      - Maintenance flag bit is asserted.
    """
    global _in_maintenance, System_InMaintenance
    _in_maintenance = True
    System_InMaintenance = 1
    plc_set_robot_state(ROBOT_STATE_MAINTENANCE)
    plc_set_maintenance_state(True)
    plc_vacuum_idle()
    plc_set_pick_mode("idle")


def plc_exit_maintenance():
    """Clear maintenance latch (allows other states again)."""
    global _in_maintenance, System_InMaintenance
    System_InMaintenance = 0
    _in_maintenance = False
    plc_set_maintenance_state(False)
    plc_vacuum_idle()
    plc_set_pick_mode("idle")
def plc_set_pick_mode(mode):
    """Envía al PLC el modo de pick como un entero.

    Mapeo propuesto:
      0 = idle
      1 = full
      2 = half_b

    half_a NO se usa en el proceso actual.
    """
    if mode == "full":
        val = 1
    elif mode == "half_b":
        val = 2
    else:
        # Cualquier otro valor (incluido "half_a") se mapea a 0
        val = 0

    tp_log("PLC pick_mode_cmd = " + str(val) + " (modo=" + str(mode) + ")")
    set_output_register_int(PICK_MODE_REG, val)

def plc_set_pick_vac_ok(ok_flag):
    """Backward-compatible helper.
    True  -> VACUUM OK bit ON, VACUUM LOST bit OFF
    False -> both bits OFF (idle)
    """
    if ok_flag:
        tp_log("PLC vacuum_state = OK")
        plc_vacuum_ok()
    else:
        tp_log("PLC vacuum_state = IDLE")
        plc_vacuum_idle()



def plc_set_vacuum_loss(flag):
    """Backward-compatible helper.
    True  -> VACUUM LOST bit ON, VACUUM OK bit OFF
    False -> VACUUM LOST bit OFF (idle)
    """
    if flag:
        tp_log("PLC vacuum_state = LOST")
        plc_vacuum_lost()
    else:
        tp_log("PLC vacuum_state = IDLE")
        plc_vacuum_idle()


def plc_set_maintenance_state(is_on):
    """Publish maintenance flag bit to the PLC (aux bit)."""
    bit_val = 1 if is_on else 0
    tp_log("PLC maint_state_bit = " + str(bit_val))
    set_output_register_bit(MAINT_BIT, bit_val)



def do_pick(mode):
    """
    Secuencia completa de pick con reintentos por fallo de vacío:

      - Hace hasta 2 intentos automáticos.
      - Si falla esos 2 intentos:
          * Pregunta UNA SOLA VEZ si quiere reintentar.
          * Si el usuario elige reintentar:
                - Se permiten otros 2 intentos.
          * Si vuelve a fallar estos 2 intentos, o el usuario elige no reintentar:
                - Se llama a modo mantenimiento (contraseña, sin pallets, etc.).

    Devuelve True si hubo vacío OK, False si se entra a modo mantenimiento.
    """
    # Avisar cómo se pretende hacer el pick (full / half_b)
    plc_set_pick_mode(mode)
    # Por defecto, asumimos que NO hay vacio valido hasta que se compruebe
    plc_set_pick_vac_ok(False)

    attempts = 0
    max_attempts = 2              # intentos por ronda
    extra_retry_used = False      # solo se permite una ronda extra

    while True:
        attempts = attempts + 1


        # 2) Ir al hub sobre el conveyor
        movej(up_conv, vj_fast, aj_fast)

        # 3) Calcular APPROACH, PICK y RETRACT
        a, _ = get_pick_app()
        p, _ = get_pick()
        r, _ = get_pick_ret()

        # 4) Bajar a APPROACH y luego a PICK
        movej(a, v=vj_slow, a=aj_slow, ref=conv_frame)
         # 1) Esperar conveyor listo
        wait_conveyor_ready()
        set_tool("gripper_weight", 0.0, 0.2)
        movel(p, v=vl_slow, a=al_slow, ref=conv_frame)

        # 5) Activar gripper según el modo
        if mode == "full":
            grip_full()
        elif mode == "half_a":
            grip_half_a()
        elif mode == "half_b":
            grip_half_b()
        else:
            tp_log("Modo de pick desconocido: " + str(mode))

        # 6) Esperar vacío OK (si está habilitado)
        if wait_vacuum_ok(mode, timeout=1.5):
            if mode == "full":
                set_tool("full_weight", 0.0, 0.3)
            else:
                set_tool("half_weight", 0.0, 0.3)
            wait(0.3)

            # ÉXITO: subir y salir
            movel(r, v=vl_slow, a=al_slow, ref=conv_frame)
            movej(up_conv, vj_fast, aj_fast)

            # Avisar al PLC que este pick fue valido (hubo vacio)
            plc_set_pick_vac_ok(True)
            if attempts > 1:
                tp_log("Pick recuperado en intento " + str(attempts) +
                       " (modo=" + mode + ").")
            return True

        # 7) FALLO DE VACÍO en este intento
        tp_log("Fallo de vacio en intento " + str(attempts) +
               " (modo=" + mode + ").")

        # Publish VACUUM LOST to the PLC (mutually exclusive with VACUUM OK)
        plc_set_vacuum_loss(True)

        # Soltar la caja en la posición de pick y subir
        rel_by_mode(mode)
        movel(r, v=vl_slow, a=al_slow, ref=conv_frame)
        movej(up_conv, vj_fast, aj_fast)

        # ¿Ya se terminaron los intentos de esta ronda?
        if attempts >= max_attempts:
            # Si ya usamos la ronda extra, se va directo a mantenimiento
            if extra_retry_used:
                tp_log("Fallo de vacio tras reintento extra. Llamando a mantenimiento.")
                # Keep VACUUM LOST ON when the pick fails and we are going to maintenance
                plc_set_vacuum_loss(True)
                go_to_maintenance_mode()
                return False

            # Primera vez que fallan los max_attempts
            tp_popup("Fallo de vacio en pick. Revise gripper y conveyor.", DR_PM_ALARM)
            resp = ask_int_required("1=Reintentar una vez mas, 2=Llamar mantenimiento", 1, 2)


            if resp == 1:
                tp_log("Operador eligio reintentar pick una vez mas.")
                extra_retry_used = True
                attempts = 0       # reseteamos contador para la nueva ronda
                continue
            else:
                tp_log("Operador eligio llamar a mantenimiento tras fallo de vacio en pick.")
                plc_set_vacuum_loss(True)
                go_to_maintenance_mode()
                return False

        # Si aún no se llegaron a los max_attempts de esta ronda,
        # el while continua y se hace otro intento automáticamente.
        tp_log("Reintentando pick (intento " +
               str(attempts + 1) + " de " + str(max_attempts) + ").")




# =====================================================================
# Place (full / half)
# =====================================================================

def do_place(side, layer, slot, rtype):
    """
    Secuencia completa de place en un slot:
      - Mueve al hub del lado (up_left/up_right)
      - Pasa por MidA o MidB (si está definido para esa capa/slot)
      - Va al APPROACH (con offsets X/Y/Z)
      - Baja al PLACE
      - Suelta tipo rtype (full/half_a/half_b)
      - Sube a RETRACT
      - Regresa al hub del lado

    Comportamiento especial ante pérdida de vacío ANTES del place:
      - Se detecta antes de bajar al pallet.
      - Aun así se hace todo el movimiento de place.
      - Ya en el hub se notifica al operador y se pregunta:
          1 = Continuar (se considera un place "bueno" y se sigue al siguiente pick)
          2 = Mantenimiento (se llama go_to_maintenance_mode)

    Devuelve:
      True  -> place terminado y se puede continuar (siguiente acción será un pick)
      False -> se llamó a mantenimiento y NO se debe seguir.
    """
    global _last_place_lost_vacuum
    _last_place_lost_vacuum = False  # por defecto, sin problema

    # Hub según lado
    up = up_left if side == "L" else up_right

    # Calcular place / app / ret
    pl, rp = get_place(side, layer, slot)
    ap, ra = get_app(side, layer, slot)
    rt, rr = get_ret(side, layer, slot)

    # 1) Ir al hub del lado
    movej(up, vj_fast, aj_fast)

    # 2) Detectar posible pérdida de vacío ANTES de bajar
    lost_vacuum = False
    if not has_vacuum_for_mode(rtype):
        lost_vacuum = True
        tp_log("Perdida de vacio detectada ANTES de place. side=" +
               side + " layer=" + str(layer + 1) +
               " slot=" + str(slot + 1) +
               " tipo=" + str(rtype))

    # 3) Movimiento normal de place (siempre se hace)
    use_b = _is_group_b(side, layer, slot)
    m = get_mid(side, layer, slot)
    if not (m == None):
        if use_b:
            tp_log("MidB en " + side + " L" + str(layer+1) + " S" + str(slot+1))
        else:
            tp_log("MidA en " + side + " L" + str(layer+1) + " S" + str(slot+1))
        movej(m, vj_fast, aj_fast)

    movej(ap, v=vj_slow, a=aj_slow, ref=ra)
    movel(pl, v=vl_slow, a=al_slow, ref=rp)

    # Soltar según tipo
    if   rtype == "full":
        rel_full()
    elif rtype == "half_a":
        rel_half_a()
    elif rtype == "half_b":
        rel_half_b()
    else:
        tp_log("WARNING: do_place con tipo desconocido: " + str(rtype))
    
    apply_tool_weight_after_place(rtype, lost_vacuum)
    
    plc_set_pick_vac_ok(False)  # tras el place, no hay vacío

    movel(rt, v=vl_slow, a=al_slow, ref=rr)

    # Regresar al hub
    movej(up, vj_fast, aj_fast)

    # 4) Si NO hubo pérdida de vacío -> todo OK
    if not lost_vacuum:
        return True

    # 5) Si hubo pérdida de vacío ANTES de place:
    #    ya estamos en el hub; ahora se le pregunta al operador qué hacer.
    plc_set_vacuum_loss(1)

    tp_popup("Perdida de vacio antes de place. Revise la tarima.", DR_PM_ALARM)
    resp = ask_int_required("1=Continuar paletizado (se considera good place), 2=Llamar mantenimiento", 1, 2)

    if resp == 1:
        tp_log("Operador eligio CONTINUAR tras perdida de vacio en place. "
               "Se considerara este place como COMPLETADO.")
        plc_set_vacuum_loss(0)

        # Muy importante:
        # Este flag permite que la lógica externa (Half, etc.) sepa que
        # hubo pérdida de vacío pero el operador decidió continuar.
        _last_place_lost_vacuum = True
        return True
    else:
        tp_log("Operador eligio llamar a mantenimiento tras perdida de vacio en place.")
        go_to_maintenance_mode()
        plc_set_pick_vac_ok(False)
        return False


# =====================================================================
# Lógica Half-A / Half-B
# =====================================================================

# Conjunto que almacena qué destinos Half-B ya han sido llenados
_halfB_filled = set()

def do_half(side, layer, slot, is_half, dl, ds):
    """
    Maneja la lógica de Half-A / Half-B para un slot.

    Si is_half == True:
      - Coloca una mitad en el slot origen
      - Coloca la otra mitad en el destino (dl, ds), si procede.

    IMPORTANTE (por espejo físico):
      Lado izquierdo  (side == "L"):
        - Origen  -> Half-A
        - Destino -> Half-B

      Lado derecho   (side == "R"):
        - Origen  -> Half-B
        - Destino -> Half-A

    Si en el place de origen hay pérdida de vacío y el operador elige CONTINUAR,
    se considera completado el origen y NO se intenta el destino.
    """
    global _halfB_filled
    global _last_place_lost_vacuum

    if is_half:
        # Decidir qué mitad va en origen/destino según el lado
        if side == "L":
            origin_rtype = "half_a"
            dest_rtype   = "half_b"
        else:  # side == "R"
            origin_rtype = "half_b"
            dest_rtype   = "half_a"

        tp_log("Half: side=" + side +
               " ORIG L" + str(layer+1) + " S" + str(slot+1) +
               " (" + origin_rtype + ")" +
               " -> DEST L" + str(dl+1) + " S" + str(ds+1) +
               " (" + dest_rtype + ")")

        # 1) Colocar mitad en el ORIGEN
        ok_origin = do_place(side, layer, slot, origin_rtype)
        if not ok_origin:
            tp_log("do_half: mantenimiento solicitado al colocar mitad de origen.")
            return False

        # Si hubo pérdida de vacío y el operador eligió continuar,
        # NO intentamos la segunda mitad.
        if _last_place_lost_vacuum:
            tp_log("do_half: perdida de vacio en origen, operador continuo. "
                   "Se omite destino y se continua con siguiente slot.")
            return True

        # 2) Verificar si el DESTINO ya fue llenado antes
        if (side, dl, ds) in _halfB_filled:
            tp_log("Destino Half ya estaba lleno. Omitiendo: side=" + side +
                   " L" + str(dl+1) + " S" + str(ds+1))
            return True

        # 3) Comprobar que el destino es válido en la tabla
        if side == "L":
            ok_dest = (dl < len(left_layers) and ds < len(left_layers[dl]))
        else:
            ok_dest = (dl < len(right_layers) and ds < len(right_layers[dl]))

        if not ok_dest:
            tp_log("Destino Half fuera de rango. Solo se coloca la mitad de origen.")
            return True

        # 4) Ajustar nivel de lifter para la capa de destino
        dest_level = lifter_level_for_layer(dl)
        lifter_set_level(side, dest_level)

        movej((up_right if side == "R" else up_left),
              v=vj_slow, a=aj_slow)

        tp_log("Colocando mitad destino en side=" + side +
               " L" + str(dl+1) + " S" + str(ds+1) +
               " (" + dest_rtype + ")")

        ok_dest_place = do_place(side, dl, ds, dest_rtype)
        if not ok_dest_place:
            tp_log("do_half: mantenimiento solicitado al colocar mitad de destino.")
            return False

        # Registrar este destino como lleno
        _halfB_filled.add((side, dl, ds))
        return True

    else:
        # NO es slot Half: caja FULL normal
        ok_full = do_place(side, layer, slot, "full")
        if not ok_full:
            tp_log("do_half: mantenimiento solicitado al colocar FULL.")
            return False

        return True


# =====================================================================
# tp helpers (Teach Pendant)
# =====================================================================

def clamp(val, lo, hi):
    """
    Limita el valor 'val' al rango [lo, hi].
    """
    if val < lo: return lo
    if val > hi: return hi
    return val

def ask_int_required(prompt, lo, hi):
    """
    Pide un entero entre [lo, hi] y NO deja continuar hasta que el operador
    ingrese un valor válido dentro del rango.
    """
    while True:
        v = tp_get_user_input(prompt, DR_VAR_INT)

        # Si por cualquier razón viene algo raro, lo tratamos como inválido
        if (v >= lo) and (v <= hi):
            return v

        msg = "Valor invalido. Ingrese un numero entre " + str(lo) + " y " + str(hi)
        tp_popup(msg, DR_PM_WARNING)
        tp_log("ask_int_required: valor fuera de rango (" + str(v) + "). Reintentando...")

def ask_str_required(prompt):
    """
    Pide un string NO vacío. Repite hasta que el operador escriba algo.
    """
    while True:
        s = tp_get_user_input(prompt, DR_VAR_STR)

        # En Doosan normalmente no hay None, pero por seguridad lo tratamos igual
        if (s is not None) and (s != ""):
            return s

        tp_popup("Entrada vacia. Por favor ingrese un texto.", DR_PM_WARNING)
        tp_log("ask_str_required: string vacio. Reintentando...")



# ===================== SYSTEM PERSISTENT VARIABLES =====================
# Variables persistentes en el controlador (prefijo System_)
# Guardan el progreso por lado (independiente L/R).
#
# Nota: No se inicializan aqui para NO sobreescribir valores persistidos.
# Se actualizan SOLO cuando el usuario selecciona inicio o cuando avanza el ciclo.

def system_update_progress(side, layer, slot):
    """Actualizar variables persistentes de progreso.

    - System_Side: lado actual en ejecución ("L" o "R")
    - System_Layer_L/System_Slot_L: progreso del lado izquierdo (0-based)
    - System_Layer_R/System_Slot_R: progreso del lado derecho (0-based)
    """
    global System_Side, System_Layer_L, System_Slot_L, System_Layer_R, System_Slot_R

    System_Side = side

    if side == "L":
        System_Layer_L = layer
        System_Slot_L  = slot
    else:
        System_Layer_R = layer
        System_Slot_R  = slot

        tp_log("System progress -> side=" + str(side) + " layer=" + str(layer) + " slot=" + str(slot))


def warn_if_starting_before_last(side, layer, slot):
    """
    Si el operador intenta iniciar ANTES del último punto guardado para ese lado,
    muestra advertencia por posible bajada del lifter y riesgo de colisión.
    Devuelve True si se permite continuar, False si se debe volver a pedir datos.
    """
    # Último progreso guardado por lado
    if side == "L":
        last_layer = System_Layer_L
        last_slot  = System_Slot_L
    else:
        last_layer = System_Layer_R
        last_slot  = System_Slot_R

    # Si no tienes valores inicializados o vienen raros, mejor no bloquear
    # (asumiendo que 0..8 capas y 0..8 slots)
    if last_layer is None or last_slot is None:
        return True

    # Comparación lexicográfica (layer primero, luego slot)
    going_back = (layer < last_layer) or ((layer == last_layer) and (slot < last_slot))

    if not going_back:
        return True

    # Advertencia fuerte + confirmación
    msg = ("ADVERTENCIA: El inicio seleccionado es ANTERIOR al último progreso guardado, El elevador (Lift100) podría BAJAR y ocasionar una colisión")
    tp_popup(msg, DR_PM_WARNING)

    resp = ask_int_required("Confirmar: 1=Continuar, 2=Reingresar", 1, 2)
    return (resp == 1)


def ask_mode():
    """
    Pregunta el modo de paletizado:
      1 -> Solo un lado (modo single)
      2 -> Ambos lados (modo dual)

    Devuelve 'single' o 'both'.
    """
    msg = "Seleccione modo de paletizado: 1 = Solo un lado, 2 = Ambos lados"
    v = ask_int_required(msg, 1, 2)

    if v == 1:
        tp_log("Modo seleccionado: SOLO UN LADO.")
        return "single"
    else:
        tp_log("Modo seleccionado: AMBOS LADOS.")
        return "both"


def ask_side():
    """
    Pregunta en qué lado quiere iniciar el usuario.
    El usuario introduce 'A' o 'B', que se mapean a:
      'A'/'a' -> 'L' (Left)
      'B'/'b' -> 'R' (Right)
    No permite dejar vacío ni otro caracter.
    """
    while True:
        s = ask_str_required("Seleccione en que Lado quiere iniciar A/B")

        if s == "A" or s == "a":
            return "L"
        if s == "B" or s == "b":
            return "R"

        tp_log("Entrada invalida en ask_side(): '" + str(s) + "'.")
        tp_popup("Entrada invalida. Use A para Izquierda o B para Derecha.", DR_PM_WARNING)

def ask_layer(side):
    """
    Pregunta en qué cama (layer) quiere iniciar.
    El usuario responde 1..N y se convierte a índice 0-based.
    """
    n = len(left_layers) if side == "L" else len(right_layers)
    v = ask_int_required("Seleccione en que Cama quiere iniciar 1 - " + str(n), 1, n)
    return v - 1  # 0-based

def ask_slot(side, layer):
    """
    Pregunta en qué slot de la cama quiere iniciar.
    El usuario responde 1..N y se convierte a índice 0-based.
    """
    n = len(left_layers[layer]) if side == "L" else len(right_layers[layer])
    v = ask_int_required("Seleccione en que Slot quiere iniciar 1 - " + str(n), 1, n)
    return v - 1  # 0-based


def ask_initial_action():
    """
    Menu inicial:
      1 -> Home seguro
      2 -> Mantenimiento
      3 -> Paletizado
    """
    msg = "Seleccione accion inicial: 1=Home seguro, 2=Mantenimiento, 3=Paletizado"
    return ask_int_required(msg, 1, 3)


def ask_home_followup_action():
    """
    Menu despues de hacer home seguro:
      1 -> Mantenimiento
      2 -> Paletizado
    """
    msg = "Seleccione accion: 1=Mantenimiento, 2=Paletizado"
    return ask_int_required(msg, 1, 2)




# =====================================================================
# helpers para lecturas posx/posj y safe_home
# =====================================================================

# Valores de referencia en X para distinguir si el robot está sobre pallets o conveyor
_left_cx  =  250.0
_right_cx = -1266.0
_conv_cx = 0.00

def _pal_hub(cx):
    """
    Selecciona el hub (up_left o up_right) más cercano según la X actual (cx).
    """
    if abs(cx - _left_cx) <= abs(cx - _right_cx):
        return up_left
    else:
        return up_right

def _nearest_hub_by_x(cx):
    """
    Devuelve el hub (up_left / up_right / up_conv) cuya X-centro
    esté más cercana a la X actual del robot.
    """
    dL = abs(cx - _left_cx)
    dR = abs(cx - _right_cx)
    dC = abs(cx - _conv_cx)

    if dC <= dL and dC <= dR:
        return up_conv
    elif dL <= dR:
        return up_left
    else:
        return up_right

def _get_posx_only():
    """
    Devuelve solo la pose cartesiana actual (sin referencia) desde get_current_posx().
    Maneja ambos formatos posibles.
    """
    res = get_current_posx()
    try:
        pose, _ = res
        return pose
    except:
        return res

def _get_posj_only():
    """
    Devuelve solo la pose en joints actual desde get_current_posj().
    Maneja ambos formatos posibles.
    """
    res = get_current_posj()
    try:
        j, _ = res
        return j
    except:
        return res

# Tolerancia en grados para considerar que el robot está en home
tol_j_deg = 2.0

def _is_home():
    """
    Verifica si la posición actual del robot está dentro de una tolerancia
    alrededor de la posición 'home'.
    """
    jcur = _get_posj_only()
    return (abs(jcur[0] - home[0]) <= tol_j_deg and
            abs(jcur[1] - home[1]) <= tol_j_deg and
            abs(jcur[2] - home[2]) <= tol_j_deg and
            abs(jcur[3] - home[3]) <= tol_j_deg and
            abs(jcur[4] - home[4]) <= tol_j_deg and
            abs(jcur[5] - home[5]) <= tol_j_deg)

def _is_safe_pose():
    """
    Verifica si la posición actual del robot está dentro de una tolerancia
    alrededor de la posición 'safe_pose'.
    """
    jcur = _get_posj_only()
    return (abs(jcur[0] - safe_pose[0]) <= tol_j_deg and
            abs(jcur[1] - safe_pose[1]) <= tol_j_deg and
            abs(jcur[2] - safe_pose[2]) <= tol_j_deg and
            abs(jcur[3] - safe_pose[3]) <= tol_j_deg and
            abs(jcur[4] - safe_pose[4]) <= tol_j_deg and
            abs(jcur[5] - safe_pose[5]) <= tol_j_deg)


def safe_home():
    """
    Lleva al robot de forma segura a la posición 'home':
      - Si ya está en home, no hace nada.
      -Si esta en safe pose se va a home.
      - Si no:
          1) Sube 100mm en Z en el frame base (movimiento relativo).
          2) Va al hub más cercano (pallets o conveyor) según la Y actual.
          3) Va a 'home'.
    """
    if _is_home():
        return
    
    if _is_safe_pose():
        movej(home, v=vj_slow, a=aj_slow)
        return

    # Obtener pose cartesiana actual
    cur = _get_posx_only()
    cx = cur[0]
    cy = cur[1]

    # Subir 100 mm en Z de forma relativa (para despegar del entorno)
    pz = posx(0, 0, 100, 0, 0, 0, rot_mode)
    movel(pz, time=2, ref=DR_BASE, mod=DR_MV_MOD_REL)

    # Elegir ruta segura según la Y actual (sobre pallets o sobre conveyor)
    hub = _nearest_hub_by_x(cx)
    movej(hub, v=vj_slow, a=aj_slow)


    # Finalmente ir a home
    movej(home, v=vj_slow, a=aj_slow)

def go_safe_before_lifter():
    """
    Movimiento a una pose segura antes de operar el lifter.
    Se usa para minimizar riesgos de colisión cuando se cambian niveles.
    """
    movej(safe_pose, v=vj_slow, a=aj_slow)

def go_to_maintenance_mode():
    """
    Rutina de llamada a mantenimiento:
      - Pide contraseña de mantenimiento (se repite hasta que sea correcta).
      - Verifica que no haya pallets presentes (L/R).
        * Si hay, pide retirar y espera a que los bits se apaguen.
      - Lleva al robot a una pose segura para mover el lifter.
      - Baja el lifter y restaura frames (nivel 0).
      - Lleva al robot a la pose de mantenimiento.
      - Detiene el programa.
    """
    global _in_maintenance
    set_tool("gripper_weight", 0.0, 0.2)
    rel_full()
    # Enter/lock maintenance immediately (clear other transient outputs)
    plc_enter_maintenance()
    # Al entrar a mantenimiento, NO queremos estados transitorios activos
    plc_set_pick_vac_ok(False)
    plc_set_vacuum_loss(False)

    # 1) Pedir contraseña en bucle hasta que sea correcta
    while True:
        pwd = tp_get_user_input("Ingrese contrasena de mantenimiento", DR_VAR_STR)

        if pwd == MAINT_PASSWORD:
            tp_log("Contrasena de mantenimiento correcta. Entrando a modo mantenimiento.")
            break

        tp_popup("Contrasena incorrecta. Intente de nuevo.", DR_PM_ALARM)
        tp_log("Contrasena de mantenimiento incorrecta. Reintentando...")
    # 2) Verificar pallets presentes
    if is_pallet_present("L") or is_pallet_present("R"):
        tp_popup("Retire ambas tarimas antes de mantenimiento.", DR_PM_WARNING)
        tp_log("Esperando retiro de tarimas para mantenimiento.")

        if is_pallet_present("L"):
            wait_remove_finished_pallet("L")
        if is_pallet_present("R"):
            wait_remove_finished_pallet("R")

    # 3) Ir a pose segura antes de mover el lifter
    go_safe_before_lifter()

    # 4) Bajar lifter y restaurar frames (nivel 0)
    lifter_restore_frames()
    # 5) Llevar al robot a la pose de mantenimiento
    movej(maint_safe_pose, v=vj_slow, a=aj_slow)

    tp_log("Robot en pose de mantenimiento. Programa detenido.")
    stop(DR_QSTOP)


# =====================================================================
def finish_side(side):
    """
    Secuencia estándar de finalización de un lado:
      - Log de fin de lado.
      - Ir a posición segura antes de mover el lifter.
      - Pedir que retiren la tarima.
      - Esperar a que la tarima sea retirada.
      - Restaurar frames y nivel lógico del lifter a 0.
    """
    global _in_maintenance
    if _in_maintenance:
        tp_log("finish_side: omitido porque estamos en modo mantenimiento.")
        return
    tp_log("Lado " + side + " finalizado.")
    go_safe_before_lifter()

    plc_set_robot_state(ROBOT_STATE_MANUAL)
    tp_popup("Retire la tarima terminada del lado " + side + ".", DR_PM_MESSAGE)
    wait_remove_finished_pallet(side)
    tp_popup("Cuidado! El paletizado continuará", DR_PM_WARNING)

    lifter_restore_frames()
    # After manual pallet removal, we are back to standby (waiting / next decisions)
    plc_set_robot_state(ROBOT_STATE_STANDBY)

# =====================================================================
# rutina: ejecutar desde (layer,slot) hasta acabar el lado
# =====================================================================

def run_from(side, start_layer, start_slot):
    """
    Ejecuta la secuencia completa de paletizado desde (start_layer,start_slot)
    hasta completar todas las capas y slots del lado indicado.

    Maneja:
      - Ajuste de nivel del lifter por cada cama.
      - Slots destino Half-B que deben saltarse (ya llenados).
      - Caso especial: última caja de la cama 9 (solo Half-B).
      - Lógica general FULL / Half-A → Half-B.
    """
    # Seleccionar la tabla de layers según el lado
    layers = left_layers if side == "L" else right_layers
    n_layers = len(layers)
    layer = start_layer

    tp_log("run_from: lado " + side +
           " inicio en L" + str(start_layer+1) +
           " S" + str(start_slot+1))

    # Actualizar progreso persistente al inicio del ciclo
    system_update_progress(side, start_layer, start_slot)

    # Bucle por capas
    while layer < n_layers:
        # Determinar nivel lógico del lifter para esta capa
        lvl = lifter_level_for_layer(layer)
        lifter_set_level(side, lvl)

        # Número de slots en esta capa
        n_slots = len(layers[layer])

        # Si es la capa inicial, empezamos en start_slot; si no, desde 0
        s0 = start_slot if layer == start_layer else 0
        slot = s0

        # Bucle por slots dentro de la capa
        while slot < n_slots:
            # Saltar slots que son destino Half-B (ya fueron llenados por do_half)
            if is_half_destination(side, layer, slot):
                tp_log("run_from: saltando destino Half-B L" +
                       str(layer+1) + " S" + str(slot+1))
                slot = slot + 1
                continue

            # Actualizar progreso persistente para este slot
            system_update_progress(side, layer, slot)

            # ---- CASO ESPECIAL: última caja de la cama 9 (solo Half-B) ----
            if (layer == n_layers - 1) and (slot == n_slots - 1):
                tp_log("Última caja de la cama 9: sólo Half-B en " +
                       side + " L" + str(layer+1) +
                       " S" + str(slot+1))

                # Aquí se toma directamente Half-B del conveyor
                ok_pick = do_pick("half_b")
                if not ok_pick:
                    tp_log("Abortando lado " + side +
                           " por fallo de vacío en la última caja.")
                    return

                # Se coloca como Half-B en el último slot
                ok_last = do_place(side, layer, slot, "half_b")
                if not ok_last:
                    tp_log("run_from: mantenimiento solicitado en ultima caja; se aborta lado.")
                    return

                tp_log("Última caja completada en " + side +
                       " L" + str(layer+1) +
                       " S" + str(slot+1) +
                       ". Fin de run_from para este lado.")
                return

            # ---- CASO GENERAL: cajas FULL / Half-A → Half-B ----
            tp_log("run_from: Colocando en " + side +
                   " L" + str(layer+1) +
                   " S" + str(slot+1))

            # Tomar caja completa del conveyor
            ok_pick = do_pick("full")
            if not ok_pick:
                tp_log("Abortando lado " + side +
                       " por fallo de vacío en L" +
                       str(layer+1) + " S" + str(slot+1))
                return  # salir de run_from, no ir a place

            # Determinar si este slot es Half (origen) y su destino
            is_h, dl, ds = find_half(side, layer, slot)

            # Ejecutar lógica de Half-A/Half-B o FULL
            ok_place = do_half(side, layer, slot, is_h, dl, ds)
            if not ok_place:
                tp_log("run_from: se salio por mantenimiento en " +
                       side + " L" + str(layer+1) + " S" + str(slot+1))
                return

            # Avanzar al siguiente slot
            slot = slot + 1

        # Siguiente capa
        layer = layer + 1

    tp_log("run_from: lado " + side + " completado.")


# =====================================================================
def run_side_once(side, layer, slot):
    """
    Ejecuta un ciclo completo de paletizado SOLO para el lado 'side',
    comenzando en (layer, slot), respetando:
      - Caso especial: arranque exactamente en última caja (cama 9, slot 9).
      - Caso especial: arranque en destino Half-B.
      - Caso normal: FULL / Half-A → Half-B.

    Al terminar:
      - Deja el robot en posición segura de retirada (finish_side).
      - Espera a que retiren la tarima.
      - Restaura frames y lifter (nivel 0).

    NO toca el otro lado ni regresa a HOME.
    """
    global _halfB_filled
    _halfB_filled = set()

    layers = left_layers if side == "L" else right_layers

    # Asegurar pallet presente en el lado seleccionado
    if not is_pallet_present(side):
        tp_log("No hay tarima en el lado " + side + ". Esperando a que la coloquen...")
        tp_popup("No hay tarima esperando a que la coloquen...", DR_PM_MESSAGE)
        wait_pallet_present(side)
        tp_popup("Cuidado! El paletizado continuará", DR_PM_WARNING)

    n_layers = len(layers)
    n_slots_in_layer = len(layers[layer])

    # ---------- CASO ESPECIAL 1: arranque EXACTAMENTE en última caja ----------
    # Es decir, estamos iniciando directamente en la última cama y el último slot.
    if (layer == n_layers - 1) and (slot == n_slots_in_layer - 1):
        tp_log("Arranque en última caja de la cama 9: sólo Half-B.")

        # Ajustar nivel del lifter a esta cama
        lvl0 = lifter_level_for_layer(layer)
        lifter_set_level(side, lvl0)

        # Tomar una media pieza (Half-B) del conveyor
        ok_pick = do_pick("half_b")
        if not ok_pick:
            tp_log("Abortando lado " + side +
                   " por fallo de vacío en la última caja (arranque especial).")
            finish_side(side)
            return

        # Colocar Half-B en ese slot
        ok2 = do_place(side, layer, slot, "half_b")
        if not ok2:
            tp_log("run_side_once: mantenimiento solicitado en ultima caja (arranque especial).")
            finish_side(side)
            return

        # Finalizar lado (posición segura + retirar tarima + restaurar frames/lifter)
        finish_side(side)
        return

    # ---------- CASO ESPECIAL 2: slot inicial es destino Half-B ----------
    # Si el usuario empieza en un slot que es destino Half-B, significa que
    # hay que colocar solo la media caja B en ese slot, y luego continuar.
    if is_half_destination(side, layer, slot):
        tp_log("Arranque en Half-B: se toma media pieza y se coloca en este slot.")

        # Ajustar nivel del lifter para esa cama
        lvl0 = lifter_level_for_layer(layer)
        lifter_set_level(side, lvl0)

        # Tomar media caja Half-B del conveyor
        ok_pick = do_pick("half_b")
        if not ok_pick:
            tp_log("Abortando lado " + side +
                   " por fallo de vacío al arrancar en Half-B.")
            finish_side(side)
            return
            
        # Colocar Half-B en este slot
        ok2 = do_place(side, layer, slot, "half_b")
        if not ok2:
            tp_log("run_side_once: mantenimiento solicitado al colocar Half-B inicial.")
            finish_side(side)
            return

        # Registrar este destino Half-B como lleno
        _halfB_filled.add((side, layer, slot))


        # Calcular el siguiente slot donde continuar
        next_layer = layer
        next_slot  = slot + 1
        if next_slot >= n_slots_in_layer:
            # Si nos pasamos del último slot de la capa, avanzamos de capa
            next_layer = next_layer + 1
            next_slot  = 0

        # Si todavía hay capas por paletizar, continuar con run_from
        if next_layer < len(layers):
            run_from(side, next_layer, next_slot)

        # Al final, terminar el lado
        finish_side(side)
        return

    # ----------------- CASO NORMAL: slot inicial NO es destino Half-B -----------------
    # Se asume que arrancamos en un slot que es:
    #   - FULL normal, o
    #   - Origen Half-A.
    lvl0 = lifter_level_for_layer(layer)
    lifter_set_level(side, lvl0)

    # Tomar caja completa (FULL) para el primer slot
    ok_pick = do_pick("full")
    if not ok_pick:
        tp_log("Abortando lado " + side +
               " por fallo de vacío en el slot inicial L" +
               str(layer+1) + " S" + str(slot+1))
        finish_side(side)
        return

    # Revisar si este slot inicial es Half-A y su destino
    is_half, dl, ds = find_half(side, layer, slot)
    # Ejecutar lógica FULL o Half-A/Half-B
    ok_place = do_half(side, layer, slot, is_half, dl, ds)
    if not ok_place:
        tp_log("run_side_once: se salio por mantenimiento en slot inicial.")
        finish_side(side)
        return

    # Correr el resto del lado desde el siguiente slot
    run_from(side, layer, slot + 1)

    # Finalizar lado
    finish_side(side)


# =====================================================================
# MAIN
# =====================================================================

def main():
    """
    Flujo principal del programa.

    Flujo:
      1) Inicializar TCP, tool y lifter, y sincronizar frames segun nivel actual.
      2) Preguntar accion inicial:
           1 = Home seguro
           2 = Mantenimiento
           3 = Paletizado
      3) Si se elige Home seguro:
           - Ejecutar safe_home()
           - Preguntar:
                1 = Mantenimiento
                2 = Paletizado
      4) Si se elige Mantenimiento (directo o despues de Home):
           - Ejecutar go_to_maintenance_mode() y terminar.
      5) Si se elige Paletizado:
           - Entrar directo al flujo de paletizado
             (preguntar modo, lado, cama, slot, etc.)
           - SIN llamar a safe_home automaticamente.
    """
    global _lifter_level, _in_maintenance, System_InMaintenance

    # ------------- Configuracion basica de herramienta -------------
    set_tcp("custom_gripper")
    set_tool_shape("gripper_shape")
    set_tool("gripper_weight", 0.0, 0.2)

    # ------------- Estado inicial hacia el PLC ---------------------
    # Mantener el modo mantenimiento entre reinicios del programa.
    # System_InMaintenance: 1 => en/desde mantenimiento, 0 => normal.
    _in_maintenance = (System_InMaintenance == 1)

    if _in_maintenance:
        # No permitir que STANDBY (u otros) sobreescriban MAINTENANCE.
        plc_enter_maintenance()
    else:
        plc_set_robot_state(ROBOT_STATE_STANDBY)
        plc_set_maintenance_state(False)
        plc_set_pick_vac_ok(False)
        plc_set_vacuum_loss(False)
        plc_set_pick_mode("idle")

# ------------- Inicializacion / sincronizacion del lifter ------
    safe_home()
    lifter_safe_init()

    if or_lift.isconn():
        pos = or_lift.get_pos()
        level_actual = lifter_level_from_pos(pos)
        tp_log("Lift100 detectado en pos=" + str(pos) +
               " mm, nivel logico estimado=" + str(level_actual))
    else:
        tp_log("Lift100 no conectado al inicio: se asume nivel 0.")
        level_actual = 0

    _lifter_level = level_actual
    apply_level_to_frames(level_actual)

        # ------------- Menu inicial: Home / Mantenimiento / Paletizado ---
    # Si el programa se reinicia mientras el robot está en MAINTENANCE,
    # SOLO se permite ejecutar Home seguro. Además, antes de permitir cualquier
    # movimiento, se verifica que NO haya tarimas presentes en L ni en R.
    if _in_maintenance:
        plc_enter_maintenance()
        tp_log("Reinicio en MAINTENANCE: solo se permite Home seguro.")
        action = ask_int_required("Robot en MANTENIMIENTO. Unica opcion: 1=Home seguro", 1, 1)
        wait_no_pallets_present_both_sides()
    else:
        action = ask_initial_action()


    if action == 1:
        # -----------------
        # HOME SEGURO
        # Durante el movimiento queremos reflejar estado NORMAL (robot en operación).
        # Si venimos de MANTENIMIENTO, el lock impide cambiar con plc_set_robot_state,
        # por eso usamos plc_force_robot_state SOLO durante el home.
        # -----------------
        if _in_maintenance:
            plc_force_robot_state(ROBOT_STATE_NORMAL)
        else:
            plc_set_robot_state(ROBOT_STATE_NORMAL)

        plc_vacuum_idle()
        safe_home()

        # Al terminar Home seguro, regresar al estado correcto
        if _in_maintenance:
            # IMPORTANTE:
            # Venimos de mantenimiento. Despues del Home seguro queremos:
            # 1) Resetear la señal/latch de mantenimiento hacia el PLC
            # 2) Volver a STANDBY para permitir el menú normal
            plc_exit_maintenance()
            plc_set_robot_state(ROBOT_STATE_STANDBY)
            plc_vacuum_idle()
        else:
            plc_set_robot_state(ROBOT_STATE_STANDBY)
            plc_vacuum_idle()

        # Despues de home: elegir entre Mantenimiento o Paletizado
        next_action = ask_home_followup_action()
        if next_action == 1:
            # Mantenimiento
            go_to_maintenance_mode()
            return
        # Si el robot venia de mantenimiento, liberar el latch antes de paletizar
        plc_exit_maintenance()
        # Si next_action == 2 -> Paletizado; continua mas abajo SIN safe_home

    elif action == 2:
        # Mantenimiento directo
        go_to_maintenance_mode()
        return

    else:
        # action == 3: Paletizado directo
        # NO se llama safe_home aqui
        tp_log("Accion inicial: paletizado directo (sin home seguro).")

    # -----------------------------------------------------------------
    # A partir de aqui: flujo normal de paletizado (igual que antes)
    # -----------------------------------------------------------------

    mode = ask_mode()        # 'single' o 'both'

    side  = ask_side()       # 'L' o 'R'
    layer = ask_layer(side)  # 0-based
    slot  = ask_slot(side, layer)  # 0-based

    while not warn_if_starting_before_last(side, layer, slot):
        layer = ask_layer(side)
        slot  = ask_slot(side, layer)


    # Guardar selección del operador en variables persistentes
    system_update_progress(side, layer, slot)

    plc_set_robot_state(ROBOT_STATE_NORMAL)

    tp_log("Inicio en " + side +
           " L" + str(layer+1) +
           " S" + str(slot+1))

    other_side = "R" if side == "L" else "L"

    if mode == "single":
        while True:
            tp_log("Iniciando ciclo de tarima en lado " + side +
                   " desde L" + str(layer+1) +
                   " S" + str(slot+1))

            plc_set_robot_state(ROBOT_STATE_NORMAL)


            run_side_once(side, layer, slot)
            # Si durante el ciclo se entró a mantenimiento, salir del bucle
            if _in_maintenance:
                tp_log("Modo mantenimiento activo. Saliendo del bucle de tarimas (single).")
                stop(DR_QSTOP)
                return

            tp_log("Esperando nueva tarima en lado " + side +
                   " para iniciar una nueva paletizacion...")
            tp_popup("Coloque una NUEVA tarima en el lado " + side +
                     " para continuar.", DR_PM_MESSAGE)

            wait_pallet_present(side)
            tp_popup("Cuidado! El paletizado continuará", DR_PM_WARNING)

            layer = 0
            slot  = 0
            tp_log("Nueva tarima detectada en lado " + side +
                   ". Reiniciando desde L1 S1.")

    else:
        plc_set_robot_state(ROBOT_STATE_NORMAL)
        run_side_once(side, layer, slot)

        # Si se activó mantenimiento en el primer lado, no seguimos
        if _in_maintenance:
            tp_log("Modo mantenimiento activo tras primer lado. No se paletiza el otro lado.")
            return

        if not is_pallet_present(other_side):
            tp_log("No hay tarima en el lado " + other_side + ". Esperando a que la coloquen...")
            tp_popup("Coloque una tarima en el lado " + other_side + " para continuar.", DR_PM_MESSAGE)
            wait_pallet_present(other_side)
            tp_popup("Cuidado! El paletizado continuará", DR_PM_WARNING)

        tp_log("Iniciando lado " + other_side + " desde L1 S1.")
        plc_set_robot_state(ROBOT_STATE_NORMAL)
        run_from(other_side, 0, 0)


        # Si durante el segundo lado se entró en mantenimiento, no hacemos finish_side ni home
        if _in_maintenance:
            tp_log("Modo mantenimiento activo durante el segundo lado. Saliendo sin finish_side.")
            return

        finish_side(other_side)

    # Solo regresar a HOME si NO estamos en modo mantenimiento
    if not _in_maintenance:
        movej(home, v=vj_fast, a=aj_slow)
        plc_set_robot_state(ROBOT_STATE_IDLE)
        plc_vacuum_idle()
        plc_set_pick_mode("idle")
    else:
        tp_log("Modo mantenimiento activo. No se regresa a home.")


# Llamada al MAIN para iniciar el flujo cuando se ejecuta el script.
main()